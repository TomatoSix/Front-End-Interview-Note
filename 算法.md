https://github.com/sl1673495/leetcode-javascript

ä»£ç éšæƒ³å½•
https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC.html

æå®šå¤§å‚ç®—æ³•é¢è¯•ä¹‹ leetcode ç²¾è®²
https://xiaochen1024.com/courseware/60b4f11ab1aa91002eb53b18

è®ºå¦‚ä½• 4 ä¸ªæœˆé«˜æ•ˆåˆ·æ»¡ 500 é¢˜å¹¶å½¢æˆé•¿æœŸè®°å¿†
https://leetcode-cn.com/circle/discuss/jq9Zke/

CodeTop
https://codetop.cc/home

ç®—æ³•çš„æ—¶é—´ä¸ç©ºé—´å¤æ‚åº¦ï¼ˆä¸€çœ‹å°±æ‡‚ï¼‰
https://zhuanlan.zhihu.com/p/50479555

# æ’åº

åå¤§ç»å…¸æ’åºç®—æ³•
https://github.com/hustcc/JS-Sorting-Algorithm

ã€Œç®—æ³•ä¸æ•°æ®ç»“æ„ã€æ¢³ç† 6 å¤§æ’åºç®—æ³•
https://juejin.cn/post/6856546833025237006#heading-9

## åˆ†ç±»

- æŒ‰æ’åºä¾æ®çš„åŸåˆ™
  æ’å…¥æ’åºï¼š ç›´æ¥æ’å…¥æ’åºã€å¸Œå°”æ’åº
  äº¤æ¢æ’åºï¼š å†’æ³¡æ’åºã€å¿«é€Ÿæ’åº
  é€‰æ‹©æ’åº: ç›´æ¥é€‰æ‹©æ’åºã€å †æ’åº
  å½’å¹¶æ’åºï¼š 2-å½•å½’å¹¶æ’åº
  åŸºæ•°æ’åº

- æ ¹æ®æ’åºçš„ç¨³å®šæ€§ï¼šå…³é”®å­—ç›¸åŒçš„è®°å½•åœ¨æ’åºè¿‡ç¨‹ä¸­æ˜¯å¦ä¿æŒå‰åæ¬¡åºä¸å˜
  ä¸å˜åˆ™ä¸ºç¨³å®šæ’åºï¼Œå˜åŒ–åˆ™ä¸ºä¸ç¨³å®šæ’åº

ç¨³å®šæ’åºï¼š ç›´æ¥æ’å…¥æ’åºã€å†’æ³¡æ’åºã€å½’å¹¶æ’åºã€è®¡æ•°æ’åº
ä¸ç¨³å®šæ’åºï¼šå¸Œå°”æ’åºã€ç›´æ¥é€‰æ‹©æ’åºã€å †æ’åºã€å¿«é€Ÿæ’åº

- æ—¶é—´å¤æ‚åº¦

1.  å†’æ³¡æ’åº-ç¨³å®š O(nÂ²)

    ```javascript
    let bubbleSort = function (arr, flag = 0) {
      let len = arr.length;

      // æœ€å¤–å±‚forå¾ªç¯è¡¨ç¤ºå¾ªç¯æ¬¡æ•°ï¼Œéœ€å¾ªç¯len - 1æ¬¡
      for (let i = 0; i < len - 1; i++) {
        for (let j = 0; j < len - 1 - i; j++) {
          //æ¯”è¾ƒç›¸é‚»ä¸¤è€…ä¹‹é—´çš„å…³ç³»å¤§å°
          if (arr[j] > arr[j + 1]) {
            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
          }
        }
      }
      return flag ? arr.reverse() : arr;
    };
    let arr = [2, 10, 8, 3, 0, 5];
    console.log(bubbleSort(arr, 1)); //flag 0-æ­£åº 1-å€’åº
    ```

2.  å¿«é€Ÿæ’åº- ä¸ç¨³å®š O(nlogn)
    åŸºæœ¬æ€æƒ³ï¼šé€šè¿‡ä¸€è¶Ÿæ’åºå°†å¾…æ’è®°å½•åˆ†éš”æˆç‹¬ç«‹çš„ä¸¤éƒ¨åˆ†ï¼Œå…¶ä¸­ä¸€éƒ¨åˆ†è®°å½•çš„å…³é”®å­—å‡æ¯”å¦ä¸€éƒ¨åˆ†çš„å…³é”®å­—å°ï¼Œåˆ™å¯åˆ†åˆ«å¯¹è¿™ä¸¤éƒ¨åˆ†è®°å½•ç»§ç»­è¿›è¡Œæ’åºï¼Œä»¥è¾¾åˆ°æ•´ä¸ªåºåˆ—æœ‰åºã€‚

    1. æ–¹æ³•ä¸€

       ```js
       let quickSort = function (arr) {
         // é€’å½’å‡ºå£å°±æ˜¯æ•°ç»„é•¿åº¦ä¸º1
         if (arr.length <= 1) return arr;
         // è·å–ä¸­é—´å€¼çš„ç´¢å¼•ï¼Œä½¿ç”¨Math.floorå‘ä¸‹å–æ•´
         let index = Math.floor(arr.length / 2);
         // ä½¿ç”¨spliceæˆªå–ä¸­é—´å€¼
         let pivot = arr.splice(index, 1)[0],
           left = [],
           right = [];
         for (let i = 0; i < arr.length; i++) {
           // å¦‚æœä¸­é—´å€¼æ›´å¤§ï¼Œåˆ™å°†arr[i] pushå·¦è¾¹æ•°ç»„
           if (pivot > arr[i]) {
             left.push(arr[i]);
           } else {
             // å¦åˆ™ï¼Œå°†arr[i] pushå³è¾¹æ•°ç»„
             right.push(arr[i]);
           }
         }
         return quickSort(left).concat([pivot], quickSort(right));
       };
       ```

    2. æ–¹æ³•äºŒ

       ```javascript
       // ä¸‹é¢è¿™ä¸ªæ–¹æ³•leetcodeä¼šæ‰§è¡Œå‡ºå‡ºé”™
       function quickSort(array) {
         if (array.length < 2) return array;
         let pivot = array[array.length - 1];
         let left = array.filter(
           (item, index) => item <= pivot && index !== array.length - 1
         );
         let right = array.filter((item) => item > pivot);
         return [...quickSort(left), pivot, ...quickSort(right)];
       }
       ```

3.  ç›´æ¥æ’å…¥æ’åº-ç¨³å®š O(nÂ²)
    åŸºæœ¬åŸç†ï¼šé€šè¿‡æ„å»ºæœ‰åºåºåˆ—ï¼Œå¯¹äºæœªæ’åºæ•°æ®ï¼Œåœ¨å·²æ’åºåºåˆ—ä¸­ä»åå‘å‰æ‰«æï¼Œæ‰¾åˆ°ç›¸åº”ä½ç½®å¹¶æ’å…¥

    ```javascript
    let insertSort = function (arr) {
      // å–æ•°ç»„é•¿åº¦
      let len = arr.length;

      for (let i = 1; i < len; i++) {
        // cur è¡¨ç¤ºå½“å‰è¦æ’å…¥æ¯”è¾ƒçš„å…ƒç´ 
        let curValue = arr[i];
        let j = i - 1;
        // è‹¥å‰é¢çš„æ•°å­—æ¯”å½“å‰å€¼curå¤§ï¼Œåˆ™å‰é¢çš„æ•°å­—å‘åç§»åŠ¨ä¸€ä½ï¼Œç»§ç»­å‘å‰ä¸€ä½ä¸å½“å‰å€¼æ¯”è¾ƒ
        // preIndex >= 0 æ˜¯ä¸ºäº†ä¿è¯ç¬¬ä¸€ä¸ªå…ƒç´ è®¤ä¸ºè¢«æ’åº
        while (j >= 0 && curValue < arr[j]) {
          arr[j + 1] = arr[j];
          j--;
        }
        // å¦‚æœå°ï¼Œåˆ™æ”¾å…¥å½“å‰æ•°å­—çš„åé¢
        arr[j + 1] = curValue;
      }
      return arr;
    };
    ```

4.  å½’å¹¶æ’åº-ç¨³å®š O(nlogn)
    https://juejin.cn/post/6844903937242300430
    å½’å¹¶æ’åºæ˜¯åˆ©ç”¨å½’å¹¶çš„æ€æƒ³å®ç°çš„æ’åºæ–¹æ³•ï¼Œè¯¥ç®—æ³•é‡‡ç”¨ç»å…¸çš„åˆ†æ²»ç­–ç•¥ã€‚

    1. å°†åºåˆ—ä¸­å¸¦æ’åºæ•°å­—åˆ†ä¸ºè‹¥å¹²ç»„ï¼Œæ¯ä¸ªæ•°å­—åˆ†ä¸ºä¸€ç»„
    2. å°†è‹¥å¹²ä¸ªç»„ä¸¤ä¸¤åˆå¹¶ï¼Œä¿è¯åˆå¹¶åçš„ç»„æ˜¯æœ‰åºçš„
    3. é‡å¤ç¬¬äºŒæ­¥æ“ä½œç›´åˆ°åªå‰©ä¸‹ä¸€ç»„ï¼Œæ’åºå®Œæˆ

    ```js
    function merge(left, right) {
      let result = [];
      let i = 0,
        j = 0;
      while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
          // ä¸€å®šä¸è¦å¿˜è®°i++
          result.push(left[i++]);
        } else {
          result.push(right[j++]);
        }
      }
      if (i < left.length) {
        result.push(...left.slice(i));
      } else {
        result.push(...right.slice(j));
      }
      return result;
    }

    function mergeSort(array) {
      if (array.length < 2) {
        return array;
      }
      let m = Math.floor(array.length / 2);
      let left = mergeSort(array.slice(0, m));
      let right = mergeSort(array.slice(m));
      return merge(left, right);
    }

    let arr = [1, 8, 9, 5, 4, 3, 6, 2];
    console.log(mergeSort(arr));
    ```

5.  è®¡æ•°æ’åº
    æ‰€è°“â€œè®¡æ•°â€ï¼Œå°±æ˜¯æ•°ä¸€æ•°ï¼Œç»Ÿè®¡æ¯ä¸ªå…ƒç´ é‡å¤å‡ºç°çš„æ¬¡æ•°ã€‚

    ```js
    function countingSort(arr) {
      let min = Infinity;
      for (let v of arr) {
        if (v < min) {
          min = v;
        }
      }
      let counts = [];
      for (let v of arr) {
        counts[v - min] = (counts[v - min] || 0) + 1;
      }
      let index = 0;
      for (let i = 0; i < counts.length; i++) {
        let count = counts[i];
        while (count > 0) {
          arr[index] = i + min;
          count--;
          index++;
        }
      }
      return arr;
    }
    ```

6.  å¸Œå°”æ’åº
    é€šè¿‡æŸä¸ªå¢é‡ gapï¼Œå°†æ•´ä¸ªåºåˆ—åˆ†ç»™è‹¥å¹²ç»„ï¼Œä»åå¾€å‰è¿›è¡Œç»„å†…æˆå‘˜çš„æ¯”è¾ƒå’Œäº¤æ¢ï¼Œéšåé€æ­¥ç¼©å°å¢é‡è‡³ 1ã€‚å¸Œå°”æ’åºç±»ä¼¼äºæ’å…¥æ’åºï¼Œåªæ˜¯ä¸€å¼€å§‹å‘å‰ç§»åŠ¨çš„æ­¥æ•°ä» 1 å˜æˆäº† gapã€‚

    ```js
    function shellSort(arr) {
      let len = arr.length;
      // åˆå§‹æ­¥æ•°
      let gap = parseInt(len / 2);
      // é€æ¸ç¼©å°æ­¥æ•°
      while (gap) {
        // ä»ç¬¬gapä¸ªå…ƒç´ å¼€å§‹éå†
        for (let i = gap; i < len; i++) {
          // é€æ­¥å…¶å’Œå‰é¢å…¶ä»–çš„ç»„æˆå‘˜è¿›è¡Œæ¯”è¾ƒå’Œäº¤æ¢
          for (let j = i - gap; j >= 0; j -= gap) {
            if (arr[j] > arr[j + gap]) {
              [arr[j], arr[j + gap]] = [arr[j + gap], arr[j]];
            } else {
              break;
            }
          }
        }
        gap = parseInt(gap / 2);
      }
      return arr;
    }
    ```

7.  ç›´æ¥é€‰æ‹©æ’åº - ä¸ç¨³å®š - O(nÂ²)

    ```javascript
    // åŸºæœ¬åŸç†ï¼šæ¯ä¸€æ¬¡ä»å¾…æ’åºçš„æ•°ç»„å…ƒç´ ä¸­é€‰æ‹©æœ€å¤§çš„ä¸€ä¸ªå…ƒç´ ä½œä¸ºé¦–å…ƒç´ ï¼Œç›´åˆ°æ’å®Œä¸ºæ­¢
    let selectSort = function (arr) {
      let len = arr.length,
        curMinIndex = 0;
      //Â ä¸€å…±éœ€è¦æ’åºlen-1æ¬¡, å³å¾ªç¯æ¬¡æ•°
      for (let i = 0; i < len - 1; i++) {
        curMinIndex = i;
        // å–å‡ºåç»­æ•°å­—ä¸­æœ€å°æ•°å­—çš„ç´¢å¼•
        for (let j = i + 1; j < len; j++) {
          if (arr[j] < arr[curMinIndex]) {
            curMinIndex = j;
          }
        }
        //Â æ¯ä¸€è¶Ÿä¿è¯ç¬¬iä½ä¸ºæœ€å°å€¼, æ­¤æ—¶çš„tempä¸ºåç»­æœ€å°æ•°å­—çš„ç´¢å¼•
        [arr[i], arr[curMinIndex]] = [arr[curMinIndex], arr[i]];
      }
      return arr;
    };
    let arr = [2, 9, 6, 7, 4, 3, 1, 7, 0, -1, -2];
    console.log(selectSort(arr));
    ```

8.  å †æ’åº
    https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/xie-gei-qian-duan-tong-xue-de-ti-jie-yi-kt5p2/

    ```javascript
    /**
     * @param {number[]} nums
     * @param {number} k
     * @return {number}
     */
    // æ•´ä¸ªæµç¨‹å°±æ˜¯ä¸Šæµ®ä¸‹æ²‰
    var findKthLargest = function (nums, k) {
      let heapSize = nums.length;
      buildMaxHeap(nums, heapSize); // æ„å»ºå¥½äº†ä¸€ä¸ªå¤§é¡¶å †
      // è¿›è¡Œä¸‹æ²‰ å¤§é¡¶å †æ˜¯æœ€å¤§å…ƒç´ ä¸‹æ²‰åˆ°æœ«å°¾
      for (let i = nums.length - 1; i >= nums.length - k + 1; i--) {
        swap(nums, 0, i);
        --heapSize; // ä¸‹æ²‰åçš„å…ƒç´ ä¸å‚ä¸åˆ°å¤§é¡¶å †çš„è°ƒæ•´
        // é‡æ–°è°ƒæ•´å¤§é¡¶å †
        maxHeapify(nums, 0, heapSize);
      }
      return nums[0];
      // è‡ªä¸‹è€Œä¸Šæ„å»ºä¸€é¢—å¤§é¡¶å †
      function buildMaxHeap(nums, heapSize) {
        for (let i = Math.floor(heapSize / 2) - 1; i >= 0; i--) {
          maxHeapify(nums, i, heapSize);
        }
      }
      // ä»å·¦å‘å³ï¼Œè‡ªä¸Šè€Œä¸‹çš„è°ƒæ•´èŠ‚ç‚¹
      function maxHeapify(nums, i, heapSize) {
        let l = i * 2 + 1;
        let r = i * 2 + 2;
        let largest = i;
        if (l < heapSize && nums[l] > nums[largest]) {
          largest = l;
        }
        if (r < heapSize && nums[r] > nums[largest]) {
          largest = r;
        }
        if (largest !== i) {
          swap(nums, i, largest); // è¿›è¡ŒèŠ‚ç‚¹è°ƒæ•´
          // ç»§ç»­è°ƒæ•´ä¸‹é¢çš„éå¶å­èŠ‚ç‚¹
          maxHeapify(nums, largest, heapSize);
        }
      }
      function swap(a, i, j) {
        let temp = a[i];
        a[i] = a[j];
        a[j] = temp;
      }
    };
    ```

# åŒæŒ‡é’ˆ

1. ä¸‹ä¸€ä¸ªæ’åˆ—

   ```js
   /**
    * @param {number[]} nums
    * @return {void} Do not return anything, modify nums in-place instead.
    */
   var nextPermutation = function (nums) {
     let len = nums.length;
     let i = len - 2;
     // ä»åå‘å‰æŸ¥æ‰¾ç¬¬ä¸€ä¸ªç›¸é‚»å‡åºçš„å…ƒç´ (i,i+1), è¯´æ˜iåé¢ä¸€å®šæ˜¯é™åº
     while (i >= 0 && nums[i] >= nums[i + 1]) i--;
     // è¯´æ˜æ­¤æ—¶ä¸æ˜¯æœ€å¤§çš„æ’åˆ—ï¼Œè¦å»å¯»æ‰¾i+1åé¢æ¯”nums[i]å¤§çš„æœ€å°å€¼
     // å¦‚æœi=-1çš„è¯, ä¸å­˜åœ¨ nums[-1] æ‰€ä»¥æ— æ³•è°ƒæ¢ä½ç½®
     if (i >= 0) {
       // æ‰¾åˆ°iåé¢æœ€å°çš„æ¯”nums[i] å¤§çš„æ•°å­—ä¸‹æ ‡j
       let j = len - 1;
       // å› ä¸ºæ˜¯é™åº,ä»åå‘å‰æŸ¥æ‰¾æ»¡è¶³>nums[i]çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
       while (j >= 0 && nums[i] >= nums[j]) j--;
       // è°ƒæ¢ä½ç½®
       [nums[i], nums[j]] = [nums[j], nums[i]];
     }
     // ä½¿iåé¢çš„å…ƒç´ å‡åºæ’åº
     let left = i + 1,
       right = len - 1;
     while (left < right) {
       [nums[left], nums[right]] = [nums[right], nums[left]];
       left++;
       right--;
     }
     return nums;
   };
   ```

2. å¯»æ‰¾é‡å¤æ•°-ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆ(å’Œç¯å½¢é“¾è¡¨ä¸€ä¸ªæ¦‚å¿µ)
   https://leetcode-cn.com/problems/find-the-duplicate-number/solution/qian-duan-ling-hun-hua-shi-tu-jie-kuai-man-zhi-z-3/
   å‰ç«¯çµé­‚ç”»å¸ˆ ğŸ¨ å›¾è§£å¿«æ…¢æŒ‡é’ˆ

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var findDuplicate = function (nums) {
     let slow = 0,
       fast = 0;
     while (true) {
       // slowèµ°ä¸€æ­¥ï¼Œfastèµ°ä¸¤æ­¥
       slow = nums[slow];
       fast = nums[nums[fast]];
       if (slow === fast) {
         // slowå’Œfastç›¸ç­‰ï¼Œåˆ™å…¶ä¸­ä¸€ä¸ªç½®ä¸º0ï¼Œä¸¤ä¸ªåŒæ­¥é€Ÿåº¦å‘å‰è¿›
         let _slow = 0;
         while (nums[slow] !== nums[_slow]) {
           slow = nums[slow];
           _slow = nums[_slow];
         }
         return nums[slow];
       }
     }
   };
   ```

3. ç¯å½¢é“¾è¡¨ II-ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆ

   ```js
   /**
    * Definition for singly-linked list.
    * function ListNode(val) {
    *     this.val = val;
    *     this.next = null;
    * }
    */

   /**
    * @param {ListNode} head
    * @return {ListNode}
    */
   var detectCycle = function (head) {
     let slow = head,
       fast = head;
     while (fast && fast.next) {
       slow = slow.next;
       fast = fast.next.next;

       if (fast === slow) {
         fast = head;
         while (fast !== slow) {
           fast = fast.next;
           slow = slow.next;
         }
         return fast;
       }
     }
     return null;
   };
   ```

# æ ˆ

1. ç§»æ‰ K ä½æ•°å­—

   ```js
   /**
    * @param {string} num
    * @param {number} k
    * @return {string}
    */
   var removeKdigits = function (num, k) {
     let stack = [];
     for (let i = 0; i < num.length; i++) {
       let c = num[i];
       // ç»´æŠ¤ä¸€ä¸ªå•è°ƒé€’å¢æ ˆ
       // å¦‚æœcæ¯”æ ˆé¡¶å…ƒç´ æ›´å°, åˆ™å¼¹å‡ºæ ˆé¡¶å…ƒç´ ï¼Œç§»é™¤çš„æ•°é‡k--
       while (k > 0 && stack.length && c < stack[stack.length - 1]) {
         stack.pop();
         // kè¡¨ç¤ºè¦ç§»é™¤çš„æ•°é‡
         k--;
       }
       // æ’é™¤æ‰ 0åœ¨æ ˆé¡¶çš„æƒ…å†µ(c === '0' && stack.legnth === 0)
       if (c != "0" || stack.length !== 0) {
         // å°†æ•°å­—å‹å…¥æ ˆä¸­
         stack.push(c);
       }
     }
     // å¦‚æœè¿˜æ²¡åˆ å¤Ÿkä¸ªå­—ç¬¦æ—¶
     while (k > 0) {
       stack.pop();
       k--;
     }
     // åˆ¤æ–­ num=10, k=2çš„æƒ…å†µ
     return stack.length === 0 ? "0" : stack.join("");
   };
   ```

# é“¾è¡¨

1.  ä»å°¾åˆ°å¤´æ‰“å°é“¾è¡¨

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */
    /**
     * @param {ListNode} head
     * @return {number[]}
     */
    var reversePrint = function (head) {
      let res = [];
      while (head) {
        res.unshift(head.val);
        head = head.next;
      }
      return res;
    };
    ```

2.  åè½¬é“¾è¡¨

    ```js
    // è¿­ä»£æ³•
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */
    /**
     * @param {ListNode} head
     * @return {ListNode}
     */
    var reverseList = function (head) {
      // prevå¿…é¡»è¦å£°æ˜ä¸ºnull
      let prev = null;
      let curr = head;
      //å¦‚æœcurrä¸ºnull,åˆ™å…¶å·²ç»æˆä¸ºæœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œé“¾è¡¨å·²ç»åè½¬å®Œæˆ
      while (curr) {
        //å…ˆç”¨nextä¿å­˜ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        let next = curr.next;
        //å°†curræŒ‡å‘prevå‰é¢ä¸€ä¸ªèŠ‚ç‚¹
        curr.next = prev;
        //prevèŠ‚ç‚¹åç§»
        //ä¸‹é¢ä¸¤è¡Œä¸èƒ½äº¤æ¢
        prev = curr;
        //currèŠ‚ç‚¹ä¹Ÿåç§»
        curr = next;
      }
      return prev;
    };
    ```

    ```js
    // é€’å½’æ³•
    var reverseList = function (head) {
      if (head == null || head.next == null) {
        return head;
      }
      const newHead = reverseList(head.next);
      head.next.next = head;
      head.next = null;
      return newHead;
    };
    ```

3.  åè½¬é“¾è¡¨ II

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val, next) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.next = (next===undefined ? null : next)
     * }
     */
    /**
     * @param {ListNode} head
     * @param {number} left
     * @param {number} right
     * @return {ListNode}
     */
    var reverseBetween = function (head, left, right) {
      let dummyNode = new ListNode(0, head);
      let pre = dummyNode;

      for (let i = 0; i < left - 1; i++) {
        pre = pre.next;
      }

      let rightNode = pre;
      for (let i = 0; i < right - left + 1; i++) {
        rightNode = rightNode.next;
      }

      let leftNode = pre.next;
      let cur = rightNode.next;

      pre.next = null;
      rightNode.next = null;

      reverseList(leftNode);

      pre.next = rightNode;
      leftNode.next = cur;
      return dummyNode.next;
    };

    var reverseList = function (head) {
      let pre = null,
        cur = head;
      while (cur) {
        let temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
      }
      return pre;
    };
    ```

4.  åˆå¹¶ä¸¤ä¸ªæ’åºçš„é“¾è¡¨(éš¾)

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */
    /**
     * @param {ListNode} l1
     * @param {ListNode} l2
     * @return {ListNode}
     */
    var mergeTwoLists = function (l1, l2) {
      if (!l1) {
        return l2;
      }
      if (!l2) {
        return l1;
      }
      let head;
      if (l1.val < l2.val) {
        head = l1;
        head.next = mergeTwoLists(l1.next, l2);
      } else {
        head = l2;
        head.next = mergeTwoLists(l1, l2.next);
      }
      return head;
    };
    ```

5.  åˆ é™¤é“¾è¡¨çš„èŠ‚ç‚¹

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */
    /**
     * @param {ListNode} head
     * @param {number} val
     * @return {ListNode}
     */

    var deleteNode = function (head, val) {
      if (head.val === val) {
        return head.next;
      }
      head.next = deleteNode(head.next, val);
      return head;
    };

    // æ–¹æ³•äºŒ
    var removeElements = function (head, val) {
      // è®¾ç½®è™šæ‹ŸèŠ‚ç‚¹
      let dummyHead = new ListNode(0, head);
      let temp = dummyHead;
      while (temp.next) {
        if (temp.next.val === val) {
          // å¦‚æœèŠ‚ç‚¹å€¼ç›¸ç­‰ï¼ŒtempèŠ‚ç‚¹å°±æŒ‡å‘temp.next.next
          temp.next = temp.next.next;
        } else {
          // å¦åˆ™tempå°±ä¸€é¡¹ä¸‹ä¸€èŠ‚ç‚¹
          temp = temp.next;
        }
      }
      // è¿”å›å¤´ç»“ç‚¹
      return dummyHead.next;
    };
    ```

6.  é“¾è¡¨ä¸­å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */
    /**
     * @param {ListNode} head
     * @param {number} k
     * @return {ListNode}
     */
    var getKthFromEnd = function (head, k) {
      let total = 0,
        node = head;
      while (node) {
        total++;
        node = node.next;
      }
      let index = total - k;
      while (index) {
        head = head.next;
        index--;
      }
      return head;
    };
    ```

7.  ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹ | ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªé‡åˆèŠ‚ç‚¹

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */

    /**
     * @param {ListNode} headA
     * @param {ListNode} headB
     * @return {ListNode}
     */
    var getIntersectionNode = function (headA, headB) {
      var getListLen = function (head) {
        let len = 0,
          cur = head; // ä¸èƒ½ç›´æ¥ä½¿ç”¨headï¼Œå¦åˆ™headä¼šè¢«ä¿®æ”¹
        while (cur) {
          len++;
          cur = cur.next;
        }
        return len;
      };

      let curA = headA,
        curB = headB,
        lenA = getListLen(headA),
        lenB = getListLen(headB);
      if (lenA < lenB) {
        [curA, curB] = [curB, curA]; //è¿™é‡Œçš„åˆ†å·ä¸€å®šè¦åŠ 
        [lenA, lenB] = [lenB, lenA];
      }
      let i = lenA - lenB;
      while (i-- > 0) {
        curA = curA.next;
      }
      // curAå­˜åœ¨ä¸è¦å¿˜è®°
      while (curA && curA !== curB) {
        curA = curA.next;
        curB = curB.next;
      }
      return curA;
    };
    ```

8.  å¤æ‚é“¾è¡¨çš„å¤åˆ¶(offer1 ä¸­)(éš¾)

    ```js
    /**
     * // Definition for a Node.
     * function Node(val, next, random) {
     *    this.val = val;
     *    this.next = next;
     *    this.random = random;
     * };
     */

    /**
     * @param {Node} head
     * @return {Node}
     */
    var copyRandomList = function (head) {
      if (!head) return null;
      let m = new Map();
      let node = head;
      while (node) {
        m.set(node, new Node(node.val));
        node = node.next;
      }
      node = head;
      while (node) {
        m.get(node).next = node.next ? m.get(node.next) : null;
        m.get(node).random = node.random ? m.get(node.random) : null;
        node = node.next;
      }
      return m.get(head);
    };
    ```

9.  ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹

10. è®¾è®¡é“¾è¡¨

11. åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªèŠ‚ç‚¹(ä¸­)-éœ€è¦è®¾ç½®è™šæ‹ŸèŠ‚ç‚¹

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val, next) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.next = (next===undefined ? null : next)
     * }
     */
    /**
     * @param {ListNode} head
     * @param {number} n
     * @return {ListNode}
     */
    var removeNthFromEnd = function (head, n) {
      // å¿…é¡»è®¾ç½®è™šæ‹ŸèŠ‚ç‚¹ï¼Œ å¦åˆ™ä¸èƒ½è§£å†³è¦åˆ é™¤çš„èŠ‚ç‚¹æ˜¯å¤´ç»“ç‚¹çš„æƒ…å†µ
      let dummyNode = new ListNode(0, head);
      let fast = dummyNode,
        slow = dummyNode;
      while (n--) fast = fast.next;
      // åªæœ‰fast.nextä¸ä¸ºç©ºï¼Œ fastæ‰èƒ½ç§»åŠ¨åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹
      // å¦‚æœåªæ˜¯fastä¸ä¸ºç©ºï¼Œ ä¸‹ä¸€æ­¥fast = fast.nextï¼Œ fastæœ€ç»ˆä¼šæŒ‡å‘null
      while (fast.next !== null) {
        fast = fast.next;
        slow = slow.next;
      }
      slow.next = slow.next.next;
      return dummyNode.next;
    };
    ```

12. åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ 

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val, next) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.next = (next===undefined ? null : next)
     * }
     */
    /**
     * @param {ListNode} head
     * @return {ListNode}
     */
    var deleteDuplicates = function (head) {
      if (!head) return head; //ä¸èƒ½è¿”å›[]

      let pre = head;
      while (pre.next) {
        if (pre.val === pre.next.val) {
          pre.next = pre.next.next; // æœ€åå¯ä»¥æŒ‡å‘Null
        } else {
          pre = pre.next;
        }
      }
      return head;
    };
    ```

13. åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´  II

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val, next) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.next = (next===undefined ? null : next)
     * }
     */
    /**
     * @param {ListNode} head
     * @return {ListNode}
     */
    var deleteDuplicates = function (head) {
      let dummyNode = new ListNode(0, head);

      let cur = dummyNode;
      while (cur.next && cur.next.next) {
        if (cur.next.val === cur.next.next.val) {
          let val = cur.next.val;
          // ä½¿ç”¨ 1-1-1-2-3å¯ä»¥è§£é‡Š
          while (cur.next && cur.next.val === val) {
            cur.next = cur.next.next;
          }
        } else {
          cur = cur.next;
        }
      }
      return dummyNode.next;
    };
    ```

14. ç¯å½¢é“¾è¡¨

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */

    /**
     * @param {ListNode} head
     * @return {boolean}
     */
    var hasCycle = function (head) {
      const map = new Map();
      while (head) {
        if (map.has(head)) return true;
        map.set(head, true);
        head = head.next;
      }
      return false;
    };
    ```

    ```js
    var hasCycle = function (head) {
      //è®¾ç½®å¿«æ…¢æŒ‡é’ˆ
      let slow = head;
      let fast = head;
      //å¦‚æœæ²¡æœ‰ç¯ï¼Œåˆ™å¿«æŒ‡é’ˆä¼šæŠµè¾¾ç»ˆç‚¹ï¼Œå¦åˆ™ç»§ç»­ç§»åŠ¨åŒæŒ‡é’ˆ
      while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
        //å¿«æ…¢æŒ‡é’ˆç›¸é‡ï¼Œè¯´æ˜å«æœ‰ç¯
        if (slow == fast) {
          return true;
        }
      }

      return false;
    };
    ```

15. é“¾è¡¨ä¸­ç¯çš„å…¥å£èŠ‚ç‚¹(ä¸­)(éš¾) | ç¯å½¢é“¾è¡¨ II
    https://leetcode-cn.com/problems/c32eOV/solution/tu-jie-kuai-man-zhi-zhen-ji-qiao-yuan-li-rdih/

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */

    /**
     * @param {ListNode} head
     * @return {ListNode}
     */
    var detectCycle = function (head) {
      // å¿«æ…¢æŒ‡é’ˆåˆå§‹åŒ–æŒ‡å‘ head
      let slow = head;
      let fast = head;
      // å¿«æŒ‡é’ˆèµ°åˆ°æœ«å°¾æ—¶åœæ­¢
      while (fast && fast.next) {
        // æ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥
        slow = slow.next;
        fast = fast.next.next;
        // å¿«æ…¢æŒ‡é’ˆç›¸é‡ï¼Œè¯´æ˜å«æœ‰ç¯
        if (slow == fast) {
          // ä»»ä¸€ä¸€èŠ‚ç‚¹æŒ‡å‘å¤´èŠ‚ç‚¹
          fast = head;
          // åŒæ­¥å‘å‰è¿›ï¼Œä¸¤æŒ‡é’ˆç›¸é‡fastå°±æ˜¯èµ·ç‚¹
          while (fast != slow) {
            fast = fast.next;
            slow = slow.next;
          }
          // è¿”å›å…¥å£èŠ‚ç‚¹
          return fast;
        }
      }
      // ä¸åŒ…å«ç¯
      return null;
    };
    ```

16. å›æ–‡é“¾è¡¨

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val, next) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.next = (next===undefined ? null : next)
     * }
     */
    /**
     * @param {ListNode} head
     * @return {boolean}
     */
    var isPalindrome = function (head) {
      let res = [];
      let node = head;
      while (node) {
        res.push(node.val);
        node = node.next;
      }
      for (let i = 0, j = res.length - 1; i < j; i++, j--) {
        if (res[i] !== res[j]) {
          return false;
        }
      }
      return true;
    };
    ```

17. ä¸¤æ•°ç›¸åŠ (ä¸­)

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val, next) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.next = (next===undefined ? null : next)
     * }
     */
    /**
     * @param {ListNode} l1
     * @param {ListNode} l2
     * @return {ListNode}
     */
    var addTwoNumbers = function (l1, l2) {
      let dummy = new ListNode();
      let cur = dummy;
      let carry = 0;
      while (l1 || l2) {
        const x = l1 ? l1.val : 0;
        const y = l2 ? l2.val : 0;

        let sum = x + y + carry;
        cur.next = new ListNode(sum % 10);
        cur = cur.next;
        carry = Math.floor(sum / 10);

        // ä¸¤ä¸ªifä¸è¦å¿˜è®°
        if (l1) l1 = l1.next;
        if (l2) l2 = l2.next;
      }
      if (carry) cur.next = new ListNode(carry);
      return dummy.next;
    };
    ```

18. é“¾è¡¨ä¸­çš„ä¸¤æ•°ç›¸åŠ (ä¸­)-éœ€è¦å…ˆç¿»è½¬é“¾è¡¨

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val, next) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.next = (next===undefined ? null : next)
     * }
     */
    /**
     * @param {ListNode} l1
     * @param {ListNode} l2
     * @return {ListNode}
     */
    var addTwoNumbers = function (l1, l2) {
      var reverseNode = function (head) {
        let pre = null,
          cur = head;
        while (cur) {
          let next = cur.next;
          cur.next = pre;
          pre = cur;
          cur = next;
        }
        return pre;
      };
      l1 = reverseNode(l1);
      l2 = reverseNode(l2);
      let dummy = new ListNode();
      let cur = dummy;
      let carry = 0;
      while (l1 || l2) {
        const x = l1 ? l1.val : 0;
        const y = l2 ? l2.val : 0;

        let sum = x + y + carry;
        cur.next = new ListNode(sum % 10);
        cur = cur.next;
        carry = Math.floor(sum / 10);

        // ä¸è¦å¿˜è®°
        if (l1) l1 = l1.next;
        if (l2) l2 = l2.next;
      }
      if (carry) cur.next = new ListNode(carry);
      return reverseNode(dummy.next);
    };
    ```

19. é“¾è¡¨æ’åº | æ’åºé“¾è¡¨(ä¸­)(éš¾) - ä½¿ç”¨å½’å¹¶æ’åº

    ```js
    var sortList = function (head) {
      if (!head || !head.next) return head;
      let slow = head,
        fast = head;
      let preSlow = null;
      // å¯»æ‰¾ä¸­é—´èŠ‚ç‚¹
      while (fast && fast.next) {
        preSlow = slow;
        slow = slow.next;
        fast = fast.next.next;
      }
      // ä¸ºä»€ä¹ˆè¦è¿™ä¸€æ­¥? ä¸€åˆ†ä¸ºäºŒ å˜æˆheadå¼€å¤´çš„èŠ‚ç‚¹å’Œslowå¼€å¤´çš„èŠ‚ç‚¹
      preSlow.next = null;
      const l = sortList(head);
      const r = sortList(slow);
      return merge(l, r);
    };

    function merge(l1, l2) {
      const dummy = new ListNode(0);
      let cur = dummy;
      while (l1 && l2) {
        if (l1.val < l2.val) {
          cur.next = l1;
          l1 = l1.next;
        } else {
          cur.next = l2;
          l2 = l2.next;
        }
        cur = cur.next;
      }
      if (l1) cur.next = l1;
      if (l2) cur.next = l2;
      return dummy.next;
    }
    ```

20. é‡æ’é“¾è¡¨(ä¸­)

21. å±•å¹³å¤šçº§åŒå‘é“¾è¡¨(ä¸­)

22. æ’åºçš„å¾ªç¯é“¾è¡¨(ä¸­)

23. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨(éš¾)

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val, next) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.next = (next===undefined ? null : next)
     * }
     */
    /**
     * @param {ListNode} head
     * @param {number} k
     * @return {ListNode}
     */
    var reverseKGroup = function (head, k) {
      const dummyNode = new ListNode(0, head);
      let pre = dummyNode;

      while (head) {
        let tail = pre;
        // æŸ¥çœ‹å‰©ä½™éƒ¨åˆ†é•¿åº¦æ˜¯å¦å¤§äºç­‰äº k
        for (let i = 0; i < k; i++) {
          tail = tail.next;
          // å¦‚æœtailä¸å­˜åœ¨äº†ï¼Œè¯´æ˜å·²ç»åˆ°è¾¾ç»ˆç‚¹
          if (!tail) {
            return dummyNode.next;
          }
        }
        const cur = tail.next;
        [head, tail] = reverseList(head, tail);
        // æŠŠå­é“¾è¡¨é‡æ–°æ¥å›åŸé“¾è¡¨
        pre.next = head;
        tail.next = cur;

        // å‘ä¸‹ä¸€æ®µè¿›è¡Œç§»åŠ¨
        pre = tail;
        head = tail.next;
      }
      // å¦‚æœåˆšå¥½å°±ç›´æ¥è¿”å›
      return dummyNode.next;
    };

    const reverseList = (head, tail) => {
      // åˆå§‹preä¸ºnull
      let pre = tail.next;
      let cur = head;
      // ç»ˆæ­¢æ¡ä»¶ pre == tailå°¾èŠ‚ç‚¹, è¯´æ˜å‰é¢çš„èŠ‚ç‚¹å·²ç»å…¨éƒ¨é€†åºæˆåŠŸ
      while (pre !== tail) {
        const temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
      }
      return [tail, head];
    };
    ```

24. åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨(éš¾)

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val, next) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.next = (next===undefined ? null : next)
     * }
     */
    /**
     * @param {ListNode[]} lists
     * @return {ListNode}
     */
    var mergeKLists = function (lists) {
      if (!lists.length) return null;
      return mergeList(lists, 0, lists.length - 1);
    };
    // ä½¿ç”¨å½’å¹¶æ’åº
    function mergeList(list, start, end) {
      // å¦‚æœ start === end è¯´æ˜åˆ†æ²»çš„åˆ†åˆ°å¤´äº†ï¼Œåªå‰©ä¸€ç»„å…ƒç´ äº†ï¼Œç›´æ¥è¿”å›ä½œä¸ºleftListæˆ–è€…rightListå³å¯
      if (start === end) {
        return list[start];
      }
      let mid = start + ((end - start) >> 1);
      let leftList = mergeList(list, start, mid);
      let rightList = mergeList(list, mid + 1, end);
      return merge(leftList, rightList);
    }
    function merge(head1, head2) {
      let dummyNode = new ListNode(0);
      let cur = dummyNode;
      while (head1 && head2) {
        if (head1.val < head2.val) {
          cur.next = head1;
          head1 = head1.next;
        } else {
          cur.next = head2;
          head2 = head2.next;
        }
        cur = cur.next;
      }
      cur.next = head1 ? head1 : head2;
      return dummyNode.next;
    }
    ```

25. æœ€è¿‘æœ€å°‘ä½¿ç”¨ç¼“å­˜

    ```js
    /**
     * @param {number} capacity
     */
    var LRUCache = function (capacity) {
      this.cache = new Map();
      this.capacity = capacity;
    };

    /**
     * @param {number} key
     * @return {number}
     */
    LRUCache.prototype.get = function (key) {
      if (!this.cache.has(key)) {
        return -1;
      }
      const value = this.cache.get(key);
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    };

    /**
     * @param {number} key
     * @param {number} value
     * @return {void}
     */
    LRUCache.prototype.put = function (key, value) {
      // ä¸€å®šè¦æ”¾åœ¨æœ€å‰é¢ï¼Œè§£å†³è¾¾åˆ°ä¸Šé™ï¼Œä¸”å…³é”®å­—å·²ç»å­˜åœ¨çš„æƒ…å†µ
      if (this.cache.has(key)) {
        this.cache.delete(key);
      }
      // å½“ç¼“å­˜å®¹é‡è¾¾åˆ°ä¸Šé™æ—¶ï¼Œåˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®å€¼
      if (this.cache.size === this.capacity) {
        const iterator = this.cache.keys();
        this.cache.delete(iterator.next().value);
      }
      this.cache.set(key, value);
    };

    /**
     * Your LRUCache object will be instantiated and called as such:
     * var obj = new LRUCache(capacity)
     * var param_1 = obj.get(key)
     * obj.put(key,value)
     */
    ```

# äºŒå‰æ ‘

## äºŒå‰æ ‘çš„éå†(éš¾)

DLR--å‰åºéå†-ä¸­å·¦å³ï¼ˆæ ¹åœ¨å‰ï¼Œä»å·¦å¾€å³ï¼Œä¸€æ£µæ ‘çš„æ ¹æ°¸è¿œåœ¨å·¦å­æ ‘å‰é¢ï¼Œå·¦å­æ ‘åˆæ°¸è¿œåœ¨å³å­æ ‘å‰é¢ ï¼‰

LDR--ä¸­åºéå†-å·¦ä¸­å³ï¼ˆæ ¹åœ¨ä¸­ï¼Œä»å·¦å¾€å³ï¼Œä¸€æ£µæ ‘çš„å·¦å­æ ‘æ°¸è¿œåœ¨æ ¹å‰é¢ï¼Œæ ¹æ°¸è¿œåœ¨å³å­æ ‘å‰é¢ï¼‰

LRD--ååºéå†-å·¦å³ä¸­ï¼ˆæ ¹åœ¨åï¼Œä»å·¦å¾€å³ï¼Œä¸€æ£µæ ‘çš„å·¦å­æ ‘æ°¸è¿œåœ¨å³å­æ ‘å‰é¢ï¼Œå³å­æ ‘æ°¸è¿œåœ¨æ ¹å‰é¢ï¼‰

1. äºŒå‰æ ‘çš„å…ˆåºéå†

   1. éé€’å½’å®ç°

      ```javascript
      /**
       * Definition for a binary tree node.
       * function TreeNode(val, left, right) {
       *     this.val = (val===undefined ? 0 : val)
       *     this.left = (left===undefined ? null : left)
       *     this.right = (right===undefined ? null : right)
       * }
       */
      /**
       * @param {TreeNode} root
       * @return {number[]}
       */
      var preorderTraversal = function (root) {
        let res = [];
        let stack = [];
        if (root) stack.push(root);
        while (stack.length > 0) {
          let node = stack.pop();
          res.push(node.val);
          if (node.right) stack.push(node.right);
          if (node.left) stack.push(node.left);
        }
        return res;
      };
      ```

   2. é€’å½’å®ç°

      ```javascript
      var preorderTraversal = function (root, array = []) {
        if (root) {
          array.push(root.val);
          preorderTraversal(root.left, array);
          preorderTraversal(root.right, array);
        }
        return array;
      };

      var preorderTraversal = function (root) {
        let res = [];

        var preorder = function (root) {
          if (!root) return;
          res.push(root.val);
          preorder(root.left);
          preorder(root.right);
        };
        preorder(root);
        return res;
      };
      ```

2. äºŒå‰æ ‘çš„ä¸­åºéå†

   1. éé€’å½’å®ç°

      ```javascript
      /**
       * Definition for a binary tree node.
       * function TreeNode(val, left, right) {
       *     this.val = (val===undefined ? 0 : val)
       *     this.left = (left===undefined ? null : left)
       *     this.right = (right===undefined ? null : right)
       * }
       */
      /**
       * @param {TreeNode} root
       * @return {number[]}
       */
      var inorderTraversal = function (root) {
        let res = [];
        let stack = [];
        let cur = root;
        while (stack.length || cur) {
          if (cur) {
            stack.push(cur);
            cur = cur.left;
          } else {
            cur = stack.pop();
            res.push(cur.val);
            cur = cur.right;
          }
        }
        return res;
      };
      ```

   2. é€’å½’å®ç°

      ```javascript
      /**
       * @param {TreeNode} root
       * @return {number[]}
       */
      var inorderTraversal = function (root) {
        let res = [];
        var inorder = function (root) {
          if (root) {
            inorder(root.left);
            res.push(root.val);
            inorder(root.right);
          }
        };
        inorder(root);
        return res;
      };
      ```

3. äºŒå‰æ ‘çš„ååºéå†

   1. éé€’å½’éå†

      ```js
      const inorderTraversal = (root) => {
        if (!root) return [];
        const res = [];
        const stack = [];
        while (root || stack.length) {
          while (root) {
            stack.push(root);
            root = root.left;
          }
          root = stack.pop();
          res.push(root.val);
          root = root.right;
        }
        return res;
      };

      // æ–¹æ³•äºŒ
      var postorderTraversal = function (root) {
        let res = [];
        let stack = [];
        if (!root) return res;
        stack.push(root);
        let cur = null;
        while (stack.length) {
          cur = stack.pop();
          res.push(cur.val);
          if (cur.left) stack.push(cur.left);
          if (cur.right) stack.push(cur.right);
        }
        return res.reverse();
      };
      ```

4. äºŒå‰æ ‘çš„å±‚åºéå†

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @return {number[][]}
    */
   var levelOrder = function (root) {
     const res = [];
     if (!root) return res;

     let seq = [];
     seq.push(root);

     while (seq.length !== 0) {
       let len = seq.length;
       res.push([]);

       for (let i = 1; i <= len; i++) {
         let node = seq.shift();
         res[res.length - 1].push(node.val);
         if (node.left) seq.push(node.left);
         if (node.right) seq.push(node.right);
       }
     }

     return res;
   };

   // äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†
   var zigzagLevelOrder = function (root) {
     if (!root) return [];
     let res = [];
     let seq = [];
     seq.push(root);
     let flag = true;
     while (seq.length) {
       let len = seq.length;
       res.push([]);
       for (let i = 1; i <= len; i++) {
         let node = seq.shift();
         if (flag) {
           res[res.length - 1].push(node.val);
         } else {
           res[res.length - 1].unshift(node.val);
         }
         if (node.left) seq.push(node.left);
         if (node.right) seq.push(node.right);
       }
       flag = !flag;
     }
     return res;
   };
   ```

5. N å‰æ ‘

   1. N å‰æ ‘çš„å±‚åºéå†

      ```js
      var levelOrder = function (root) {
        if (!root) return [];
        let res = [];
        let seq = [];
        seq.push(root);
        while (seq.length) {
          let len = seq.length;
          let curArr = [];
          while (len--) {
            let node = seq.shift();
            curArr.push(node.val);
            for (let item of node.children) {
              if (item) seq.push(item);
            }
          }
          res.push(curArr);
        }
        return res;
      };
      ```

   2. N å‰æ ‘çš„å‰åºéå†

      ```js
      // é€’å½’
      /**
       * // Definition for a Node.
       * function Node(val, children) {
       *    this.val = val;
       *    this.children = children;
       * };
       */

      /**
       * @param {Node|null} root
       * @return {number[]}
       */
      var preorder = function (root) {
        let res = [];
        var preCheck = function (root) {
          if (root) {
            res.push(root.val);
            for (let item of root.children) {
              preCheck(item);
            }
          }
        };
        preCheck(root);
        return res;
      };
      ```

   3. N å‰æ ‘çš„ååºéå†

      ```js
      // é€’å½’
      var postorder = function (root) {
        let res = [];
        var postCheck = function (node) {
          if (node) {
            for (let i = 0; i < node.children.length; i++) {
              postCheck(node.children[i]);
            }
            res.push(node.val);
          }
        };
        postCheck(root);
        return res;
      };
      ```

   4. N å‰æ ‘çš„æœ€å¤§æ·±åº¦

      ```js
      /**
       * // Definition for a Node.
       * function Node(val,children) {
       *    this.val = val;
       *    this.children = children;
       * };
       */

      /**
       * @param {Node|null} root
       * @return {number}
       */
      var maxDepth = function (root) {
        if (!root) return 0;
        let maxRes = 0;
        for (let node of root.children) {
          let depth = maxDepth(node);
          maxRes = Math.max(depth, maxRes);
        }
        return 1 + maxRes;
      };
      ```

## å…¶å®ƒ

äºŒå‰æ ‘ä¸­å…³äºæ·±åº¦ä¼˜å…ˆéå†å’Œå›æº¯çš„åŒºåˆ«:

1. æ·±åº¦ä¼˜å…ˆéå†æ˜¯æ¯æ¡è·¯éƒ½å¿…é¡»èµ°ï¼Œ ä¾‹å¦‚é¢˜ç›®`äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„`
2. å›æº¯ä¹Ÿæ˜¯æ¯æ¡è·¯éƒ½å¿…é¡»èµ°ï¼Œä½†å¿…é¡»åˆ¤æ–­è¯¥æ¡è·¯æ˜¯å¦æ­£ç¡®ï¼Œ ä¸æ­£ç¡®åˆ™å¿…é¡»å›æº¯, ä¾‹å¦‚é¢˜ç›®`äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„` `å‘ä¸‹çš„è·¯å¾„èŠ‚ç‚¹ä¹‹å’Œ`

ä¸€ç¯‡æ–‡ç« è§£å†³æ‰€æœ‰äºŒå‰æ ‘è·¯å¾„é—®é¢˜ï¼ˆé—®é¢˜åˆ†æ+åˆ†ç±»æ¨¡æ¿+é¢˜ç›®å‰–æï¼‰
https://leetcode-cn.com/problems/path-sum-iii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-smch/

1. å‰åºå’Œä¸­åºç¡®å®šä¸€æ£µäºŒå‰æ ‘

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {number[]} preorder
    * @param {number[]} inorder
    * @return {TreeNode}
    */
   var buildTree = function (preorder, inorder) {
     if (!preorder.length) return null;

     let root = new TreeNode(preorder[0]);

     let index = inorder.findIndex((item) => item === root.val);

     root.left = buildTree(
       preorder.slice(1, index + 1),
       inorder.slice(0, index)
     );
     root.right = buildTree(
       preorder.slice(index + 1, preorder.length),
       inorder.slice(index + 1, preorder.length)
     );
     return root;
   };
   ```

2. ååºå’Œä¸­åºç¡®å®šä¸€æ£µäºŒå‰æ ‘

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {number[]} inorder
    * @param {number[]} postorder
    * @return {TreeNode}
    */
   var buildTree = function (inorder, postorder) {
     if (!postorder.length) return null;

     let root = new TreeNode(postorder[postorder.length - 1]);

     let index = inorder.findIndex((item) => item === root.val);

     root.left = buildTree(inorder.slice(0, index), postorder.slice(0, index));
     root.right = buildTree(
       inorder.slice(index + 1, index.length),
       postorder.slice(index, postorder.length - 1)
     );
     return root;
   };
   ```

3. è·¯å¾„æ€»å’Œ I

   https://leetcode-cn.com/problems/path-sum-ii/

   ```js
   //è·¯å¾„æ€»å’ŒI
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @param {number} targetSum
    * @return {boolean}
    */
   var hasPathSum = function (root, targetSum) {
     if (!root) return false;
     if (!root.left && !root.right) {
       return targetSum - root.val === 0;
     }
     return (
       hasPathSum(root.left, targetSum - root.val) ||
       hasPathSum(root.right, targetSum - root.val)
     );
   };
   ```

4. äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„ | è·¯å¾„æ€»å’Œ II(ä¸­)

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @param {number} target
    * @return {number[][]}
    */
   //  æ–¹æ³•ä¸€
   var pathSum = function (root, target) {
     if (!root) return [];
     var getPath = function (sum, path, node) {
       if (node.val === sum && !node.left && !node.right) {
         res.push(path);
       }
       path.push(node.val);
       if (node.left) getPath(sum - node.val, path.slice(), node.left);
       if (node.right) getPath(sum - node.val, path.slice(), node.right);
     };
     let res = [];
     getPath(target, [], root);
     return res;
   };
   ```

   ```js
   // æ–¹æ³•äºŒ
   var pathSum = function (root, target) {
     // ä¸€å®šè¦åŠ ï¼Œè§£å†³rootä¸º[]çš„æ—¶å€™
     if (!root) return [];
     let res = [];
     var getPath = function (node, sum, path) {
       if (sum + node.val === target && !node.left && !node.right) {
         // å¿…é¡»è¿™æ ·å†™ï¼Œ ä¸èƒ½å†™path.push(node.val), res.push([...path])
         res.push([...path, node.val]);
         return;
       }
       path.push(node.val);
       if (node.left) getPath(node.left, sum + node.val, path);
       if (node.right) getPath(node.right, sum + node.val, path);
       // path.pop()ä¸€å®šè¦åŠ 
       path.pop();
     };
     getPath(root, 0, []);
     return res;
   };
   ```

5. è·¯å¾„æ€»å’Œ III | å‘ä¸‹çš„è·¯å¾„èŠ‚ç‚¹ä¹‹å’Œ(ä¸­)
   æ–¹æ³•åŒºåˆ«åœ¨äºæœ‰æ²¡æœ‰äº‹å…ˆè®¾ç½® map.set(0, 1)

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @param {number} targetSum
    * @return {number}
    */
   var pathSum = function (root, targetSum) {
     let res = 0,
       map = new Map();
     map.set(0, 1);
     if (!root) return 0;
     var getPath = function (preSum, node) {
       let sum = preSum + node.val;
       res += map.get(sum - targetSum) || 0;
       map.set(sum, (map.get(sum) || 0) + 1);

       if (node.left) getPath(sum, node.left);
       if (node.right) getPath(sum, node.right);
       map.set(sum, map.get(sum) - 1);
     };
     getPath(0, root);
     return res;
   };
   ```

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @param {number} targetSum
    * @return {number}
    */
   var pathSum = function (root, targetSum) {
     let res = 0,
       map = new Map();
     const dfs = function (node, preSum) {
       if (!node) return 0;
       map.set(preSum, (map.get(preSum) || 0) + 1);
       let target = preSum + node.val;
       res += map.get(target - targetSum) || 0;
       dfs(node.left, target);
       dfs(node.right, target);
       // å›æº¯æ’¤é”€
       map.set(preSum, map.get(preSum) - 1);
     };
     dfs(root, 0);
     return res;
   };
   ```

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @param {number} targetSum
    * @return {number}
    */
   var pathSum = function (root, targetSum) {
     if (!root) return 0;
     // å‰ç¼€å’Œ + å›æº¯ + map
     let res = 0,
       map = new Map();
     var getPath = function (node, preSum) {
       // if (!node) return 0
       map.set(preSum, (map.get(preSum) || 0) + 1);
       let sum = preSum + node.val;
       res += map.get(sum - targetSum) || 0;
       if (node.left) getPath(node.left, sum);
       if (node.right) getPath(node.right, sum);
       map.set(preSum, map.get(preSum) - 1);
     };
     getPath(root, 0);
     return res;
   };
   ```

6. äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @return {string[]}
    */
   var binaryTreePaths = function (root) {
     if (!root) return [];
     let res = [];

     var getPath = function (node, curPath) {
       // ç¡®å®šç»ˆæ­¢æ¡ä»¶ï¼Œåˆ°å¶å­ç»“ç‚¹å°±ç»ˆæ­¢
       if (!node.left && !node.right) {
         curPath += node.val;
         res.push(curPath);
         return;
       }

       curPath += node.val + "->";

       if (node.left) getPath(node.left, curPath);
       if (node.right) getPath(node.right, curPath);
       // ä¸éœ€è¦popï¼Œå› ä¸ºæ¯æ¡è·¯å¾„éƒ½æ­£ç¡®
     };
     getPath(root, "");
     return res;
   };
   ```

7. ä»æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹çš„è·¯å¾„æ•°å­—ä¹‹å’Œ

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @return {number}
    */
   var sumNumbers = function (root) {
     var dfs = function (node, preSum) {
       if (!node) return 0;
       let sum = preSum * 10 + node.val;
       if (!node.left && !node.right) {
         return sum;
       } else {
         return dfs(node.left, sum) + dfs(node.right, sum);
       }
     };
     return dfs(root, 0);
   };
   ```

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @return {number}
    */
   var sumNumbers = function (root) {
     let res = 0;

     var getPath = function (node, path) {
       if (!node.left && !node.right) {
         path += node.val;
         res += +path;
         return;
       }
       if (node.left) getPath(node.left, path + node.val);
       if (node.right) getPath(node.right, path + node.val);
     };
     getPath(root, "");
     return res;
   };
   ```

8. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @return {number}
    */
   var minDepth = function (root) {
     if (!root) return 0;
     if (!root.left && !root.right) return 1;
     if (!root.left) return 1 + minDepth(root.right);
     if (!root.right) return 1 + minDepth(root.left);
     return 1 + Math.min(minDepth(root.left), minDepth(root.right));
   };
   ```

9. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ | äºŒå‰æ ‘çš„æ·±åº¦

   ```js
   // æœ€å¤§æ·±åº¦
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @return {number}
    */
   var maxDepth = function (root) {
     var getDepth = function (root) {
       if (!root) return 0;
       return 1 + Math.max(getDepth(root.left), getDepth(root.right));
     };
     return getDepth(root);
     // if (!root) return 0;
     // return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
   };
   ```

10. æœ€å¤§äºŒå‰æ ‘

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {number[]} nums
     * @return {TreeNode}
     */
    var constructMaximumBinaryTree = function (nums) {
      if (nums.length == 0) return null;
      var big = Math.max(...nums);
      var root = new TreeNode(big);
      root.left = constructMaximumBinaryTree(nums.slice(0, nums.indexOf(big)));
      root.right = constructMaximumBinaryTree(
        nums.slice(nums.indexOf(big) + 1)
      );
      return root;
    };
    ```

11. æ ‘çš„å­ç»“æ„(ä¸­ç­‰)

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val) {
     *     this.val = val;
     *     this.left = this.right = null;
     * }
     */
    /**
     * @param {TreeNode} A
     * @param {TreeNode} B
     * @return {boolean}
     */
    var isSubStructure = function (A, B) {
      // çº¦å®šç©ºæ ‘ä¸æ˜¯ä»»æ„ä¸€ä¸ªæ ‘çš„å­ç»“æ„
      // 1. åªå­˜åœ¨Bï¼Œ ä¸¤ä¸ªè‚¯å®šä¸ç›¸ç­‰
      // 2. åªå­˜åœ¨A,  ä¸¤ä¸ªè‚¯å®šä¸ç›¸ç­‰
      // 3. Aå’ŒBéƒ½ä¸å­˜åœ¨, åˆ™Bæ˜¯ç©ºæ ‘
      // if (!A || !B) return false;
      // æˆ–è€…
      if (!B) return false; // å¦‚æœBæ˜¯ç©ºæ ‘çš„è¯ï¼Œè‚¯å®šæ˜¯é”™è¯¯çš„
      if (!A) return false; // å­˜åœ¨Bï¼Œä¸å­˜åœ¨Aï¼Œåˆ™ä¸¤ä¸ªä¸ç›¸ç­‰
      return (
        isSameTree(A, B) ||
        isSubStructure(A.left, B) ||
        isSubStructure(A.right, B)
      );
    };
    // åˆ¤æ–­æœ‰æ²¡æœ‰èŠ‚ç‚¹é‡åˆ
    var isSameTree = function (A, B) {
      // ä¸‹é¢ä¸¤è¡Œé¡ºåºä¸èƒ½æ¢
      // 1. åªè¦Bä¸ºç©ºï¼Œ è‚¯å®šæ˜¯Açš„å­ç»“æ„ï¼Œ è¿”å›true
      // 2. è‹¥Aä¸ºç©ºç›´æ¥è¿”å›false, ä¸èƒ½è§£å†³Aå’ŒBéƒ½ä¸ºç©ºçš„æƒ…å†µ
      if (!B) return true;
      // è§£å†³ Bå­˜åœ¨ï¼Œ Aä¸å­˜åœ¨çš„æƒ…å†µ
      if (!A) return false;
      if (A.val !== B.val) return false;
      return isSameTree(A.left, B.left) && isSameTree(A.right, B.right);
    };
    ```

12. äºŒå‰æ ‘çš„é•œåƒ

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val) {
     *     this.val = val;
     *     this.left = this.right = null;
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {TreeNode}
     */
    var mirrorTree = function (root) {
      var reverseNode = function (node) {
        if (node) {
          [node.left, node.right] = [node.right, node.left];
          reverseNode(node.left);
          reverseNode(node.right);
        }
      };
      reverseNode(root);
      return root;
    };
    ```

13. ç¿»è½¬äºŒå‰æ ‘(å’ŒäºŒå‰æ ‘çš„é•œåƒé¢˜ç›®ä¸€æ ·)

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {TreeNode}
     */
    var invertTree = function (root) {
      if (!root) return null;
      var invert = function (left, right) {
        let temp = left;
        left = right;
        right = temp;
        root.left = left;
        root.right = right;
      };
      invert(root.left, root.right);
      invertTree(root.left);
      invertTree(root.right);
      return root;
    };
    ```

14. å¯¹ç§°äºŒå‰æ ‘(å¯¹ç§°åˆ†å·¦å³)

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {boolean}
     */
    var isSymmetric = function (root) {
      var check = function (left, right) {
        if (!left && !right) return true;
        if (!left || !right) return false;
        return (
          left.val === right.val &&
          check(left.left, right.right) &&
          check(left.right, right.left)
        );
      };
      return check(root, root);
    };
    ```

15. åˆå¹¶äºŒå‰æ ‘

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root1
     * @param {TreeNode} root2
     * @return {TreeNode}
     */
    var mergeTrees = function (root1, root2) {
      var preOrder = function (root1, root2) {
        if (!root1 && !root2) return null;
        if (!root1) return root2;
        if (!root2) return root1;
        root1.val += root2.val;
        root1.left = mergeTrees(root1.left, root2.left);
        root1.right = mergeTrees(root1.right, root2.right);
        return root1;
      };
      return preOrder(root1, root2);
    };
    ```

16. å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°(ä¸­)

    å±‚åºéå†

17. å·¦å¶å­ä¹‹å’Œ

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {number}
     */
    var sumOfLeftLeaves = function (root) {
      if (!root) return null;
      let sum = 0;
      let seq = [];
      seq.push(root);

      while (seq.length) {
        let len = seq.length;
        for (let i = 1; i <= len; i++) {
          let node = seq.shift();
          if (node.left && !node.left.left && !node.left.right) {
            sum += node.left.val;
          }
          if (node.left) seq.push(node.left);
          if (node.right) seq.push(node.right);
        }
      }
      return sum;
    };

    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {number}
     */
    var sumOfLeftLeaves = function (root) {
      let res = 0;
      var getSum = function (root, value) {
        if (!root.left && !root.right && value === 1) {
          res += root.val;
          return;
        }
        if (root.left) getSum(root.left, 1);
        if (root.right) getSum(root.right, 2);
      };
      getSum(root, 2);
      return res;
    };
    ```

18. æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {number}
     */
    var findBottomLeftValue = function (root) {
      if (!root) return null;
      let res = 0;
      let seq = [];
      seq.push(root);

      while (seq.length) {
        let len = seq.length;

        for (let i = 1; i <= len; i++) {
          let node = seq.shift();
          if (i === 1) {
            res = node.val;
          }
          if (node.left) seq.push(node.left);
          if (node.right) seq.push(node.right);
        }
      }

      return res;
    };
    ```

19. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val) {
     *     this.val = val;
     *     this.left = this.right = null;
     * }
     */
    /**
     * @param {TreeNode} root
     * @param {TreeNode} p
     * @param {TreeNode} q
     * @return {TreeNode}
     */
    var lowestCommonAncestor = function (root, p, q) {
      if (!root) return null;
      // å¦‚æœèŠ‚ç‚¹ === pæˆ–q, åˆ™æ‰¾åˆ°èŠ‚ç‚¹å¹¶è¿”å›
      if (root === p || root === q) return root;
      // å¯»æ‰¾åšå­æ ‘ç›¸åŒçš„èŠ‚ç‚¹
      let left = lowestCommonAncestor(root.left, p, q);
      // å¯»æ‰¾å³å­æ ‘ç›¸åŒçš„èŠ‚ç‚¹
      let right = lowestCommonAncestor(root.right, p, q);
      // å¦‚æœå·¦å³å„æ‰¾åˆ°ä¸€ä¸ªï¼Œ åˆ™rootä¸ºæ ¹èŠ‚ç‚¹
      if (left && right) {
        return root;
      }
      // åªæœ‰å·¦è¾¹æ‰¾åˆ°ï¼Œé‚£ä¹ˆæœ€è¿‘å…¬å…±ç¥–å…ˆåœ¨å·¦è¾¹
      if (left) return left;
      // åªæœ‰å³è¾¹æ‰¾åˆ°ï¼Œé‚£ä¹ˆæœ€è¿‘å…¬å…±ç¥–å…ˆåœ¨å³è¾¹
      if (right) return right;
    };
    ```

20. äºŒå‰æ ‘å‰ªæ(ä¸­ç­‰)- åˆ©ç”¨ååºéå†(éš¾)

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {TreeNode}
     */
    var pruneTree = function (root) {
      if (root === null) {
        return null;
      }
      root.left = pruneTree(root.left);
      root.right = pruneTree(root.right);
      if (!root.left && !root.right && root.val === 0) {
        return null;
      }
      return root;
    };
    ```

21. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {void} Do not return anything, modify root in-place instead.
     */
    var flatten = function (root) {
      let res = [];
      var preorder = function (node) {
        if (node) {
          res.push(node);
          preorder(node.left);
          preorder(node.right);
        }
      };
      preorder(root);

      for (let i = 1; i < res.length; i++) {
        const prev = res[i - 1],
          curr = res[i];
        prev.left = null;
        prev.right = curr;
      }
    };
    ```

22. äºŒå‰æ ‘çš„ç›´å¾„
    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {number}
     */
    var diameterOfBinaryTree = function (root) {
      let res = 0;
      var getRes = function (node) {
        if (!node) return 0;
        let left = getRes(node.left);
        let right = getRes(node.right);
        sum = left + right;
        res = Math.max(sum, res);
        return Math.max(left, right) + 1;
      };
      getRes(root);
      return res;
    };
    ```

## äºŒå‰æœç´¢æ ‘(éš¾)

1. äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @param {number} val
    * @return {TreeNode}
    */
   var searchBST = function (root, val) {
     if (!root) return null;
     if (root.val === val) return root;
     if (root.val > val) {
       return searchBST(root.left, val);
     }
     if (root.val < val) {
       return searchBST(root.right, val);
     }
     return null;
   };
   ```

2. éªŒè¯äºŒå‰æœç´¢æ ‘

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @return {boolean}
    */
   //  ä¸­åºéå†
   var isValidBST = function (root) {
     let arr = [];
     var inorder = function (node) {
       if (node) {
         inorder(node.left);
         arr.push(node.val);
         inorder(node.right);
       }
     };
     inorder(root);
     for (let i = 1; i < arr.length; i++) {
       if (arr[i] <= arr[i - 1]) {
         return false;
       }
     }
     return true;
   };
   ```

   ```js
   // é€’å½’
   var isValidBST = function (root) {
     var isCheck = function (root, min = -Infinity, max = Infinity) {
       if (!root) return true;
       if (root.val <= min || root.val >= max) return false;
       return (
         isCheck(root.left, min, root.val) && isCheck(root.right, root.val, max)
       );
     };
     return isCheck(root);
   };
   ```

3. äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•°

   ```js
   var findMode = function (root) {
     let map = new Map();
     var inorder = function (node) {
       if (node) {
         inorder(node.left);
         map.set(node.val, map.has(node.val) ? map.get(node.val) + 1 : 1);
         inorder(node.right);
       }
     };
     inorder(root);

     let maxValue = map.get(root.val);
     let res = [];
     for (let [key, value] of map) {
       if (value === maxValue) {
         res.push(key);
       }
       if (value > maxValue) {
         res = [];
         maxValue = value;
         res.push(key);
       }
     }
     return res;
   };
   ```

4. äºŒå‰æœç´¢æ ‘çš„ååºéå†åºåˆ—(å‰‘æŒ‡ä¸­)

   ```js
   /**
    * @param {number[]} postorder
    * @return {boolean}
    */
   var verifyPostorder = function (postorder) {
     const len = postorder.length;
     if (len < 2) return true;
     let root = postorder[len - 1];
     let i = 0;
     for (; i < len - 1; i++) {
       // å–å‡ºå³å­æ ‘çš„ç¬¬ä¸€ä¸ªindex
       if (postorder[i] > root) break;
     }
     // å³å­æ ‘ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹å¤§äºæ ¹èŠ‚ç‚¹
     let res = postorder.slice(i, len - 1).every((item) => item > root);
     // å¦åˆ™é€’å½’åˆ¤æ–­å·¦å³å­æ ‘
     return res
       ? verifyPostorder(postorder.slice(0, i)) &&
           verifyPostorder(postorder.slice(i, len - 1))
       : false;
   };
   ```

5. äºŒå‰æœç´¢æ ‘ä¸åŒå‘é“¾è¡¨

6. äºŒå‰æœç´¢æ ‘çš„ç¬¬ k å¤§èŠ‚ç‚¹(ç®€å•)

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val) {
    *     this.val = val;
    *     this.left = this.right = null;
    * }
    */
   /**
    * @param {TreeNode} root
    * @param {number} k
    * @return {number}
    */
   var kthLargest = function (root, k) {
     let res = [];
     var inorder = function (node) {
       if (node) {
         inorder(node.left);
         res.push(node.val);
         inorder(node.right);
       }
     };
     inorder(root);
     return res[res.length - k];
   };
   ```

7. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val) {
    *     this.val = val;
    *     this.left = this.right = null;
    * }
    */
   /**
    * @param {TreeNode} root
    * @param {TreeNode} p
    * @param {TreeNode} q
    * @return {TreeNode}
    */
   var lowestCommonAncestor = function (root, p, q) {
     if (!root) return null;
     // root.valæ¯”p,qèŠ‚ç‚¹éƒ½å¤§, åˆ™ç¥–å…ˆä¸€å®šåœ¨root.leftå·¦å­æ ‘
     if (root.val > p.val && root.val > q.val) {
       let left = lowestCommonAncestor(root.left, p, q);
       return left;
     }
     // root.valæ¯”p,qèŠ‚ç‚¹éƒ½å°ï¼Œåˆ™å…¬å…±ç¥–å…ˆä¸€å®šåœ¨root.rightå³å­æ ‘
     if (root.val < p.val && root.val < q.val) {
       let right = lowestCommonAncestor(root.right, p, q);
       return right;
     }
     return root;
   };
   ```

8. æ‰€æœ‰å¤§äºç­‰äºèŠ‚ç‚¹çš„å€¼ä¹‹å’Œ

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @return {TreeNode}
    */
   var convertBST = function (root) {
     // åˆ©ç”¨ç‰¹æ®Šçš„ä¸­åºéå†,
     // å…ˆéå†å³å­æ ‘ï¼Œ å†éå†root, åéå†å·¦å­æ ‘
     let sum = 0;
     var dfs = function (node) {
       // é€’å½’ç»ˆç‚¹
       if (!node) return;
       dfs(node.right);
       sum += node.val;
       node.val = sum;
       dfs(node.left);
     };
     dfs(root);
     return root;
   };
   ```

9. äºŒå‰æœç´¢æ ‘ä¸­ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹å’Œ

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @param {number} k
    * @return {boolean}
    */
   var findTarget = function (root, k) {
     const set = new Set();
     const getRes = function (node) {
       if (!node) return false;
       if (set.has(k - node.val)) return true;
       set.add(node.val);
       // åªè¦æœ‰ä¸€è¾¹æˆåŠŸå°±æ˜¯æˆåŠŸï¼Œæ‰€ä»¥æ˜¯||, å¹¶ä¸”è¦è¿”å›ç»“æœ
       return getRes(node.left) || getRes(node.right);
     };
     return getRes(root);
   };
   ```

10. å±•å¹³äºŒå‰æœç´¢æ ‘

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {TreeNode}
     */
    var increasingBST = function (root) {
      var inorder = function (node, res) {
        if (node) {
          inorder(node.left, res);
          res.push(node.val);
          inorder(node.right, res);
        }
      };
      let res = [];
      inorder(root, res);

      let dummyNode = new TreeNode(-1);
      let cur = dummyNode;
      for (let value of res) {
        cur.right = new TreeNode(value);
        cur = cur.right;
      }
      return dummyNode.right;
    };
    ```

11. äºŒå‰æœç´¢æ ‘ä¸­çš„ä¸­åºåç»§

    ```js
    // åˆ©ç”¨ä¸­åºéå†
    /**
     * Definition for a binary tree node.
     * function TreeNode(val) {
     *     this.val = val;
     *     this.left = this.right = null;
     * }
     */
    /**
     * @param {TreeNode} root
     * @param {TreeNode} p
     * @return {TreeNode}
     */
    var inorderSuccessor = function (root, p) {
      let list = [];
      var inorder = function (node) {
        if (node) {
          inorder(node.left);
          list.push(node);
          inorder(node.right);
        }
      };
      inorder(root);
      for (let i = 0; i < list.length; i++) {
        if (p.val < list[i].val) {
          return list[i];
        }
      }
      return null;
    };
    ```

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val) {
     *     this.val = val;
     *     this.left = this.right = null;
     * }
     */
    /**
     * @param {TreeNode} root
     * @param {TreeNode} p
     * @return {TreeNode}
     */
    var inorderSuccessor = function (root, p) {
      let pre,
        res = null; // éœ€è®¾ç½®resä¸ºnull
      var dfs = function (node) {
        if (!node) return;
        dfs(node.left);
        if (pre === p) res = node;
        pre = node;
        dfs(node.right);
      };
      dfs(root);
      return res;
    };
    ```

12. äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨

## å¹³è¡¡äºŒå‰æ ‘(éš¾)

1. å¹³è¡¡äºŒå‰æ ‘

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val) {
    *     this.val = val;
    *     this.left = this.right = null;
    * }
    */
   /**
    * @param {TreeNode} root
    * @return {boolean}
    */
   var isBalanced = function (root) {
     // è®°å½•äºŒå‰æ ‘æ˜¯å¦å¹³è¡¡
     let flag = true;
     var getMaxDepth = function (node) {
       if (!node) return 0;
       let leftMaxDepth = getMaxDepth(node.left);
       let rightMaxDepth = getMaxDepth(node.right);
       // å¦‚æœå·¦å³æœ€å¤§æ·±åº¦å¤§äº 1ï¼Œå°±ä¸æ˜¯å¹³è¡¡äºŒå‰æ ‘
       if (Math.abs(leftMaxDepth - rightMaxDepth) > 1) {
         flag = false;
       }
       return 1 + Math.max(leftMaxDepth, rightMaxDepth);
     };
     getMaxDepth(root);
     return flag;
   };
   ```

# å“ˆå¸Œè¡¨

1. ä¸¤æ•°ä¹‹å’Œ

   ```js
   /**
    * @param {number[]} nums
    * @param {number} target
    * @return {number[]}
    */

   //  æ—¶é—´å¤æ‚åº¦O(n)
   // ç©ºé—´å¤æ‚åº¦O(n)
   var twoSum = function (nums, target) {
     const map = {};
     if (Array.isArray(nums)) {
       for (let i = 0; i < nums.length; i++) {
         // æœ‰å¯èƒ½å­˜åœ¨0çš„æƒ…å†µ
         if (map[target - nums[i]] != undefined) {
           return [map[target - nums[i]], i];
         } else {
           map[nums[i]] = i;
         }
       }
     }
   };
   ```

2. ä¸‰æ•°ä¹‹å’Œ

   ```js
   // æ–¹æ³•ä¸€
   /**
    * @param {number[]} nums
    * @return {number[][]}
    */
   var threeSum = function (nums) {
     let res = [];
     let len = nums.length;
     if (nums == null || len < 3) {
       return res;
     }
     // æ•°ç»„ä¸­æœ‰æ•°å­—é‡å¤ï¼Œsortä¸€å®šè¦å†™å…¨
     nums.sort((a, b) => a - b);
     for (let i = 0; i < len; i++) {
       if (nums[i] > 0) break;
       if (i > 0 && nums[i] == nums[i - 1]) continue;
       let L = i + 1;
       let R = len - 1;
       while (L < R) {
         let sum = nums[i] + nums[L] + nums[R];
         if (sum === 0) {
           res.push([nums[i], nums[L], nums[R]]);
           while (L < R && nums[L] === nums[L + 1]) L++;
           while (L < R && nums[R] === nums[R - 1]) R--;
           L++;
           R--;
         } else if (sum < 0) L++;
         else if (sum > 0) R--;
       }
     }
     return res;
   };
   ```

3. å››æ•°ä¹‹å’Œ

   ```js
   /**
    * @param {number[]} nums
    * @param {number} target
    * @return {number[][]}
    */
   var fourSum = function (nums, target) {
     if (nums.length < 4) return [];
     let res = [];
     nums.sort((a, b) => a - b);

     for (let i = 0; i < nums.length; i++) {
       if (i > 0 && nums[i] === nums[i - 1]) continue;
       for (let j = i + 1; j < nums.length; j++) {
         if (j > i + 1 && nums[j] === nums[j - 1]) continue;
         let L = j + 1,
           R = nums.length - 1;
         while (L < R) {
           let sum = nums[i] + nums[j] + nums[L] + nums[R];
           if (sum === target) {
             res.push([nums[i], nums[j], nums[L], nums[R]]);
             while (L < R && nums[L] === nums[R]) L++;
             while (L < R && nums[R] === nums[R - 1]) R--;
             L++;
             R--;
           } else if (sum < target) L++;
           else if (sum > target) R--;
         }
       }
     }
     return res;
   };
   ```

4. å››æ•°ä¹‹å’ŒäºŒ

   ```js
   /**
    * @param {number[]} nums1
    * @param {number[]} nums2
    * @param {number[]} nums3
    * @param {number[]} nums4
    * @return {number}
    */
   var fourSumCount = function (nums1, nums2, nums3, nums4) {
     let res = 0;
     let map1 = new Map();

     for (let key1 of nums1) {
       for (let key2 of nums2) {
         let sum = key1 + key2;
         map1.set(sum, map1.has(sum) ? map1.get(sum) + 1 : 1);
       }
     }
     for (let key1 of nums3) {
       for (let key2 of nums4) {
         let sum2 = key1 + key2;
         res += map1.has(0 - sum2) ? map1.get(0 - sum2) : 0;
       }
     }
     return res;
   };
   ```

5. ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†

   ```js
   /**
    * @param {number[]} nums1
    * @param {number[]} nums2
    * @return {number[]}
    */
   var intersection = function (nums1, nums2) {
     let numberA = new Set(nums1);
     let numberB = new Set(nums2);
     let res = [];
     if (numberA.length > numberB.length) {
       let temp = numberA;
       numberA = numberB;
       numberB = temp;
     }
     for (let value of numberA) {
       if (numberB.has(value)) {
         res.push(value);
       }
     }
     return res;
   };
   ```

6. å¿«ä¹æ•°

   ```js
   /**
    * @param {number} n
    * @return {boolean}
    */
   var isHappy = function (n) {
     let map = new Map();
     var getSum = function (n) {
       let res = 0;
       while (n) {
         number = n % 10;
         res += number * number;
         n = Math.floor(n / 10);
       }
       return res;
     };

     while (true) {
       if (map.has(n)) return false;
       if (n === 1) return true;
       map.set(n, 1);
       n = getSum(n);
     }
   };
   ```

# åŠ¨æ€è§„åˆ’

https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/solution/dong-tai-gui-hua-bei-bao-wen-ti-yun-yong-axtf/
èƒŒåŒ…é—®é¢˜-å®«æ°´ä¸‰å¶

1. ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯

   ```js
   /**
    * @param {number[]} cost
    * @return {number}
    */
   var minCostClimbingStairs = function (cost) {
     // fill(0)å¯ä»¥ä¸åŠ 
     let dp = new Array(cost.length).fill(0);
     dp[0] = cost[0];
     dp[1] = cost[1];
     for (let i = 2; i < cost.length; i++) {
       dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];
     }

     return Math.min(dp[cost.length - 1], dp[cost.length - 2]);
   };
   ```

2. æ•´æ•°æ‹†åˆ†

   ```js
   /**
    * @param {number} n
    * @return {number}
    */
   var integerBreak = function (n) {
     let dp = new Array(n + 1).fill(0);
     dp[2] = 1;
     for (let i = 3; i <= n; i++) {
       for (let j = 1; j < i; j++) {
         dp[i] = Math.max(dp[i], dp[i - j] * j, (i - j) * j);
       }
     }
     return dp[n];
   };
   ```

   ```js
   /**
    * @param {number} n
    * @return {number}
    */
   var cuttingRope = function (n) {
     let dp = new Array(n + 1).fill(0);
     dp[1] = 1;
     for (let i = 2; i <= n; i++) {
       for (let j = 1; j < i; j++) {
         dp[i] = Math.max(dp[i], (i - j) * j, dp[i - j] * j);
       }
     }
     return dp[n];
   };
   ```

3. ä¸åŒçš„äºŒå‰æœç´¢æ ‘

   ```js
   /**
    * @param {number} n
    * @return {number}
    */
   var numTrees = function (n) {
     // fill(0)ä¸€å®šè¦åŠ 
     let dp = new Array(n + 1).fill(0);
     dp[0] = 1;
     dp[1] = 1;
     // æ³¨æ„içš„åˆå§‹å€¼ï¼Œ ä»2å¼€å§‹ï¼Œ ä»1å¼€å§‹çš„è¯dp[i]ä¼šé‡æ–°è®¡ç®—å˜ä¸º2
     for (let i = 2; i <= n; i++) {
       for (let j = 1; j <= i; j++) {
         dp[i] += dp[j - 1] * dp[i - j];
       }
     }
     return dp[n];
   };
   ```

- 0-1 èƒŒåŒ…

  ```js
  for (let i = 0; i < weight.length; i++) {
    for (let j = bagWeight; j >= weight[i]; j++) {
      dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
    }
  }
  ```

- å®Œå…¨èƒŒåŒ…

  1. å®Œå…¨èƒŒåŒ…

     ```js
     // å…ˆéå†ç‰©å“ï¼Œå†éå†èƒŒåŒ…
     for(int i = 0; i < weight.size(); i++) { // éå†ç‰©å“
       for(int j = weight[i]; j < bagWeight ; j++) { // éå†èƒŒåŒ…å®¹é‡
           dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

       }
     }
     ```

  2. æ±‚ç»„åˆä¸ªæ•°-å…ˆéå†ç‰©å“ï¼Œå†éå†èƒŒåŒ…-é›¶é’±å…‘æ¢ II

     ```js
     for (int i = 0; i < coins.size(); i++) { // éå†ç‰©å“
       for (int j = coins[i]; j <= amount; j++) { // éå†èƒŒåŒ…å®¹é‡
           dp[j] += dp[j - coins[i]];
       }
     }
     ```

  3. æ±‚æ’åˆ—ä¸ªæ•°-å…ˆéå†èƒŒåŒ…ï¼Œå†éå†ç‰©å“ - ç»„åˆæ€»å’Œ IV

     ```js
     for (int j = 0; j <= amount; j++) { // éå†èƒŒåŒ…å®¹é‡
       for (int i = 0; i < coins.size(); i++) { // éå†ç‰©å“
           if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
       }
     }
     ```

5. æœ€åä¸€å—çŸ³å¤´çš„é‡é‡äºŒ

6. ç›®æ ‡å’Œ

   ```js
   // æ–¹æ³•ä¸€: å›æº¯æ³•
   /**
    * @param {number[]} nums
    * @param {number} target
    * @return {number}
    */
   var findTargetSumWays = function (nums, target) {
     let count = 0;

     var getRes = function (sum, index) {
       if (index === nums.length) {
         if (sum === target) {
           count++;
         }
       } else {
         getRes(sum + nums[index], index + 1);
         getRes(sum - nums[index], index + 1);
       }
     };
     getRes(0, 0);
     return count;
   };
   ```

7. 1 å’Œ 0

8. åˆ†å‰²ç­‰å’Œå­é›†(éš¾) - 01 èƒŒåŒ…
   å¤–å±‚éå†ç‰©å“ï¼Œ å†…å±‚å€’åºéå†èƒŒåŒ…

   ```js
   /**
    * @param {number[]} nums
    * @return {boolean}
    */
   var canPartition = function (nums) {
     let sum = nums.reduce((pre, cur) => {
       return pre + cur;
     });
     if (sum % 2 === 1) return false;
     let average = sum / 2;

     var dp = new Array(average + 1).fill(0);

     for (let i = 0; i < nums.length; i++) {
       for (let j = average; j >= nums[i]; j--) {
         dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
         if (dp[j] === average) {
           return true;
         }
       }
     }
     return dp[sum / 2] === sum / 2;
   };
   ```

9. åˆ’åˆ†ä¸º k ä¸ªç›¸ç­‰çš„å­é›†
10. é›¶é’±å…‘æ¢ 2(éš¾) - å®Œå…¨èƒŒåŒ…æ±‚ç»„åˆæ•°
    æ±‚ç»„åˆæ•°å°±æ˜¯å¤–å±‚ for å¾ªç¯éå†ç‰©å“ï¼Œå†…å±‚ for éå†èƒŒåŒ…ã€‚

    ```js
    var change = function (amount, coins) {
      let dp = new Array(amount + 1).fill(0);
      // å‡‘æˆæ€»é‡‘é¢0çš„è´§å¸ç»„åˆæ•°ä¸º1
      dp[0] = 1;

      for (let i = 0; i < coins.length; i++) {
        for (let j = coins[i]; j <= amount; j++) {
          // dp[j]:å‡‘æˆæ€»é‡‘é¢jçš„è´§å¸ç»„åˆæ•°ä¸ºdp[j]
          // dp[j] å°±æ˜¯æ‰€æœ‰çš„dp[j-coins[i]]ç›¸åŠ 
          dp[j] += dp[j - coins[i]];
        }
      }
      return dp[amount];
    };
    ```

11. ç»„åˆæ€»å’Œå›› | æ’åˆ—çš„æ•°ç›®(éš¾) - å®Œå…¨èƒŒåŒ…æ±‚æ’åˆ—æ•°
    å›æº¯æ³•å®¹æ˜“è¶…å‡ºæ—¶é—´é™åˆ¶
    æ±‚æ’åˆ—æ˜¯å¤–å±‚éå†èƒŒåŒ…ï¼Œå†…å±‚éå†ç‰©å“

    ```js
    var combinationSum4 = function (nums, target) {
      // å…ˆéå†èƒŒåŒ…ï¼Œå†éå†ç‰©å“
      let dp = new Array(target + 1).fill(0);
      dp[0] = 1;
      for (let i = 0; i <= target; i++) {
        for (let j = 0; j < nums.length; j++) {
          if (i >= nums[j]) dp[i] += dp[i - nums[j]];
        }
      }
      return dp[target];
    };
    ```

12. é›¶é’±å…‘æ¢ | æœ€å°‘çš„ç¡¬å¸æ•°ç›®(éš¾) - å®Œå…¨èƒŒåŒ…å½¢å¼(ç»„åˆ)
    å¤–å±‚éå†ç‰©å“ï¼Œ å†…å±‚éå†èƒŒåŒ…

    ```js
    /**
     * @param {number[]} coins
     * @param {number} amount
     * @return {number}
     */
    var coinChange = function (coins, amount) {
      if (!amount) return 0;
      let dp = new Array(amount + 1).fill(Infinity);
      dp[0] = 0;

      for (let i = 0; i < coins.length; i++) {
        for (let j = coins[i]; j <= amount; j++) {
          // é€’æ¨å…¬å¼
          // dp[j]: å‡‘è¶³é‡‘é¢ä¸ºjæ‰€éœ€é’±å¸çš„æœ€å°‘ä¸ªæ•°ä¸ºdp[j]
          dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
        }
      }
      return dp[amount] === Infinity ? -1 : dp[amount];
    };
    ```

13. å®Œå…¨å¹³æ–¹æ•°

14. æ‰“å®¶åŠ«èˆä¸€äºŒä¸‰ | æˆ¿å±‹å·ç›—

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var rob = function (nums) {
      let dp = new Array(nums.length).fill(0);
      (dp[0] = nums[0]), (dp[1] = Math.max(nums[0], nums[1]));
      for (let i = 2; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
      }

      return dp[nums.length - 1];
    };
    ```

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var rob = function (nums) {
      var robRange = function (nums, start, end) {
        if (start === end) return nums[start];
        let dp = new Array(nums.length).fill(0);
        dp[start] = nums[start];
        dp[start + 1] = Math.max(nums[start], nums[start + 1]);
        for (let i = start + 2; i <= end; i++) {
          dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[end];
      };
      let len = nums.length;
      // robRangeå‡½æ•°ä¸åŒ…æ‹¬ nums.length === 0æˆ–1çš„æ—¶å€™, æ‰€ä»¥éœ€è¦ç‰¹åˆ«ä¸¾ä¾‹å‡º
      if (len === 0) return 0;
      if (len === 1) return nums[0];
      let res1 = robRange(nums, 0, len - 2);
      let res2 = robRange(nums, 1, len - 1);
      return Math.max(res1, res2);
    };
    ```

    ```js
    const rob = root => {
    // ååºéå†å‡½æ•°
    const postOrder = node => {
        // é€’å½’å‡ºå£
        if (!node) return [0, 0];
        // éå†å·¦å­æ ‘
        const left = postOrder(node.left);
        // éå†å³å­æ ‘
        const right = postOrder(node.right);
        // ä¸å·å½“å‰èŠ‚ç‚¹ï¼Œå·¦å³å­èŠ‚ç‚¹éƒ½å¯ä»¥å·æˆ–ä¸å·ï¼Œå–æœ€å¤§å€¼
        const DoNot = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        // å·å½“å‰èŠ‚ç‚¹ï¼Œå·¦å³å­èŠ‚ç‚¹åªèƒ½ä¸å·
        const Do = node.val + left[0] + right[0];
        // [ä¸å·ï¼Œå·]
        return [DoNot, Do];
    };
    const res = postOrder(root);
    // è¿”å›æœ€å¤§å€¼
    return Math.max(...res);
    ```

15. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº ä¸€äºŒä¸‰å››

16. æœ€é•¿é€’å¢(ä¸Šå‡)å­åºåˆ—(éš¾)

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var lengthOfLIS = function (nums) {
      // æ³¨æ„åˆå§‹å€¼
      let dp = new Array(nums.length).fill(1);
      let res = 1;
      for (let i = 1; i < nums.length; i++) {
        for (let j = 0; j < i; j++) {
          if (nums[i] > nums[j]) {
            // ä½ç½®içš„æœ€é•¿ä¸Šå‡å­åºåˆ—ç­‰äºjä»i-1å„ä¸ªä½ç½®çš„æœ€é•¿å‡åºå­åºåˆ— + 1çš„æœ€å¤§å€¼
            dp[i] = Math.max(dp[i], dp[j] + 1);
          }
        }
        res = Math.max(dp[i], res);
      }
      return res;
    };
    ```

17. æœ€é•¿é€’å¢å­åºåˆ—çš„ä¸ªæ•°

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var findNumberOfLIS = function (nums) {
      let res = 0;
      if (nums.length <= 1) return nums.length;
      // dp[i]ï¼šiä¹‹å‰ï¼ˆåŒ…æ‹¬iï¼‰æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦ä¸ºdp[i]
      let dp = new Array(nums.length).fill(1);
      // count[i]ï¼šä»¥nums[i]ä¸ºç»“å°¾çš„å­—ç¬¦ä¸²ï¼Œæœ€é•¿é€’å¢å­åºåˆ—çš„ä¸ªæ•°ä¸ºcount[i]
      let count = new Array(nums.length).fill(1);
      let maxCount = 0;
      for (let i = 1; i < nums.length; i++) {
        for (let j = 0; j < i; j++) {
          if (nums[i] > nums[j]) {
            // å¦‚æœdp[j]+1 > dp[i],æ›´æ–°dp[i]å’Œcount[i]
            if (dp[j] + 1 > dp[i]) {
              dp[i] = dp[j] + 1;
              count[i] = count[j];
            } else if (dp[j] + 1 === dp[i]) {
              // ä»¥iä¸ºç»“å°¾çš„å­ä¸²çš„æœ€é•¿é€’å¢å­åºåˆ—çš„ä¸ªæ•°+ä»¥jä¸ºç»“å°¾çš„å­ä¸²çš„æœ€é•¿é€’å¢å­åºåˆ—çš„ä¸ªæ•°
              count[i] += count[j];
            }
          }
          // è®°å½•æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦
          maxCount = Math.max(maxCount, dp[i]);
        }
      }
      for (let i = 0; i < nums.length; i++) {
        // ä»¥nums[i]ä¸ºç»“å°¾çš„å­—ç¬¦ä¸²ï¼Œæœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦ä¸ºmaxCountçš„ä¸ªæ•°æ±‚å’Œ
        if (dp[i] === maxCount) {
          res += count[i];
        }
      }
      return res;
    };
    ```

18. æœ€é•¿è¿ç»­é€’å¢åºåˆ—

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var findLengthOfLCIS = function (nums) {
      let dp = new Array(nums.length).fill(1);
      let result = 1;
      for (let i = 0; i < nums.length - 1; i++) {
        if (nums[i + 1] > nums[i]) {
          dp[i + 1] = dp[i] + 1;
        }
        if (result < dp[i + 1]) {
          result = dp[i + 1];
        }
      }
      return result;
    };
    ```

19. æœ€é•¿è¿ç»­åºåˆ—

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var longestConsecutive = function (nums) {
      if (!nums.length) return 0;
      let res = 1;
      nums.sort((a, b) => a - b);
      let dp = new Array(nums.length).fill(1);

      for (let i = 1; i < nums.length; i++) {
        // å¦‚æœè¿ç»­ï¼Œdp[i] + 1
        if (nums[i] === nums[i - 1] + 1) {
          dp[i] = dp[i - 1] + 1;
          // å¦‚æœä¸è¿ç»­ï¼Œ dp[i] = dp[i-1]
        } else if (nums[i] === nums[i - 1]) {
          dp[i] = dp[i - 1];
        }
        res = Math.max(res, dp[i]);
      }
      return res;
    };
    ```

20. æœ€é•¿é‡å¤å­æ•°ç»„

    ```js
    /**
     * @param {number[]} nums1
     * @param {number[]} nums2
     * @return {number}
     */
    var findLength = function (nums1, nums2) {
      // æ³¨æ„é•¿åº¦
      let dp = new Array(nums1.length + 1)
        .fill(0)
        .map((x) => new Array(nums2.length + 1).fill(0));
      let result = 0;
      for (let i = 1; i <= nums1.length; i++) {
        for (let j = 1; j <= nums2.length; j++) {
          if (nums1[i - 1] === nums2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
          }
          if (result < dp[i][j]) {
            result = dp[i][j];
          }
        }
      }
      return result;
    };
    ```

21. æœ€é•¿å…¬å…±å­åºåˆ—

    ```js
    /**
     * @param {string} text1
     * @param {string} text2
     * @return {number}
     */
    var longestCommonSubsequence = function (text1, text2) {
      let dp = new Array(text1.length + 1)
        .fill(0)
        .map((x) => new Array(text2.length + 1).fill(0));

      for (let i = 1; i <= text1.length; i++) {
        for (let j = 1; j <= text2.length; j++) {
          if (text1[i - 1] === text2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
          } else {
            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
          }
        }
      }
      return dp[text1.length][text2.length];
    };
    ```

22. æœ€å¤§å­æ•°ç»„å’Œ(æœ€å¤§å­åºå’Œ)

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var maxSubArray = function (nums) {
      let dp = new Array(nums.length).fill(0);
      // æ³¨æ„resultåˆå§‹å€¼ï¼Œ[1]çš„æƒ…å†µ
      let result = nums[0];
      dp[0] = nums[0];
      for (let i = 1; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);

        if (result < dp[i]) {
          result = dp[i];
        }
      }
      return result;
    };
    ```

23. åˆ¤æ–­å­åºåˆ—

    ```js
    /**
     * @param {string} s
     * @param {string} t
     * @return {boolean}
     */
    var isSubsequence = function (s, t) {
      let index = 0;
      for (let i = 0; i < t.length; i++) {
        if (s[index] === t[i]) {
          index++;
        }
      }
      return index >= s.length;
    };
    ```

    ```js
    var isSubsequence = function (s, t) {
      let [m, n] = [s.length, t.length];
      let dp = new Array(m + 1).fill().map((item) => new Array(n + 1).fill(0));

      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          if (s[i - 1] === t[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
          } else {
            dp[i][j] = dp[i][j - 1];
          }
        }
      }
      return dp[m][n] === m;
    };
    ```

24. å›æ–‡å­ä¸²

    ```js
    /**
     * @param {string} s
     * @return {number}
     */
    var countSubstrings = function (s) {
      var isHW = function (str, l, r) {
        for (let i = l, j = r; i < j; i++, j--) {
          if (str[i] !== str[j]) {
            return false;
          }
        }
        return true;
      };
      let res = 0;
      for (let i = 0; i < s.length; i++) {
        for (let j = i; j < s.length; j++) {
          if (isHW(s, i, j)) {
            res += 1;
          }
        }
      }
      return res;
    };
    ```

25. æœ€é•¿å›æ–‡å­åºåˆ—

    ```js
    const longestPalindromeSubseq = (s) => {
      const strLen = s.length;
      let dp = Array.from(Array(strLen), () => Array(strLen).fill(0));

      for (let i = 0; i < strLen; i++) {
        dp[i][i] = 1;
      }

      for (let i = strLen - 1; i >= 0; i--) {
        // ä¸ºä»€ä¹ˆä»i+1å¼€å§‹ï¼Œ å› ä¸ºå·²ç»è®¾è®¡dp[i][i]=1
        // å› ä¸ºæ˜¯ä»å†…å‘å¤–, å…ˆä»s[i]å’Œs[i+1]å¼€å§‹
        for (let j = i + 1; j < strLen; j++) {
          if (s[i] === s[j]) {
            // å›æ–‡å‡è®¾ä»é‡Œå‘å¤–æ‰©æ•£
            // ç”±ä¸‹é¢çš„é€’æ¨å…¬å¼å¾—å‡ºiæ˜¯å€’åºéå†ï¼Œjæ˜¯æ­£åºéå†
            dp[i][j] = dp[i + 1][j - 1] + 2;
          } else {
            dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
          }
        }
      }

      return dp[0][strLen - 1];
    };
    ```

26. å›æ–‡å­å­—ç¬¦ä¸²çš„ä¸ªæ•°
    æœ‰å¾ˆå¤šæ–¹æ³•

    ```js
    // åŠ¨æ€è§„åˆ’
    const countSubstrings = function (s) {
      const len = s.length;
      const dp = new Array(len).fill(0).map(() => new Array(len).fill(false));
      let res = 0;
      for (let i = 0; i < len; i++) {
        for (let j = i; j >= 0; j--) {
          if (s[i] === s[j]) {
            if (i - j <= 1) {
              dp[i][j] = true;
            } else {
              dp[i][j] = dp[i - 1][j + 1];
            }
          }
          res += dp[i][j] ? 1 : 0;
        }
      }
      return res;
    };
    ```

27. ä¸ç›¸äº¤çš„çº¿

    ```js
    /**
     * @param {number[]} nums1
     * @param {number[]} nums2
     * @return {number}
     */
    var maxUncrossedLines = function (nums1, nums2) {
      let [m, n] = [nums1.length, nums2.length];
      let dp = new Array(m + 1).fill().map((item) => new Array(n + 1).fill(0));

      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          if (nums1[i - 1] === nums2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
          } else {
            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
          }
        }
      }
      return dp[m][n];
    };
    ```

28. æœ€å°è·¯å¾„å’Œ

    ```js
    /**
     * @param {number[][]} grid
     * @return {number}
     */
    var minPathSum = function (grid) {
      if (grid.length === 0 || grid[0].length === 0) return 0;
      let rows = grid.length,
        columns = grid[0].length;
      // å®šä¹‰äºŒç»´æ•°ç»„
      const dp = new Array(rows);
      for (let i = 0; i < rows; i++) {
        dp[i] = new Array(columns);
      }
      dp[0][0] = grid[0][0];
      for (let i = 1; i < rows; i++) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
      }
      for (let j = 1; j < columns; j++) {
        dp[0][j] = dp[0][j - 1] + grid[0][j];
      }

      for (let i = 1; i < rows; i++) {
        for (let j = 1; j < columns; j++) {
          dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];
        }
      }

      return dp[rows - 1][columns - 1];
    };
    ```

29. ä¸‰è§’å½¢ä¸­æœ€å°è·¯å¾„å’Œ

    ```js
    /**
     * @param {number[][]} triangle
     * @return {number}
     */
    var minimumTotal = function (triangle) {
      let dp = new Array(triangle.length)
        .fill()
        .map((item, index) => new Array(triangle[index].length).fill(0));
      let len = triangle.length;

      // è¿™é‡Œå€’åº
      for (let i = len - 1; i >= 0; i--) {
        // è¿™é‡Œæ­£åºï¼Œ è™½ç„¶ä¸çŸ¥é“ä¸ºä»€ä¹ˆè¿™é‡Œä¸æ­£åº
        for (let j = 0; j < triangle[i].length; j++) {
          if (i === len - 1) {
            // æœ€åä¸€è¡Œåˆå§‹åŒ–å†™åœ¨é‡Œé¢
            dp[i][j] = triangle[i][j];
          } else {
            dp[i][j] =
              Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle[i][j];
          }
        }
      }
      return dp[0][0];
    };
    ```

30. æœ€å¤§æ­£æ–¹å½¢

    ```js
    /**
     * @param {character[][]} matrix
     * @return {number}
     */
    var maximalSquare = function (matrix) {
      let [m, n] = [matrix.length, matrix[0].length];
      let dp = new Array(m).fill().map((item) => Array(n).fill(0));
      // resæŒ‡è¾¹é•¿
      let res = 0;

      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          if (matrix[i][j] === "1") {
            // è€ƒè™‘ [[0,1],[1,0]]çš„æƒ…å†µ
            if (i === 0 || j === 0) {
              dp[i][j] = 1;
            } else {
              dp[i][j] =
                Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1;
            }
            res = Math.max(res, dp[i][j]);
          }
        }
      }
      return res * res;
    };
    ```

31. ç»Ÿè®¡å…¨ä¸º 1 çš„æ­£æ–¹å½¢å­çŸ©é˜µ

    ```js
    /**
     * @param {number[][]} matrix
     * @return {number}
     */
    var countSquares = function (matrix) {
      let [m, n] = [matrix.length, matrix[0].length];
      let res = 0;
      let dp = new Array(m).fill().map((item) => Array(n).fill(0));

      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          if (matrix[i][j] === 1) {
            // è¦ç®—ä¸Šç¬¬ä¸€åˆ—å’Œç¬¬ä¸€è¡Œçš„çŸ©é˜µä¸ªæ•°ï¼Œæ‰€ä»¥è¦å†™åœ¨é‡Œé¢
            if (i === 0 || j === 0) {
              dp[i][j] = 1;
            } else {
              dp[i][j] =
                Math.min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1;
            }
            res += dp[i][j];
          }
        }
      }
      return res;
    };
    ```

32. ä¸‹é™è·¯å¾„æœ€å°å’Œ

    ```js
    /**
     * @param {number[][]} matrix
     * @return {number}
     */
    var minFallingPathSum = function (matrix) {
      let res = Infinity;
      let m = matrix.length;
      let dp = Array(m)
        .fill()
        .map((item) => Array(m).fill(0));

      for (let i = 0; i < m; i++) {
        dp[m - 1][i] = matrix[m - 1][i];
      }
      for (let i = m - 1; i >= 0; i--) {
        for (let j = 0; j < m; j++) {
          if (i === m - 1) {
            dp[i][j] = matrix[i][j];
          } else if (j === 0) {
            dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + matrix[i][j];
          } else if (j === m - 1) {
            dp[i][j] = Math.min(dp[i + 1][j - 1], dp[i + 1][j]) + matrix[i][j];
          } else {
            dp[i][j] =
              Math.min(dp[i + 1][j - 1], dp[i + 1][j], dp[i + 1][j + 1]) +
              matrix[i][j];
          }
        }
      }
      for (let i = 0; i < m; i++) {
        res = Math.min(res, dp[0][i]);
      }
      return res;
    };
    ```

33. ç¤¼ç‰©çš„æœ€å¤§ä»·å€¼

    ```js
    /**
     * @param {number[][]} grid
     * @return {number}
     */
    var maxValue = function (grid) {
      let m = grid.length,
        n = grid[0].length;

      let dp = new Array(m).fill().map((item) => Array(n).fill(0));
      dp[0][0] = grid[0][0];
      for (let i = 1; i < m; i++) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
      }

      for (let i = 1; i < n; i++) {
        dp[0][i] = dp[0][i - 1] + grid[0][i];
      }

      for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
          dp[i][j] = Math.max(
            dp[i - 1][j] + grid[i][j],
            dp[i][j - 1] + grid[i][j]
          );
        }
      }
      return dp[m - 1][n - 1];
    };
    ```

34. ç²‰åˆ·æˆ¿å­

    ```js
    /**
     * @param {number[][]} costs
     * @return {number}
     */
    var minCost = function (costs) {
      let dp = new Array(3).fill(0);
      for (let i = 0; i < costs.length; i++) {
        let p1 = costs[i][0] + Math.min(dp[1], dp[2]);
        let p2 = costs[i][1] + Math.min(dp[0], dp[2]);
        let p3 = costs[i][2] + Math.min(dp[0], dp[1]);
        dp = [p1, p2, p3];
      }
      return Math.min(...dp);
    };
    ```

35. ç¿»è½¬å­—ç¬¦(éš¾)

    ```js
    /**
     * @param {string} s
     * @return {number}
     */
    var minFlipsMonoIncr = function (s) {
      // è®°å½•1çš„ä¸ªæ•°
      let countOf1 = s[0] === "0" ? 0 : 1;
      let dp = new Array(s.length).fill(0);
      for (let i = 1; i < s.length; i++) {
        if (s[i] === "0") {
          // s[i] ä¸º0, æœ‰ä¸¤ç§é€‰æ‹©
          // 1) å°†è‡ªå·±çš„0ç¿»è½¬ä¸º1
          // 2) å°†å‰é¢çš„æ‰€æœ‰1ç¿»è½¬ä¸º0
          dp[i] = Math.min(dp[i - 1] + 1, countOf1);
        } else {
          // è‹¥ä¸º1, ä¸å‰é¢ç›¸åŒ
          dp[i] = dp[i - 1];
          // è®°å½•1çš„ä¸ªæ•°
          countOf1++;
        }
      }
      return dp[s.length - 1];
    };
    ```

36. æœ€é•¿æ–æ³¢é‚£å¥‘æ•°åˆ—(éš¾)

    ```js
    /**
     * @param {number[]} arr
     * @return {number}
     */
    var lenLongestFibSubseq = function (arr) {
      let map = new Map();
      // è¦æ±‚nå¿…é¡»>=3
      let res = 0;
      for (let i = 0; i < arr.length; i++) {
        map.set(arr[i], i);
      }

      var dfs = function (pre, cur, len) {
        let sum = arr[pre] + arr[cur];
        if (map.has(sum)) {
          dfs(cur, map.get(sum), len + 1);
          res = Math.max(res, len + 1);
        }
      };
      for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
          dfs(i, j, 2);
        }
      }
      return res;
    };
    ```

37. å­—ç¬¦ä¸²äº¤ç»‡(ä¸ä¼š)

38. çŸ©é˜µä¸­çš„è·ç¦»(ä¸ä¼š)

    ```js

    ```

39. æŠŠæ•°å­—ç¿»è¯‘æˆå­—ç¬¦ä¸²(éš¾)

    ```js
    /**
     * @param {number} num
     * @return {number}
     */
    var translateNum = function (num) {
      const str = num.toString();
      const len = str.length;
      let dp = new Array(len + 1);
      (dp[0] = 1), (dp[1] = 1);

      for (let i = 2; i <= len; i++) {
        let temp = Number(str[i - 2] + str[i - 1]);
        if (temp > 9 && temp < 26) {
          // ä¾‹å¦‚15
          // çœ‹æˆæ•´ä½“ï¼Œdp[i] = dp[i-1]
          // ä¸ç»„åˆï¼Œ5å•ç‹¬ç¿»è¯‘, dp[i] = dp[i-1]
          dp[i] = dp[i - 1] + dp[i - 2];
        } else {
          dp[i] = dp[i - 1];
        }
      }
      return dp[len];
    };
    ```

40. è§£ç æ–¹æ³• - ä¸`æŠŠæ•°å­—ç¿»è¯‘æˆå­—ç¬¦ä¸²`æ¯”è¾ƒ

    ```js
    /**
     * @param {string} s
     * @return {number}
     */
    var numDecodings = function (s) {
      let dp = new Array(s.length + 1).fill(0);
      if (s[0] === "0") return 0;
      // ç¡®å®šè¾¹ç•Œcase, éœ€è€ƒè™‘'06'çš„æƒ…å†µ
      (dp[0] = 1), (dp[1] = s[0] === "0" ? 0 : 1);

      for (let i = 2; i <= s.length; i++) {
        // åˆ¤æ–­s.slice(i,i+2)æ˜¯å¦åœ¨1-26ä¹‹ä¸­
        let str = s.slice(i - 2, i);

        // s[i-2]å’Œs[i-1]ç»„åˆç¼–ç , æ’é™¤æ‰'05'è¿™ç§ä¸èƒ½ç»„åˆçš„æƒ…å†µ
        if (+str <= 26 && +str >= 10) {
          dp[i] = dp[i - 2];
        }
        // s[i-1]å•ç‹¬åšç¼–ç åˆæ˜¯ä¸€ç§æ–°çš„è§£ç æ–¹å¼
        if (+str[1] >= 1 && +str[1] <= 9) {
          dp[i] += dp[i - 1];
        }
      }
      return dp[s.length];
    };
    ```

41. ä¸‘æ•°
    https://leetcode-cn.com/problems/chou-shu-lcof/solution/js-jian-zhi-offer-49-chou-shu-by-adela20-4q7p/

    ```js
    /**
     * @param {number} n
     * @return {number}
     */
    var nthUglyNumber = function (n) {
      const dp = [1];
      let p2 = 0,
        p3 = 0,
        p5 = 0;
      for (let i = 1; i < n; i++) {
        let n2 = dp[p2] * 2,
          n3 = dp[p3] * 3,
          n5 = dp[p5] * 5;
        dp[i] = Math.min(n2, n3, n5);
        dp[i] == n2 && p2++;
        dp[i] == n3 && p3++;
        dp[i] == n5 && p5++;
      }
      return dp[n - 1];
    };
    ```

42. è·³è·ƒæ¸¸æˆ

43. è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦
    https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/solution/yi-ci-bian-li-javascript-by-lzxjack-su9l/

    ```js
    /**
     * @param {number[]} prices
     * @return {number}
     */
    const maxProfit = (prices) => {
      const len = prices.length;
      // åˆ›å»ºdpæ•°ç»„
      const dp = new Array(len).fill([0, 0]);
      // dpæ•°ç»„åˆå§‹åŒ–
      dp[0] = [-prices[0], 0];
      for (let i = 1; i < len; i++) {
        // æ›´æ–°dp[i]
        dp[i] = [
          Math.max(dp[i - 1][0], -prices[i]),
          Math.max(dp[i - 1][1], prices[i] + dp[i - 1][0]),
        ];
      }
      return dp[len - 1][1];
    };
    ```

44. ä¹˜ç§¯æœ€å¤§å­æ•°ç»„

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var maxProduct = function (nums) {
      let res = nums[0];
      let preMin = nums[0],
        preMax = nums[0];
      let temp1 = 0,
        temp2 = 0;
      for (let i = 1; i < nums.length; i++) {
        temp1 = preMin * nums[i];
        temp2 = preMax * nums[i];
        preMin = Math.min(temp1, temp2, nums[i]);
        preMax = Math.max(temp1, temp2, nums[i]);
        res = Math.max(res, preMax);
      }
      return res;
    };
    ```

45. æœ€é•¿å®šå·®å­åºåˆ—

    ```js
    /**
     * @param {number[]} arr
     * @param {number} difference
     * @return {number}
     */
    var longestSubsequence = function (arr, difference) {
      // çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸º
      // dp[num] = dp[num - difference] + 1;  // æƒ…å†µ1
      // dp[num] = 1                          // æƒ…å†µ2
      let res = 0;
      const dp = new Map();
      for (let i = 0; i < arr.length; i++) {
        dp.set(arr[i], (dp.get(arr[i] - difference) || 0) + 1);
        res = Math.max(res, dp.get(arr[i]));
      }
      return res;
    };
    ```

46. å•è¯æ‹†åˆ† - å®Œå…¨èƒŒåŒ…ç»å…¸é¢˜

    ```js
    /**
     * @param {string} s
     * @param {string[]} wordDict
     * @return {boolean}
     */
    var wordBreak = function (s, wordDict) {
      // å®Œå…¨èƒŒåŒ…ç®—æ³•
      let dp = new Array(s.length + 1).fill(false);
      // ç¬¬ä¸€ä¸ªä¸€å®šè¦è®¾ç½®true, æ‰èƒ½ä½¿åé¢çš„æ ¹æ®å‰é¢çš„è®¾ç½®ä¸ºtrue
      dp[0] = true;
      for (let i = 0; i <= s.length; i++) {
        for (let j = 0; j < wordDict.length; j++) {
          // å‰ææ˜¯s[i] >= wordDict[j].length
          if (i >= wordDict[j].length) {
            // s.slice(i-wordDict[j].length, i) === wordDict[j] å¹¶ä¸” ä¹‹å‰çš„ä¸ºtrue
            if (
              s.slice(i - wordDict[j].length, i) === wordDict[j] &&
              dp[i - wordDict[j].length]
            ) {
              dp[i] = true;
            }
          }
        }
      }
      return dp[s.length];
    };
    ```

47. æ·éª°å­çš„ N ç§æ–¹æ³•

# å›æº¯

- for å¾ªç¯æ¨ªå‘éå†ï¼Œ é€’å½’çºµå‘éå†
- é¢˜ç›®åˆ†ç±»: ç»„åˆ(1,2)ï¼Œå­é›†(3,4,5)ï¼Œ æ’åˆ—(6,7,8)ï¼Œ åˆ†å‰²(9,10)ï¼Œ æ£‹ç›˜é—®é¢˜ï¼Œ å…¶å®ƒ(é€’å¢å­åºåˆ—ï¼Œ é‡æ–°å®‰æ’è¡Œç¨‹)

1. ç”µè¯å·ç çš„å­—æ¯ç»„åˆ

2. ç»„åˆ

   ```js
   /**
    * @param {number} n
    * @param {number} k
    * @return {number[][]}
    */
   var combine = function (n, k) {
     let res = [],
       path = [];

     var getPath = function (index) {
       if (path.length === k) {
         res.push([...path]);
         return;
       }
       for (let i = index; i <= n; i++) {
         path.push(i);
         getPath(i + 1);
         path.pop();
       }
     };
     getPath(1);
     return res;
   };
   ```

3. ç»„åˆæ€»å’Œ III

   ```js
   /**
    * @param {number} k
    * @param {number} n
    * @return {number[][]}
    */
   var combinationSum3 = function (k, n) {
     let res = [],
       path = [];
     var getPath = function (sum, index) {
       if (sum > n) return;
       if (sum === n && path.length === k) {
         res.push([...path]);
         return;
       }
       for (let i = index; i <= 9; i++) {
         path.push(i);
         getPath(sum + i, i + 1);
         path.pop();
       }
     };
     getPath(0, 1);
     return res;
   };
   ```

4. ç»„åˆæ€»å’Œ | å…è®¸é‡å¤é€‰æ‹©å…ƒç´ çš„ç»„åˆ

   ```js
   var combinationSum = function (candidates, target) {
     candidates.sort();
     let res = [];
     var getPath = function (sum, path, j) {
       // if (sum > target) return
       if (sum === target) {
         res.push([...path]);
         return;
       }
       for (let i = j; i < candidates.length; i++) {
         let number = candidates[i];
         // ä¸åŠ ä¼šå¯¼è‡´æ ˆæº¢å‡º
         if (number > target - sum) continue;
         path.push(number);

         sum += number;
         // ä¸èƒ½å†™sum+candidates[i], å¦åˆ™ sum-=numberæ”¹çš„å°±æ˜¯åŸæ¥çš„sum, ä¸æ˜¯åŠ è¿‡numberåçš„sum
         getPath(sum, path, i);
         path.pop();
         sum -= number;
       }
     };
     getPath(0, [], 0);
     return res;
   };
   ```

5. ç»„åˆæ€»å’Œ II | å«æœ‰é‡å¤å…ƒç´ é›†åˆçš„ç»„åˆ(éš¾)

   ```js
   var combinationSum2 = function (candidates, target) {
     const res = [],
       path = [];
     candidates.sort(); // æ’åº
     backtracking(0, 0);
     return res;
     function backtracking(j, sum) {
       if (sum > target) return;
       if (sum === target) {
         res.push(Array.from(path));
         return;
       }
       let f = -1;
       for (let i = j; i < candidates.length; i++) {
         const n = candidates[i];
         if (n > target - sum || f === n) continue;
         path.push(n);
         sum += n;
         backtracking(i + 1, sum);
         f = n;
         path.pop();
         sum -= n;
       }
     }
   };
   ```

6. é€’å¢å­åºåˆ—

   ```js
   /**
    * @param {number[]} nums
    * @return {number[][]}
    */
   var findSubsequences = function (nums) {
     let res = [];

     var getPath = function (path, j) {
       if (path.length > 1) {
         res.push([...path]);
       }
       let uset = [];
       for (let i = j; i < nums.length; i++) {
         if (
           (path.length > 0 && nums[i] < path[path.length - 1]) ||
           uset[nums[i] + 100]
         )
           continue;
         uset[nums[i] + 100] = true;
         path.push(nums[i]);
         getPath(path, i + 1);
         path.pop();
       }
     };
     getPath([], 0);
     return res;
   };
   ```

7. å…¨æ’åˆ— | æ²¡æœ‰é‡å¤å…ƒç´ é›†åˆçš„å…¨æ’åˆ—

   ```js
   /**
    * @param {number[]} nums
    * @return {number[][]}
    */
   var permute = function (nums) {
     let res = [];
     var getPath = function (path, used) {
       if (path.length === nums.length) {
         res.push([...path]);
         return;
       }
       for (let i = 0; i < nums.length; i++) {
         if (used[i]) continue;
         path.push(nums[i]);
         used[i] = true;
         getPath(path, used);
         path.pop();
         used[i] = false;
       }
     };
     getPath([], []);
     return res;
   };
   ```

8. å…¨æ’åˆ— II | å«æœ‰é‡å¤å…ƒç´ é›†åˆçš„å…¨æ’åˆ— - å¯ä»¥ç”¨ f

   ```js
   // æ–¹æ³•ä¸€
   /**
    * @param {number[]} nums
    * @return {number[][]}
    */
   var permuteUnique = function (nums) {
     nums.sort((a, b) => a - b);
     let res = [];
     var getPath = function (path, used) {
       if (path.length === nums.length) {
         res.push([...path]);
         return;
       }
       let f = "";
       for (let i = 0; i < nums.length; i++) {
         if (used[i] || f === nums[i]) continue;
         path.push(nums[i]);
         f = nums[i];
         used[i] = true;
         getPath(path, used);
         path.pop();
         used[i] = false;
       }
     };
     getPath([], []);
     return res;
   };
   ```

9. å­—ç¬¦ä¸²çš„æ’åˆ—(éš¾)

   ```js
   /**
    * @param {string} s
    * @return {string[]}
    */
   var permutation = function (s) {
     // 1. å­—ç¬¦æ’åºæ—¶ä¸éœ€è¦åŠ  (a,b) => a-b ,ä¼šå‡ºé”™
     // 2. séœ€è¦é‡æ–°èµ‹å€¼
     s = s.split("").sort();
     let res = [];
     let len = s.length;
     var getPath = function (path, used) {
       if (path.length === s.length) {
         res.push(path.join(""));
         return;
       }
       let f = "";
       for (let i = 0; i < len; i++) {
         if (used[i] || f === s[i]) continue;
         path.push(s[i]);
         used[i] = true;
         f = s[i];
         getPath(path, used);
         path.pop();
         used[i] = false;
       }
     };
     getPath([], []);
     return res;
   };
   ```

   ```js
   var permutation = function (s) {
     s = s.split("").sort().join("");
     let n = s.length;

     let res = [],
       path = [];
     backtrack([]);
     return res;

     function backtrack(used) {
       if (path.length === n) {
         res.push(path.slice());
         return;
       }

       for (let i = 0; i < n; i++) {
         if (used[i]) continue;
         if (i > 0 && s[i] === s[i - 1] && !used[i - 1]) continue;

         used[i] = 1;
         path = path + s[i];
         backtrack(used);
         used[i] = 0;
         path = path.slice(0, path.length - 1);
       }
     }
   };
   ```

10. åˆ†å‰²å›æ–‡å­å­—ç¬¦ä¸² | åˆ†å‰²å›æ–‡ä¸²

    ```js
    /**
     * @param {string} s
     * @return {string[][]}
     */
    var partition = function (s) {
      let res = [],
        len = s.length;
      // sè¡¨ç¤ºä¸€æ•´ä¸ªå­—ç¬¦ä¸²
      var isHW = function (s, l, r) {
        for (let i = l, j = r; i < j; i++, j--) {
          if (s[i] !== s[j]) return false;
        }
        return true;
      };

      var getPath = function (path, i) {
        if (i >= len) {
          res.push([...path]);
          return;
        }
        for (let j = i; j < s.length; j++) {
          if (!isHW(s, i, j)) continue;
          // éœ€è¦è€ƒè™‘ i===jçš„æ—¶å€™ï¼Œæ‰€ä»¥å¿…é¡»j-i+1, è‡³å°‘æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²
          path.push(s.substr(i, j - i + 1));
          getPath(path, j + 1);
          path.pop();

          // æˆ–è€…
          // let str = s.substr(i, j - i + 1);
          // if (!isHW(i, j, s)) continue;
          // path.push(str);
          // getPath(path, j + 1);
          // path.pop();
        }
      };
      getPath([], 0);
      return res;
    };
    ```

11. å¤åŸ IP åœ°å€(éš¾)

    ```js
    /**
     * @param {string} s
     * @return {string[]}
     */
    var restoreIpAddresses = function (s) {
      let res = [];

      var getPath = function (path, i) {
        let len = path.length;
        // ä¸€å®šè¦åŠ 
        if (len > 4) return;
        // åˆ¤æ–­æ¡ä»¶ä¸ºé•¿åº¦ä¸º4ï¼Œ ä¸”så…¨éƒ¨éå†å®Œ
        if (len === 4 && i === s.length) {
          res.push(path.join("."));
          return;
        }
        for (let j = i; j < s.length; j++) {
          // è¡¨ç¤ºä»iå¼€å§‹ï¼Œå–j-i+1ä¸ªå…ƒç´ , è¦æ±‚è‡³å°‘æœ‰ä¸€ä¸ªå…ƒç´ ,å¦åˆ™strä¸ºç©ºï¼Œä¼šå¾ªç¯çˆ†æ ˆ
          let str = s.substr(i, j - i + 1);
          // ä¹Ÿå¯ä»¥ç”¨continue
          // æ’é™¤ >255çš„æƒ…å†µ
          if (str.length > 3 || +str > 255) break;
          // str[0]ä¸ºå­—ç¬¦ä¸²'0'
          // æ’é™¤ è¿˜æœ‰å‰å¯¼0çš„æƒ…å†µ
          if (str.length > 1 && str[0] === "0") break;
          path.push(str);
          getPath(path, j + 1);
          path.pop();
        }
      };
      getPath([], 0);
      return res;
    };
    ```

12. åŠ å‡çš„ç›®æ ‡å€¼ | ç›®æ ‡å’Œ

    ```js
    /**
     * @param {number[]} nums
     * @param {number} target
     * @return {number}
     */
    var findTargetSumWays = function (nums, target) {
      let res = 0;
      var getRes = function (sum, index) {
        // if else éœ€è¦åˆ¤æ–­
        if (index === nums.length) {
          if (sum === target) {
            res++;
            // returnåŠ ä¸åŠ éƒ½å¯ä»¥
            return;
          }
        } else {
          // ä¸æ˜¯index++
          getRes(sum + nums[index], index + 1);
          getRes(sum - nums[index], index + 1);
        }
      };
      getRes(0, 0);
      return res;
    };
    ```

13. æ‰€æœ‰è·¯å¾„(éš¾)

    ```js
    /**
     * @param {number[][]} graph
     * @return {number[][]}
     */
    var allPathsSourceTarget = function (graph) {
      let res = [],
        path = [];
      var getPath = function (index) {
        // å³åˆ°è¾¾æœ€åä¸€ä¸ªèŠ‚ç‚¹, è¯¥èŠ‚ç‚¹ä¸ºç©º
        if (index === graph.length - 1) {
          res.push([...path]);
          return;
        }
        for (let node of graph[index]) {
          path.push(node);
          getPath(node);
          path.pop();
        }
      };
      path.push(0);
      getPath(0);
      return res;
    };
    ```

14. ç”ŸæˆåŒ¹é…çš„æ‹¬å· | æ‹¬å·ç”Ÿæˆ

    ```js
    /**
     * @param {number} n
     * @return {string[]}
     */
    var generateParenthesis = function (n) {
      let res = [];

      var getPath = function (path, open, close) {
        // å‰ªæ
        if (open > n || close > open) return;
        if (path.length === 2 * n) {
          res.push(path);
          return;
        }
        getPath(path + "(", open + 1, close);
        getPath(path + ")", open, close + 1);
      };
      getPath("", 0, 0);
      return res;
    };
    ```

15. çŸ©é˜µä¸­çš„è·¯å¾„ | å•è¯æœç´¢(éš¾)

    ```js
    /**
     * @param {character[][]} board
     * @param {string} word
     * @return {boolean}
     */
    var exist = function (board, word) {
      const [m, n] = [board.length, board[0].length];

      const dfs = function (r, c, index) {
        // è¶Šç•Œã€æˆ–è€…å­—ç¬¦ä¸åŒ¹é…
        if (r < 0 || r >= m || c < 0 || c >= n || board[r][c] !== word[index])
          return false;
        // ç´¢å¼•ç­‰äºå•è¯é•¿åº¦-1ï¼Œè¯´æ˜å…¨åŒ¹é…ä¸Šäº†
        // å› ä¸ºå‰é¢board[r][c] !== word[index] å·²ç»åˆ¤æ–­å­—ç¬¦æ˜¯å¦ç›¸ç­‰äº†
        if (index === word.length - 1) return true;
        // ä¿å­˜å½“å‰å­—ç¬¦
        let temp = board[r][c];
        // å°†å½“å‰å­—ç¬¦è®¾ç½®ä¸ºç©ºï¼Œé˜²æ­¢å››ä¸ªæ–¹å‘dfså†æ¬¡éå†åˆ°ï¼Œ å› ä¸ºåŒä¸€ä¸ªå•å…ƒæ ¼å†…çš„å­—æ¯ä¸å…è®¸è¢«é‡å¤ä½¿ç”¨
        board[r][c] = "";
        // è¦ç”¨æˆ–è€…
        let res =
          dfs(r + 1, c, index + 1) ||
          dfs(r - 1, c, index + 1) ||
          dfs(r, c + 1, index + 1) ||
          dfs(r, c - 1, index + 1);
        // æ¢å¤å½“å‰å­—ç¬¦
        board[r][c] = temp;
        return res;
      };

      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          if (dfs(i, j, 0)) return true;
        }
      }
      return false;
    };
    s;
    ```

16. ä¸åŒçš„äºŒå‰æœç´¢æ ‘ II

17. è¿ç»­å·®ç›¸åŒçš„æ•°å­—

    ```js
    /**
     * @param {number} n
     * @param {number} k
     * @return {number[]}
     */
    var numsSameConsecDiff = function (n, k) {
      let res = [];
      let path = [];
      for (let i = 1; i <= 9; i++) {
        path[0] = i;
        var getPath = function (path, index) {
          if (index === n) {
            res.push(+path.join(""));
            return;
          }
          if (path[path.length - 1] + k < 10) {
            let number = path[path.length - 1] + k;
            path.push(number);
            getPath(path, index + 1);
            path.pop();
          }
          // æ’é™¤kç­‰äº0æ—¶é‡å¤ 11å’Œ11çš„æƒ…å†µ
          if (k !== 0) {
            if (path[path.length - 1] - k >= 0) {
              let number = path[path.length - 1] - k;
              path.push(number);
              getPath(path, index + 1);
              path.pop();
            }
          }
        };
        getPath(path, 1);
      }
      return res;
    };
    ```

18. N çš‡å

19. è§£æ•°ç‹¬

20. å•è¯æ‹†åˆ† II

21. æ‰“å°ä» 1 åˆ°æœ€å¤§çš„ n ä½æ•°-è€ƒè™‘å¤§æ•°(1. å›æº¯ 2. ä½è¿ç®—)(éš¾)
    https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution/4chong-jie-fa-bao-li-zi-fu-chuan-wei-yun-v2dr/

    ```js
    /**
     * @param {number} n
     * @return {number[]}
     */
    var printNumbers = function (n) {
      let res = [];
      var dfs = function (index, str) {
        if (index === n) {
          res.push(+str);
          return;
        }
        for (let i = 0; i <= 9; i++) {
          str += i.toString();
          dfs(index + 1, str);
          str = str.slice(0, str.length - 1);
        }
      };
      dfs(0, "");
      res.shift();
      return res;
    };
    ```

22. ç½‘æ˜“ç¬”è¯•é¢˜ - ä¸‰ä¸ªæ•°åŠ å‡ä¹˜é™¤ç­‰äº 24

    ```js
    // ä¸‰ä¸ªæ•°åŠ å‡ä¹˜é™¤ï¼Œå¯ä¸å¯ä»¥å¾—åˆ°24
    var getSum = function (arr) {
      let res = "";
      var dfs = function (used, sum, path) {
        if (path.length === 3) {
          if (sum > 24) return;
          if (sum === 24) {
            console.log(path, sum, "pathå’Œsum");
            res = true;
            return;
          }
        } else {
          for (let i = 0; i < arr.length; i++) {
            if (used[i]) continue;
            let num = arr[i];
            used[i] = true;
            path.push(num);

            if (getCount(used) === 1) {
              dfs(used, num, path);
              dfs(used, num, path);
              dfs(used, num, path);
              dfs(used, num, path);
            } else {
              dfs(used, sum + num, path);
              dfs(used, sum - num, path);
              dfs(used, sum * num, path);
              dfs(used, sum / num, path);
            }
            path.pop();
            used[i] = false;
          }
        }
      };
      dfs([], 0, []);
      return res === true ? true : false;
    };

    var getCount = function (used) {
      let count = 0;
      used.forEach((item) => {
        if (item) {
          count++;
        }
      });
      return count;
    };

    let arr = [1, 1, 24];
    let res = getSum(arr);
    console.log(res, "res");
    ```

# è´ªå¿ƒç®—æ³•

1. åˆ†å‘é¥¼å¹²

   ```js
   /**
    * @param {number[]} g
    * @param {number[]} s
    * @return {number}
    */
   var findContentChildren = function (g, s) {
     g.sort((a, b) => a - b);
     s.sort((a, b) => a - b);
     let res = 0;
     let index = s.length - 1;
     for (let i = g.length - 1; i >= 0; i--) {
       if (index >= 0 && s[index] >= g[i]) {
         res++;
         index--;
       }
     }
     return res;
   };
   ```

   ```js
   // è‡ªå·±çš„å†™æ³•
   /**
    * @param {number[]} g
    * @param {number[]} s
    * @return {number}
    */
   var findContentChildren = function (g, s) {
     let res = 0;
     g.sort((a, b) => a - b);
     s.sort((a, b) => a - b);
     let i = g.length - 1,
       j = s.length - 1;

     while (j >= 0 && i >= 0) {
       if (s[j] >= g[i]) {
         res++;
         j--;
       }
       i--;
     }
     return res;
   };
   ```

2. æ‘†åŠ¨åºåˆ—
   å±€éƒ¨æœ€ä¼˜ï¼šåˆ é™¤å•è°ƒå¡åº¦ä¸Šçš„èŠ‚ç‚¹ï¼ˆä¸åŒ…æ‹¬å•è°ƒå¡åº¦ä¸¤ç«¯çš„èŠ‚ç‚¹ï¼‰ï¼Œé‚£ä¹ˆè¿™ä¸ªå¡åº¦å°±å¯ä»¥æœ‰ä¸¤ä¸ªå±€éƒ¨å³°å€¼ã€‚

   æ•´ä½“æœ€ä¼˜ï¼šæ•´ä¸ªåºåˆ—æœ‰æœ€å¤šçš„å±€éƒ¨å³°å€¼ï¼Œä»è€Œè¾¾åˆ°æœ€é•¿æ‘†åŠ¨åºåˆ—ã€‚

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var wiggleMaxLength = function (nums) {
     if (nums.length <= 1) return 1;
     let result = 1;
     let pre = 0;
     let cur = 0;
     for (let i = 0; i < nums.length; i++) {
       cur = nums[i + 1] - nums[i];
       if ((pre >= 0 && cur < 0) || (pre <= 0 && cur > 0)) {
         result++;
         pre = cur;
       }
     }
     return result;
   };
   ```

3. è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦ | ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº I

   ```js
   /**
    * @param {number[]} prices
    * @return {number}
    */
   var maxProfit = function (prices) {
     let min = prices[0];
     let profit = 0;
     for (let i = 1; i < prices.length; i++) {
       min = Math.min(min, prices[i]);
       profit = Math.max(profit, prices[i] - min);
     }
     return profit;
   };
   ```

4. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº II

   ```js
   /**
    * @param {number[]} prices
    * @return {number}
    */
   var maxProfit = function (prices) {
     let result = 0;
     for (let i = 1; i < prices.length; i++) {
       result += Math.max(prices[i] - prices[i - 1], 0);
     }
     return result;
   };
   ```

5. è·³è·ƒæ¸¸æˆ

   ```js
   var canJump = function (nums) {
     // if (nums.length === 1) return true;
     let cover = 0;
     // i<=coveréƒ¨ç½²èŒƒå›´å†…
     for (let i = 0; i <= cover; i++) {
       // æ±‚å±€éƒ¨æœ€é•¿çš„è·³è·ƒè¦†ç›–èŒƒå›´
       cover = Math.max(cover, i + nums[i]);
       if (cover >= nums.length - 1) {
         return true;
       }
     }
     return false;
   };
   ```

6. è·³è·ƒæ¸¸æˆ II

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var jump = function (nums) {
     // å½“å‰è¦†ç›–çš„æœ€è¿œè·ç¦»ä¸‹æ ‡
     let curIndex = 0;
     // ä¸‹ä¸€æ­¥è¦†ç›–çš„æœ€è¿œè·ç¦»ä¸‹æ ‡
     let nextIndex = 0;
     let step = 0;
     // æ³¨æ„içš„å–å€¼èŒƒå›´
     for (let i = 0; i < nums.length - 1; i++) {
       // å½“å‰ç´¢å¼•å¯è¦†ç›–çš„èŒƒå›´å’Œä¹‹å‰nextIndexè¿›è¡Œæ¯”è¾ƒ
       // æ±‚ä¸‹ä¸€æ­¥çš„æœ€å¤§ç´¢å¼•
       nextIndex = Math.max(nums[i] + i, nextIndex);
       // å‡å¦‚ç§»åŠ¨ä¸‹æ ‡å·²ç»é‡åˆ°å½“å‰è·ç¦»æœ€è¿œè¦†ç›–ä¸‹æ ‡ï¼Œæ­¥æ•°+1
       if (i === curIndex) {
         curIndex = nextIndex;
         step++;
       }
     }
     return step;
   };
   ```

# æ»‘åŠ¨çª—å£

https://leetcode-cn.com/problems/2VG8Kg/solution/shua-chuan-jian-zhi-offer-day06-shu-zu-i-d5ne/

å¦‚ä½•è¯†åˆ«æ»‘åŠ¨çª—å£çš„é¢˜ç›®ï¼Ÿä¸€èˆ¬é¢˜ç›®ä¸­éƒ½ä¼šæœ‰æ˜ç¡®çš„â€œè¿ç»­å­æ•°ç»„â€ã€â€œè¿ç»­å­ä¸²â€ç­‰å…³é”®å­—ï¼Œå¦å¤–å¯èƒ½ä¼šé™„å¸¦æœ€å¤§ã€æœ€å°çš„é™å®šè¯è¿›è¡Œè¡¥å……ã€‚

```
åˆå§‹åŒ–å·¦è¾¹ç•Œ left = 0
åˆå§‹åŒ–è¿”å›å€¼ ret = æœ€å°å€¼ or æœ€å¤§å€¼
for å³è¾¹ç•Œ in å¯è¿­ä»£å¯¹è±¡:
  æ›´æ–°çª—å£å†…éƒ¨ä¿¡æ¯
  while æ ¹æ®é¢˜æ„è¿›è¡Œè°ƒæ•´ï¼š
    æ¯”è¾ƒå¹¶æ›´æ–°ret(æ”¶ç¼©åœºæ™¯æ—¶)
    æ‰©å¼ æˆ–æ”¶ç¼©çª—å£å¤§å°
  æ¯”è¾ƒå¹¶æ›´æ–°ret(æ‰©å¼ åœºæ™¯æ—¶)
è¿”å› ret
```

1. å’Œå¤§äºç­‰äº target çš„æœ€çŸ­å­æ•°ç»„ | é•¿åº¦æœ€å°çš„å­æ•°ç»„

   ```js
   /**
    * @param {number} target
    * @param {number[]} nums
    * @return {number}
    */
   var minSubArrayLen = function (target, nums) {
     let left = 0;
     let sum = 0,
       res = nums.length + 1;
     for (let right = 0; right < nums.length; right++) {
       sum += nums[right];

       while (sum >= target && left <= right) {
         res = Math.min(res, right - left + 1);

         sum -= nums[left];
         left++;
       }
     }

     // ç»†èŠ‚æŠŠæ¡å¥½
     return res === nums.length + 1 ? 0 : res;
   };
   ```

2. ä¹˜ç§¯å°äº k çš„å­æ•°ç»„

   ```js
   /**
    * @param {number[]} nums
    * @param {number} k
    * @return {number}
    */
   var numSubarrayProductLessThanK = function (nums, k) {
     let left = 0;
     let res = 0,
       sum = 1;
     for (let right = 0; right < nums.length; right++) {
       sum *= nums[right];

       while (sum >= k && left <= right) {
         sum /= nums[left];
         left++;
       }
       res += right >= left ? right - left + 1 : 0;
     }
     return res;
   };
   ```

3. å’Œä¸º k çš„å­æ•°ç»„
   æ€è·¯: ä½¿ç”¨å‰ç¼€å’Œ
   https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484488&idx=1&sn=848f76e86fce722e70e265d0c6f84dc3&source=41#wechat_redirect

   ```js
   /**
    * @param {number[]} nums
    * @param {number} k
    * @return {number}
    */
   var subarraySum = function (nums, k) {
     let res = 0,
       sum = 0;
     let map = new Map();
     map.set(0, 1);

     for (let i = 0; i < nums.length; i++) {
       sum += nums[i];
       res += map.get(sum - k) || 0;
       map.set(sum, (map.get(sum) || 0) + 1);
     }
     return res;
   };
   ```

4. 0 å’Œ 1 ä¸ªæ•°ç›¸åŒçš„å­æ•°ç»„
   æ€è·¯: ä½¿ç”¨å‰ç¼€å’Œ

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var findMaxLength = function (nums) {
     const n = nums.length;
     const map = new Map();
     map.set(0, -1);
     // å‰ç¼€å’Œ
     let pre = 0;
     let res = 0;
     for (let i = 0; i < n; i++) {
       pre += nums[i] == 0 ? -1 : 1;
       // å¦‚æœå­˜åœ¨çš„è¯ï¼Œåˆ™å°†å½“å‰ç´¢å¼•å’Œä¹‹å‰å­˜å…¥çš„ç´¢å¼•å€¼ç›¸å‡  å–é¢˜ç›®è¦æ±‚çš„æœ€å¤§å€¼
       if (map.has(pre)) {
         res = Math.max(res, i - map.get(pre));
       } else {
         // è®°å½•å‰ç¼€å’Œç´¢å¼•
         map.set(pre, i);
       }
     }
     return res;
   };
   ```

5. ä¸å«é‡å¤å­—ç¬¦çš„æœ€é•¿å­å­—ç¬¦ä¸²(ä¸­)
   https://leetcode-cn.com/problems/wtcaE1/solution/jian-dan-yi-dong-javac-pythonjshua-dong-dtang/

   ```js
   /**
    * @param {string} s
    * @return {number}
    */
   var lengthOfLongestSubstring = function (s) {
     // çª—å£ä¸­çš„å­—ç¬¦
     let window = {};
     let left = 0,
       res = 0;
     for (let right = 0; right < s.length; right++) {
       let str = s[right];
       window[str] = (window[str] || 0) + 1;
       while (window[str] > 1) {
         // éœ€è¦æ€è€ƒ
         let strL = s[left];
         left++;
         window[strL]--;
       }
       res = Math.max(res, right - left + 1);
     }
     return res;
   };
   ```

6. ç»å¯¹å·®ä¸è¶…è¿‡é™åˆ¶çš„æœ€é•¿è¿ç»­å­æ•°ç»„

   ```js
   /**
    * @param {number[]} nums
    * @param {number} limit
    * @return {number}
    */
   var longestSubarray = function (nums, limit) {
     const queMax = [],
       queMin = [];
     let left = 0,
       right = 0;
     let res = 0;
     for (let right = 0; right < nums.length; right++) {
       // ä¸€ä¸ªå•è°ƒé€’å‡çš„é˜Ÿåˆ— queMax ç»´æŠ¤æœ€å¤§å€¼
       while (queMax.length && queMax[queMax.length - 1] < nums[right]) {
         queMax.pop();
       }
       // ä½¿ç”¨ä¸€ä¸ªå•è°ƒé€’å¢çš„é˜Ÿåˆ— queMin ç»´æŠ¤æœ€å°å€¼
       while (queMin.length && queMin[queMin.length - 1] > nums[right]) {
         queMin.pop();
       }
       queMax.push(nums[right]);
       queMin.push(nums[right]);
       if (queMax.length && queMin.length && queMax[0] - queMin[0] > limit) {
         // å¦‚æœæ»‘åŠ¨çª—å£çš„å·¦è¾¹left++, å°±éœ€è¦æŠŠå¯¹åº”çš„ä¸¤ä¸ªé˜Ÿåˆ—ä¸­çš„å…ƒç´ åˆ é™¤
         if (nums[left] === queMin[0]) {
           queMin.shift();
         }
         if (nums[left] === queMax[0]) {
           queMax.shift();
         }
         left++;
       } else {
         res = right - left + 1;
       }
     }
     return res;
   };
   ```

   ä¸‹é¢è¿™ä¸ªæ–¹æ³•è¶…å‡ºæ—¶é—´é™åˆ¶

   ```js
   /**
    * @param {number[]} nums
    * @param {number} limit
    * @return {number}
    */
   var longestSubarray = function (nums, limit) {
     let left = 0,
       seq = [],
       res = 0;
     for (let right = 0; right < nums.length; right++) {
       let number = nums[right];
       seq.push(number);

       while (Math.max(...seq) - Math.min(...seq) > limit && left < right) {
         seq.shift();
         left++;
       }
       res = Math.max(res, right - left + 1);
     }
     return res;
   };
   ```

7. æœ€å°è¦†ç›–å­ä¸²

   ```js
   /**
    * @param {string} s
    * @param {string} t
    * @return {string}
    */
   var minWindow = function (s, t) {
     let res = Number.MAX_VALUE;
     // è®°å½•tå­—ç¬¦ä¸²éœ€è¦çš„å­—æ¯ä¸ªæ•°
     let need = {};
     // åªè®°å½•sä¸­æœ‰tçš„å­—ç¬¦ä¸²ä¸ªæ•°
     let window = {};
     // å·¦æŒ‡é’ˆ
     let left = 0;
     // æœ€å°è¦†ç›–å­ä¸²çš„èµ·å§‹ç´¢å¼•
     let start = 0;
     // è¡¨ç¤ºwindowä¸­å·²æœ‰çš„tçš„å­—æ¯ä¸ªæ•°
     let valid = 0;
     // ç»Ÿè®¡tä¸­çš„å­—ç¬¦
     for (let str of t) {
       need[str] = (need[str] || 0) + 1;
     }
     for (let right = 0; right < s.length; right++) {
       let str = s[right];
       // å¦‚æœå½“å‰å­—ç¬¦å­˜åœ¨äºtä¸­
       if (need[str]) {
         // æ›´æ–°çª—å£ç»Ÿè®¡
         window[str] = (window[str] || 0) + 1;
         // å½“å‰çª—å£å’Œéœ€è¦çš„å­—ç¬¦åŒ¹é…æ—¶ï¼ŒéªŒè¯æ•°é‡+1
         if (window[str] == need[str]) {
           valid++;
         }
       }
       // å½“éªŒè¯æ•°é‡å’Œéœ€è¦çš„å­—ç¬¦ä¸ªæ•°ç›¸åŒæ—¶,å¼€å§‹æ”¶ç¼©çª—å£
       while (valid == Object.keys(need).length) {
         // æ›´æ–°æœ€å°è¦†ç›–å­ä¸²
         if (right - left + 1 < res) {
           start = left;
           res = right - left + 1;
         }
         // å¤„ç†å·¦è¾¹å³å°†ç§»å‡ºçš„å­—ç¬¦
         let remove = s[left];
         left++;
         // ä¸»è¦éœ€è¦å¤„ç†ç§»å‡ºå­—ç¬¦ä¸²æ‰€å½±å“åˆ°çš„windowå’Œvalid
         if (need[remove]) {
           if (window[remove] == need[remove]) {
             valid--;
           }
           window[remove]--;
         }
       }
     }
     return res == Number.MAX_VALUE ? "" : s.substr(start, res);
   };
   ```

# æ·±åº¦ä¼˜å…ˆéå†å’Œå¹¿åº¦ä¼˜å…ˆéå†

1. ç½‘æ ¼ dfs æ¡†æ¶ä»£ç 

   ```js
   var dfs = function (grid, r, c) {
     // åˆ¤æ–­æ˜¯å¦è¶…å‡ºç½‘æ ¼èŒƒå›´
     if (!inArea(grid, r, c)) return;
     // å¦‚æœè¿™ä¸ªæ ¼å­ä¸æ˜¯å²›å±¿ï¼Œ ç›´æ¥è¿”å›
     if (grid[r][c] !== 1) return;
     // å°†æ ¼å­æ ‡è®°ä¸ºå·²éå†è¿‡
     grid[r][c] = 2;

     dfs(grid, r - 1, c);
     dfs(grid, r + 1, c);
     dfs(grid, r, c - 1);
     dfs(grid, r, c + 1);
   };

   var inArea = function (grid, r, c) {
     return 0 <= r && r < grid.length && 0 <= c && c < grid[0].length;
   };
   ```

2. å²›å±¿é—®é¢˜

   1. å²›å±¿æ•°é‡

      ```js
      /**
       * @param {character[][]} grid
       * @return {number}
       */
      var numIslands = function (grid) {
        var inArea = function (grid, r, c) {
          return 0 <= r && r < grid.length && 0 <= c && c < grid[0].length;
        };
        var getArea = function (grid, r, c) {
          if (!inArea(grid, r, c)) return;
          if (grid[r][c] !== "1") return;
          grid[r][c] = "2";

          getArea(grid, r - 1, c);
          getArea(grid, r + 1, c);
          getArea(grid, r, c - 1);
          getArea(grid, r, c + 1);
        };
        let res = 0;
        for (let r = 0; r < grid.length; r++) {
          for (let c = 0; c < grid[0].length; c++) {
            if (grid[r][c] === "1") {
              res++;
              getArea(grid, r, c);
            }
          }
        }
        return res;
      };
      ```

   2. å²›å±¿çš„å‘¨é•¿

      ```js
      /**
       * @param {number[][]} grid
       * @return {number}
       */
      var islandPerimeter = function (grid) {
        var getLen = function (grid, r, c) {
          // ä»ä¸€ä¸ªå²›å±¿æ–¹æ ¼èµ°å‘ç½‘æ ¼è¾¹ç•Œï¼Œå‘¨é•¿åŠ  1
          if (r >= 0 && r < grid.length && c >= 0 && c < grid[0].length) {
            return 1;
          }
          // ä»ä¸€ä¸ªå²›å±¿æ–¹æ ¼èµ°å‘æ°´åŸŸæ–¹æ ¼ï¼Œå‘¨é•¿åŠ  1
          if (grid[r][c] === 0) return 1;
          // å·²éå†è¿‡ï¼Œ ä¸é‡å¤éå†ï¼Œè¿”å›0
          if (grid[r][c] === 2) return 0;
          grid[r][c] = 2;
          return (
            getLen(grid, r - 1, c) +
            getLen(grid, r, c - 1) +
            getLen(grid, r, c + 1) +
            getLen(grid, r + 1, c)
          );
        };

        for (let r = 0; r < grid.length; r++) {
          for (let c = 0; c < grid[0].length; c++) {
            if (grid[r][c] === 1) {
              return getLen(grid, r, c);
            }
          }
        }
      };
      ```

   3. å²›å±¿çš„æœ€å¤§é¢ç§¯

      ```js
      /**
       * @param {number[][]} grid
       * @return {number}
       */
      var maxAreaOfIsland = function (grid) {
        var inArea = function (grid, r, c) {
          return 0 <= r && r < grid.length && c >= 0 && c < grid[0].length;
        };

        var getArea = function (grid, r, c) {
          if (!inArea(grid, r, c)) return 0;
          if (grid[r][c] !== 1) return 0;
          grid[r][c] = 2;
          return (
            1 +
            getArea(grid, r - 1, c) +
            getArea(grid, r, c - 1) +
            getArea(grid, r, c + 1) +
            getArea(grid, r + 1, c)
          );
        };

        let res = 0;
        for (let r = 0; r < grid.length; r++) {
          for (let c = 0; c < grid[0].length; c++) {
            if (grid[r][c] === 1) {
              let area = getArea(grid, r, c);
              res = Math.max(res, area);
            }
          }
        }
        return res;
      };
      ```

3. äºŒåˆ†å›¾

   å›¾è§£äºŒåˆ†å›¾ï¼šæ€è·¯é€šä¿—æ˜“æ‡‚ï¼Œæ³¨é‡Šè¯¦å°½
   https://leetcode-cn.com/problems/vEAB3K/solution/tu-jie-er-fen-tu-si-lu-tong-su-yi-dong-z-ayw1/

   ```js
   /**
    * @param {number[][]} graph
    * @return {boolean}
    */
   var isBipartite = function (graph) {
     // DFS éå†æ¡†æ¶
     const traverse = (graph, v) => {
       // å¦‚æœå·²ç»ç¡®å®šä¸æ˜¯äºŒåˆ†å›¾äº†ï¼Œå°±ä¸ç”¨æµªè´¹æ—¶é—´å†é€’å½’éå†äº†, ç›´æ¥returnåœæ­¢é€’å½’
       if (!flag) return;
       // è®°å½•å½“å‰èŠ‚ç‚¹vå·²ç»è®¿é—®è¿‡äº†
       visited[v] = true;
       // éå†å½“å‰èŠ‚ç‚¹æ‰€è¿æ¥çš„è¾¹çš„å¦ä¸€ä¸ªèŠ‚ç‚¹
       for (let w of graph[v]) {
         if (!visited[w]) {
           /**
            * ç›¸é‚»èŠ‚ç‚¹ w æ²¡æœ‰è¢«è®¿é—®è¿‡
            * é‚£ä¹ˆåº”è¯¥ç»™èŠ‚ç‚¹ w æ¶‚ä¸Šå’ŒèŠ‚ç‚¹ v ä¸åŒçš„é¢œè‰²
            */
           color[w] = !color[v];
           // ç»§ç»­éå† w
           traverse(graph, w);
         } else {
           // å¦‚æœèŠ‚ç‚¹wå·²ç»è®¿é—®è¿‡ï¼Œåˆ™åˆ¤æ–­vå’Œwæ˜¯å¦æ˜¯ä¸åŒé¢œè‰²
           // ç›¸åŒé¢œè‰²åˆ™ä¸æ˜¯äºŒåˆ†å›¾
           if (color[w] == color[v]) {
             flag = false;
           }
         }
       }
     };
     // è®°å½•å›¾æ˜¯å¦ç¬¦åˆäºŒåˆ†å›¾æ€§è´¨
     let flag = true;
     let n = graph.length;
     // è®°å½•å›¾ä¸­èŠ‚ç‚¹çš„é¢œè‰²ï¼Œfalse å’Œ true ä»£è¡¨ä¸¤ç§ä¸åŒé¢œè‰²,
     // å…ˆåˆå§‹åŒ–ä¸ºåŒä¸€ç§é¢œè‰²
     let color = new Array(n).fill(false);
     // è®°å½•å›¾ä¸­èŠ‚ç‚¹æ˜¯å¦è¢«è®¿é—®è¿‡
     let visited = new Array(n).fill(false);
     // å› ä¸ºå›¾ä¸ä¸€å®šæ˜¯è”é€šçš„ï¼Œå¯èƒ½å­˜åœ¨å¤šä¸ªå­å›¾
     // æ‰€ä»¥è¦æŠŠæ¯ä¸ªèŠ‚ç‚¹éƒ½ä½œä¸ºèµ·ç‚¹è¿›è¡Œä¸€æ¬¡éå†
     // å¦‚æœå‘ç°ä»»ä½•ä¸€ä¸ªå­å›¾ä¸æ˜¯äºŒåˆ†å›¾ï¼Œæ•´å¹…å›¾éƒ½ä¸ç®—äºŒåˆ†å›¾
     for (let i = 0; i < n; i++) {
       if (!visited[i]) {
         traverse(graph, i);
       }
     }
     return flag;
   };
   ```

4. è®¡ç®—é™¤æ³•

5. è¯¾ç¨‹é¡ºåº

6. çœä»½æ•°é‡

   ```js
   /**
    * @param {number[][]} isConnected
    * @return {number}
    */
   var findCircleNum = function (isConnected) {
     let len = isConnected.length;
     let visited = new Set();
     var dfs = function (i, visited) {
       for (let j = 0; j < len; j++) {
         if (isConnected[i][j] === 1 && !visited.has(j)) {
           visited.add(j);
           // æ·±åº¦ä¼˜å…ˆéå†
           dfs(j, visited);
         }
       }
     };
     let res = 0;
     for (let i = 0; i < len; i++) {
       if (!visited.has(i)) {
         // æ‰¾å‡ºæ‰€æœ‰ä¸ç¬¬iä¸ªåŸå¸‚ç›¸è¿çš„åŸå¸‚, åŠ å…¥åˆ°setä¸­
         dfs(i, visited);
         // ä¸‹é¢ä¸€è¡Œå¯åŠ å¯ä¸åŠ 
         visited.add(i);
         res++;
       }
     }
     return res;
   };
   ```

7. å¤šä½™çš„è¾¹ | å†—ä½™è¿æ¥

   ```js
   /**
    * @param {number[][]} edges
    * @return {number[]}
    */
   var findRedundantConnection = function (edges) {
     const len = edges.length;
     // parent[i] = i
     const parent = new Array(len + 1).fill().map((item, index) => index);

     for (let i = 0; i < len; i++) {
       const edge = edges[i];
       const node1 = edge[0],
         node2 = edge[1];
       // å¦‚æœèŠ‚ç‚¹på’Œqè¿é€šçš„è¯ï¼Œå®ƒä»¬ä¸€å®šæ‹¥æœ‰ç›¸åŒçš„æ ¹èŠ‚ç‚¹
       if (find(parent, node1) !== find(parent, node2)) {
         // ä¸¤ä¸ªä»£è¡¨èŠ‚ç‚¹ä¸ç›¸åŒï¼Œè¯´æ˜ä¹‹å‰ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´ä¸è¿é€šï¼Œåˆå¹¶
         union(parent, node1, node2);
       } else {
         // ä¸¤ä¸ªä»£è¡¨èŠ‚ç‚¹ç›¸åŒï¼Œè¯´æ˜åœ¨éå†å½“å‰è¾¹ä¹‹å‰ï¼Œä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´å·²ç»è¿é€šï¼Œå½“å‰è¾¹ä¼šå¯¼è‡´ç¯å‡ºç°
         return edge;
       }
     }
     return [0];
   };

   // èŠ‚ç‚¹åˆå¹¶
   var union = function (parent, i1, i2) {
     // æ‰¾åˆ°i1èŠ‚ç‚¹çš„ç¥–å…ˆèŠ‚ç‚¹
     let parent1 = find(parent, i1);
     // æ‰¾åˆ°i2èŠ‚ç‚¹çš„ç¥–å…ˆèŠ‚ç‚¹
     let parent2 = find(parent, i2);
     // i1ç¥–å…ˆèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ æŒ‡å‘ i2èŠ‚ç‚¹çš„ç¥–å…ˆèŠ‚ç‚¹
     parent[parent1] = parent2;
   };
   // æŸ¥è¯¢èŠ‚ç‚¹içš„æ ¹èŠ‚ç‚¹ï¼Œé€’å½’éå†
   var find = function (parent, i) {
     if (parent[i] != i) {
       parent[i] = find(parent, parent[i]);
     }
     return parent[i];
   };
   ```

8. çŸ©é˜µä¸­çš„è·¯å¾„

   ```js
   /**
    * @param {character[][]} board
    * @param {string} word
    * @return {boolean}
    */
   var exist = function (board, word) {
     const [m, n] = [board.length, board[0].length];

     const dfs = function (r, c, index) {
       // è¶Šç•Œã€æˆ–è€…å­—ç¬¦ä¸åŒ¹é…
       if (r < 0 || r >= m || c < 0 || c >= n || board[r][c] !== word[index])
         return false;
       // ç´¢å¼•ç­‰äºå•è¯é•¿åº¦-1ï¼Œè¯´æ˜å…¨åŒ¹é…ä¸Šäº†
       if (index === word.length - 1) return true;
       // ä¿å­˜å½“å‰å­—ç¬¦
       let temp = board[r][c];
       // å°†å½“å‰å­—ç¬¦è®¾ç½®ä¸ºç©ºï¼Œé˜²æ­¢å››ä¸ªæ–¹å‘dfså†æ¬¡éå†åˆ°
       board[r][c] = "";
       let res =
         dfs(r + 1, c, index + 1) ||
         dfs(r - 1, c, index + 1) ||
         dfs(r, c + 1, index + 1) ||
         dfs(r, c - 1, index + 1);
       // æ¢å¤å½“å‰å­—ç¬¦
       board[r][c] = temp;
       return res;
     };

     for (let i = 0; i < m; i++) {
       for (let j = 0; j < n; j++) {
         if (dfs(i, j, 0)) return true;
       }
     }
     return false;
   };
   s;
   ```

9. æœºå™¨äººçš„è¿åŠ¨èŒƒå›´

   ```js
   /**
    * @param {number} m
    * @param {number} n
    * @param {number} k
    * @return {number}
    */
   var movingCount = function (m, n, k) {
     // visited ç”¨æ¥è®°å½•èµ°è¿‡çš„æ ¼å­ï¼Œé¿å…é‡å¤
     const visited = Array(m)
       .fill(0)
       .map((item) => Array(n).fill(false));

     // è¾…åŠ©å‡½æ•°ï¼Œè®¡ç®—ä½æ•°å’Œ
     function sum(n) {
       let res = 0;
       while (n) {
         res += n % 10;
         n = Math.floor(n / 10);
       }
       return res;
     }
     // dfs
     let res = 0;
     function dfs(x, y) {
       // å¯¹åº”å¼€å¤´æ‰€è¯´çš„ä¸‰ä¸ªç»ˆæ­¢æ¡ä»¶ï¼Œè¶…è¿‡kå€¼ã€åˆ°è¾¾è¾¹ç•Œã€èµ°è¿‡çš„æ ¼å­
       if (x >= m || x < 0 || y >= n || y < 0 || visited[x][y]) return;

       // è®°å½•å½“å‰æ ¼å­å·²ç»èµ°è¿‡ï¼Œè¿”å›å½“å‰è®¡æ•° 1 + åç»­å…¶ä»–ä¸¤ä¸ªæ–¹å‘çš„æ€»å’Œ

       visited[x][y] = true;
       // è¯¥æ¡ä»¶ä¸èƒ½æ”¾åœ¨å‰é¢çš„ifåˆ¤æ–­ä¸­ï¼Œä¸ç„¶æ— æ³•å°†å·²èµ°è¿‡çš„ä½†æ˜¯sum>kçš„æƒ…å†µéå†ä¸ºtrue
       if (sum(x) + sum(y) <= k) {
         res++;
         dfs(x + 1, y);
         dfs(x - 1, y);
         dfs(x, y - 1);
         dfs(x, y + 1);
       }
     }
     dfs(0, 0);
     return res;
   };
   ```

# äºŒåˆ†æŸ¥æ‰¾

https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/

ä»åŸºæœ¬çš„äºŒåˆ†æ³•è¯´èµ·ï¼Œå¦‚ä½• AC æœç´¢æ—‹è½¬æ•°ç»„ç³»åˆ—
https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/js-by-m-estelle-jgqr/

1.  äºŒåˆ†æŸ¥æ‰¾

    ```js
    /**
     * @param {number[]} nums
     * @param {number} target
     * @return {number}
     */
    var search = function (nums, target) {
      let left = 0,
        right = nums.length - 1;
      // è¿™é‡Œæ˜¯<=
      while (left <= right) {
        let midIndex = Math.floor((right - left) / 2) + left;
        let mid = nums[midIndex];
        if (mid === target) {
          return midIndex;
        } else if (mid < target) {
          left = midIndex + 1;
        } else {
          right = midIndex - 1;
        }
      }
      return -1;
    };
    ```

2.  åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®

    ```js
    /**
     * @param {number[]} nums
     * @param {number} target
     * @return {number[]}
     */
    var searchRange = function (nums, target) {
      //äºŒåˆ†æŸ¥æ‰¾
      let find = (isLeft) => {
        let left = 0,
          right = nums.length - 1;

        while (left <= right) {
          let mid = Math.floor((left + right) / 2);

          if (target < nums[mid]) {
            right = mid - 1;
          } else if (target > nums[mid]) {
            left = mid + 1;
          } else {
            if (isLeft) {
              if (nums[mid] === nums[mid - 1]) {
                right = mid - 1;
              } else {
                return mid;
              }
            } else {
              if (nums[mid] === nums[mid + 1]) {
                left = mid + 1;
              } else {
                return mid;
              }
            }
          }
        }
        return -1;
      };
      let left = find(true),
        right = find(false);
      return [left, right];
    };
    ```

3.  å¯»æ‰¾å³°å€¼ |

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var findPeakElement = function (nums) {
      let left = 0,
        right = nums.length - 1;

      while (left < right) {
        let mid = Math.floor((left + right) / 2);
        if (nums[mid] < nums[mid + 1]) {
          left = mid + 1;
        } else {
          right = mid;
        }
      }
      return left;
    };
    ```

4.  äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾(ä¸­)

    ```js
    /**
     * @param {number[][]} matrix
     * @param {number} target
     * @return {boolean}
     */
    var findNumberIn2DArray = function (matrix, target) {
      // å­˜åœ¨ matrix = [] çš„æƒ…å†µ
      if (!matrix[0]) return 0;
      let left = 0,
        right = matrix[0].length - 1;

      while (left < matrix.length && right >= 0) {
        if (matrix[left][right] < target) {
          left++;
        } else if (matrix[left][right] > target) {
          right--;
        } else {
          return true;
        }
      }
      return false;
    };
    ```

5.  æ•°å­—åºåˆ—ä¸­æŸä¸€ä½çš„æ•°å­—
    https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/mian-shi-ti-44-shu-zi-xu-lie-zhong-mou-yi-wei-de-6/

    ```js
    /**
     * @param {number} n
     * @return {number}
     */
    var findNthDigit = function (n) {
      // è¡¨ç¤ºnæ‰€åœ¨çš„æ•°å­—ä½æ•°, æ•°å­—10çš„ä½æ•° ä¸º 2
      let digit = 1;
      // æ¯ digitdigit ä½æ•°çš„èµ·å§‹æ•°å­—ï¼ˆå³ï¼š1, 10, 100, \cdots1,10,100,â‹¯ï¼‰ï¼Œè®°ä¸º start
      let start = 1;
      // ä½æ•°çš„æ•°å­—æ•°é‡
      let count = 9;

      while (n > count) {
        n -= count;
        digit += 1;
        start *= 10;
        count = digit * start * 9;
      }
      // æ‰¾å‡ºæ‰€åœ¨çš„æ•°å­—
      let num = start + Math.floor((n - 1) / digit);
      // æ‰¾å‡ºæ‰€åœ¨æ•°å­—çš„ç¬¬å‡ ä½
      let index = (n - 1) % digit;
      return num.toString().charAt(index) - "0";
    };
    ```

6.  åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾æ•°å­—(éš¾)

    ```js
    /**
     * @param {number[]} nums
     * @param {number} target
     * @return {number}
     */
    var search = function (nums, target) {
      var helper = function (nums, target) {
        let left = 0,
          right = nums.length - 1;
        while (left <= right) {
          let mid = Math.floor((left + right) / 2);
          if (nums[mid] <= target) {
            left = mid + 1;
          } else {
            right = mid - 1;
          }
        }
        return left;
      };
      return helper(nums, target) - helper(nums, target - 1);
    };
    ```

7.  æŒ‰æƒé‡ç”Ÿæˆéšæœºæ•°

8.  æ’åºæ•°ç»„ä¸­ä¸¤ä¸ªæ•°å­—ä¹‹å’Œ
    https://leetcode-cn.com/problems/kLl5u1/solution/jian-dan-yi-dong-javac-pythonjs-liang-sh-et4y/

    ```js
    /**
     * @param {number[]} numbers
     * @param {number} target
     * @return {number[]}
     */
    var twoSum = function (numbers, target) {
      let left = 0,
        right = numbers.length - 1;

      while (left < right) {
        let sum = numbers[left] + numbers[right];
        if (sum < target) {
          left++;
        } else if (sum > target) {
          right--;
        } else {
          return [left, right];
        }
      }
      return [];
    };
    ```

9.  æŸ¥æ‰¾æ’å…¥ä½ç½®

    ```js
    /**
     * @param {number[]} nums
     * @param {number} target
     * @return {number}
     */
    var searchInsert = function (nums, target) {
      let left = 0,
        right = nums.length - 1;
      let mid;
      while (left <= right) {
        mid = Math.floor((left + right) / 2);
        if (nums[mid] < target) {
          left = mid + 1;
        } else if (nums[mid] > target) {
          right = mid - 1;
        } else {
          return mid;
        }
      }
      return left;
    };
    ```

    ```js
    /**
     * @param {number[]} nums
     * @param {number} target
     * @return {number}
     */
    var searchInsert = function (nums, target) {
      for (let i = 0; i < nums.length; i++) {
        if (target <= nums[i]) {
          return i;
        }
      }
      return nums.length;
    };
    ```

10. å±±å³°æ•°ç»„çš„é¡¶éƒ¨

    ```js
    /**
     * @param {number[]} arr
     * @return {number}
     */
    var peakIndexInMountainArray = function (arr) {
      let left = 1,
        right = arr.length - 2;
      while (left < right) {
        let mid = Math.floor((left + left) / 2);
        if (arr[mid - 1] < arr[mid] && arr[mid] > arr[mid + 1]) {
          return mid;
        } else if (arr[mid - 1] < arr[mid]) {
          left = mid + 1;
        } else {
          right = mid - 1;
        }
      }
      return left;
    };
    ```

11. æ’åºæ•°ç»„ä¸­åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var singleNonDuplicate = function (nums) {
      let res = 0;
      for (let num of nums) {
        res ^= num;
      }
      return res;
    };
    ```

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var singleNonDuplicate = function (nums) {
      let map = new Map();
      for (let num of nums) {
        map.set(num, (map.get(num) || 0) + 1);
      }
      for (let [key, value] of map) {
        if (value === 1) {
          return key;
        }
      }
    };
    ```

12. æ±‚å¹³æ–¹æ ¹

    ```js
    /**
     * @param {number} x
     * @return {number}
     */
    var mySqrt = function (x) {
      let left = 0,
        right = x;
      // æ³¨æ„ä¸èƒ½æœ‰ =
      while (left < right) {
        // å¿…é¡»æ˜¯ceil,ä¸èƒ½æ˜¯floor
        // å› ä¸ºå½“x=8æ—¶ï¼Œå­˜åœ¨left=2,right=3çš„æƒ…å†µä¸åœé‡å¤ï¼Œä¼šè¶…å‡ºæ—¶é—´é™åˆ¶
        let mid = Math.ceil((left + right) / 2);
        // æˆ–è€…
        // let mid = left + ((right-left) >> 1)
        if (mid * mid <= x) {
          left = mid;
        } else {
          right = mid - 1;
        }
      }
      return left;
    };
    ```

    ```js
    var mySqrt = function (x) {
      let left = 0;
      let right = x;
      while (left <= right) {
        let mid = left + ((right - left) >> 1); //ä¸­é—´ä½ç½®ç´¢å¼• x>>1 è¡¨ç¤ºé™¤ä»¥2å¹¶å–æ•´ï¼Œç¼©å°ä¸€ä¸‹éå†çš„èŒƒå›´
        if (mid * mid <= x) {
          left = mid + 1;
        } else {
          right = mid - 1;
        }
      }
      return right;
    };
    ```

13. ç‹’ç‹’åƒé¦™è•‰

    ```js
    /**
     * @param {number[]} piles
     * @param {number} h
     * @return {number}
     */
    var minEatingSpeed = function (piles, h) {
      let left = 1,
        right = Math.max(...piles) + 1;

      while (left < right) {
        let mid = Math.floor((left + right) / 2);
        if (canFinish(piles, mid, h)) {
          // å› ä¸ºæ˜¯å·¦é—­å³å¼€åŒºé—´  æ‰€ä»¥è¿™é‡Œright = mid
          // æœç´¢å·¦ä¾§è¾¹ç•Œï¼Œåˆ™éœ€è¦æ”¶ç¼©å³ä¾§è¾¹ç•Œ
          right = mid;
        } else {
          left = mid + 1;
        }
      }
      return left;
    };
    // åƒå®Œnæ ¹é¦™è•‰ä»¥speedçš„é€Ÿåº¦éœ€è¦å¤šå°‘å°æ—¶
    var getTime = function (num, speed) {
      return Math.floor(num / speed) + (num % speed > 0);
    };
    // pileså †é¦™è•‰ä»¥speedçš„é€Ÿåº¦èƒ½å¦åœ¨hå°æ—¶å†…åƒå®Œ
    var canFinish = function (piles, speed, h) {
      let time = 0;
      for (let pile of piles) {
        time += getTime(pile, speed);
      }
      return time <= h;
    };
    ```

14. æ—‹è½¬æ•°ç»„çš„æœ€å°æ•°å­—(å­˜åœ¨å…ƒç´ é‡å¤)

    ```js
    /**
     * @param {number[]} numbers
     * @return {number}
     */
    var findMin = function (nums) {
      let left = 0,
        right = nums.length - 1;
      while (left < right) {
        let mid = left + Math.floor((right - left) / 2);
        if (nums[mid] > nums[right]) {
          left = mid + 1;
        } else if (nums[mid] < nums[right]) {
          right = mid;
        } else {
          right--;
        }
      }
      return nums[left];
    };
    ```

15. å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼(ä¸ä¸Šä¸€é¢˜ç±»ä¼¼,ä½†æ˜¯å…ƒç´ å€¼äº’ä¸ç›¸åŒ)

    ä»åŸºæœ¬çš„äºŒåˆ†æ³•è¯´èµ·ï¼Œå¦‚ä½• AC æœç´¢æ—‹è½¬æ•°ç»„ç³»åˆ—
    https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/cong-ji-ben-de-er-fen-fa-shuo-qi-ru-he-a-hof5/

    ```js
    var findMin = function (nums) {
      let left = 0,
        right = nums.length - 1;
      while (left < right) {
        let mid = left + Math.floor((right - left) / 2);
        if (nums[mid] > nums[right]) {
          left = mid + 1;
        } else if (nums[mid] < nums[right]) {
          right = mid;
        }
      }
      return nums[left];
    };
    ```

16. æœç´¢æ—‹è½¬æ’åºæ•°ç»„(å…ƒç´ äº’ä¸ç›¸åŒ)

    ```js
    /**
     * @param {number[]} nums
     * @param {number} target
     * @return {number}
     */
    var search = function (nums, target) {
      if (!nums.length) return -1;
      let left = 0,
        right = nums.length - 1;
      while (left <= right) {
        let mid = left + ((right - left) >> 1);
        if (nums[mid] === target) {
          return mid;
        }
        // è¯´æ˜midå·¦ä¾§æ˜¯å‡åºæ•°ç»„
        // è¿™ä¸ª = ä¸€å®šè¦åŠ 
        if (nums[mid] >= nums[left]) {
          if (target >= nums[left] && target < nums[mid]) {
            right = mid - 1;
          } else {
            left = mid + 1;
          }
          // è¯´æ˜midå³ä¾§æ˜¯å‡åºæ•°ç»„
        } else {
          if (target > nums[mid] && target <= nums[right]) {
            left = mid + 1;
          } else {
            right = mid - 1;
          }
        }
      }
      return -1;
    };
    ```

17. æœç´¢æ—‹è½¬æ’åºæ•°ç»„ II
    https://leetcode-cn.com/problems/search-rotate-array-lcci/solution/xuan-zhuan-shu-zu-cong-yi-dao-nan-ge-ge-dcv7a/

    ```js
    /**
     * @param {number[]} nums
     * @param {number} target
     * @return {boolean}
     */
    var search = function (nums, target) {
      if (!nums.length) return -1;
      let left = 0,
        right = nums.length - 1;

      while (left <= right) {
        let mid = left + ((right - left) >> 1);
        if (nums[mid] === target) {
          return true;
        }
        // æ­¤æ—¶è¯´æ˜å…·æœ‰é‡å¤é¡¹ç›®ï¼Œåº”è¯¥è°ƒæ•´leftæŒ‡é’ˆï¼Œä½¿leftå‘å³ç§»åŠ¨ï¼Œç”¨ä»¥å»é™¤é‡å¤å¹²æ‰°
        if (nums[mid] === nums[left]) {
          left++;
          continue;
        }
        // å°†midä¸ç¬¬ä¸€ä¸ªæ•°å­—è¿›è¡Œæ¯”è¾ƒï¼Œmidå·¦ä¾§æ˜¯å‡åºæ•°ç»„
        if (nums[mid] > nums[left]) {
          if (target >= nums[left] && target < nums[mid]) {
            right = mid - 1;
          } else {
            left = mid + 1;
          }
          // midå³ä¾§æ˜¯å‡åºæ•°ç»„
        } else {
          if (target > nums[mid] && target <= nums[right]) {
            left = mid + 1;
          } else {
            right = mid - 1;
          }
        }
      }
      return false;
    };
    ```

18. æœç´¢æ—‹è½¬æ•°ç»„(å’Œä¸Šé¢ä¸€é¢˜ä¸€æ ·ï¼Œåªä¸è¿‡æ˜¯æ±‚ index)

    ```js
    /**
     * @param {number[]} arr
     * @param {number} target
     * @return {number}
     */
    var search = function (arr, target) {
      if (!arr.length) return -1;
      let left = 0,
        right = arr.length - 1;

      while (left <= right) {
        // å½“leftç¬¦åˆæ—¶ç›´æ¥è¿”å›ï¼Œå› ä¸ºæ˜¯æ‰¾æœ€å°çš„ç´¢å¼•
        if (arr[left] === target) return left;
        let mid = left + ((right - left) >> 1);
        // å½“ä¸­é—´å€¼ç­‰äºç›®æ ‡å€¼ï¼Œå°†å³è¾¹ç•Œç§»åˆ°ä¸­é—´ï¼Œå› ä¸ºå·¦è¾¹å¯èƒ½è¿˜æœ‰ç›¸ç­‰çš„å€¼
        if (arr[mid] === target) {
          right = mid;
        }
        // å°†midä¸ç¬¬ä¸€ä¸ªæ•°å­—è¿›è¡Œæ¯”è¾ƒï¼Œmidå·¦ä¾§æ˜¯å‡åºæ•°ç»„
        else if (arr[mid] > arr[left]) {
          if (target >= arr[left] && target < arr[mid]) {
            right = mid - 1;
          } else {
            left = mid + 1;
          }
          // midå³ä¾§æ˜¯å‡åºæ•°ç»„
        } else if (arr[mid] > arr[left]) {
          if (target > arr[mid] && target <= arr[right]) {
            left = mid + 1;
          } else {
            right = mid - 1;
          }
        } else {
          left += 1;
        }
      }
      return -1;
    };
    ```

# å‰ç¼€å’Œ

1. å’Œä¸º k çš„å­æ•°ç»„
   æ€è·¯: ä½¿ç”¨å‰ç¼€å’Œ
   https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484488&idx=1&sn=848f76e86fce722e70e265d0c6f84dc3&source=41#wechat_redirect

   ```js
   /**
    * @param {number[]} nums
    * @param {number} k
    * @return {number}
    */
   var subarraySum = function (nums, k) {
     let res = 0,
       sum = 0;
     let map = new Map();
     map.set(0, 1);

     for (let i = 0; i < nums.length; i++) {
       sum += nums[i];
       res += map.get(sum - k) || 0;
       map.set(sum, (map.get(sum) || 0) + 1);
     }
     return res;
   };
   ```

2. 0 å’Œ 1 ä¸ªæ•°ç›¸åŒçš„å­æ•°ç»„
   æ€è·¯: ä½¿ç”¨å‰ç¼€å’Œ

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var findMaxLength = function (nums) {
     const n = nums.length;
     const map = new Map();
     map.set(0, -1);
     // å‰ç¼€å’Œ
     let pre = 0;
     let res = 0;
     for (let i = 0; i < n; i++) {
       pre += nums[i] == 0 ? -1 : 1;
       // å¦‚æœå­˜åœ¨çš„è¯ï¼Œåˆ™å°†å½“å‰ç´¢å¼•å’Œä¹‹å‰å­˜å…¥çš„ç´¢å¼•å€¼ç›¸å‡  å–é¢˜ç›®è¦æ±‚çš„æœ€å¤§å€¼
       if (map.has(pre)) {
         res = Math.max(res, i - map.get(pre));
       } else {
         // è®°å½•å‰ç¼€å’Œç´¢å¼•
         map.set(pre, i);
       }
     }
     return res;
   };
   ```

3. æœ‰åºæ•°ç»„ä¸­å·®ç»å¯¹å€¼ä¹‹å’Œ

   ```js
   /**
    * @param {number[]} nums
    * @return {number[]}
    */
   var getSumAbsoluteDifferences = function (nums) {
     // åˆ©ç”¨å‰ç¼€å’Œ
     // nums[i]ä¸å…¶åæ‰€æœ‰å…ƒç´ çš„ç»å¯¹å€¼ä¹‹å’Œ === å…¶åæ‰€æœ‰å…ƒç´ æ€»å’Œå‡å»å…¶åå…ƒç´ ä¸ªæ•°ä¸nums[i]çš„ä¹˜ç§¯ï¼Œ
     // nums[i]å…¶å‰æ‰€æœ‰å…ƒç´ ç»å¯¹å€¼ä¹‹å’Œ === nums[i]*å…¶å‰å…ƒç´ ä¸ªæ•° - å…¶å‰å…ƒç´ æ€»å’Œ
     let res = [];
     let sum = nums.reduce((pre, cur) => pre + cur);
     let curSum = 0;
     for (let i = 0; i < nums.length; i++) {
       let leftSum = nums[i] * i - curSum;
       let rightSum = sum - curSum - nums[i] - (nums.length - i - 1) * nums[i];
       res.push(leftSum + rightSum);
       curSum += nums[i];
     }
     return res;
   };
   ```

4. è¿ç»­çš„å­æ•°ç»„å’Œ
   ```js
   /**
    * @param {number[]} nums
    * @param {number} k
    * @return {boolean}
    */
   var checkSubarraySum = function (nums, k) {
     if (nums.length < 2) return false;
     let map = new Map();
     map.set(0, -1);
     let sum = 0;
     for (let i = 0; i < nums.length; i++) {
       // å½“ a-b ä¸º k çš„å€æ•°æ—¶ï¼Œaå’Œb é™¤ä»¥ kçš„ä½™æ•°ç›¸åŒã€‚
       // å› æ­¤åªéœ€è¦è®¡ç®—æ¯ä¸ªä¸‹æ ‡å¯¹åº”çš„å‰ç¼€å’Œé™¤ä»¥ k çš„ä½™æ•°å³å¯ï¼Œä½¿ç”¨å“ˆå¸Œè¡¨å­˜å‚¨æ¯ä¸ªä½™æ•°ç¬¬ä¸€æ¬¡å‡ºç°çš„ä¸‹æ ‡ã€‚
       sum = (sum + nums[i]) % k;
       if (map.has(sum)) {
         let preIndex = map.get(sum);
         if (i - preIndex >= 2) {
           return true;
         }
       } else {
         // ä½¿ç”¨hashè¡¨å­˜å‚¨æ¯ä¸ªä½™æ•°ç¬¬ä¸€æ¬¡å‡ºç°çš„ä¸‹æ ‡
         map.set(sum, i);
       }
     }
     return false;
   };
   ```

# å›æ–‡

1. æœ€å¤šåˆ é™¤ä¸€ä¸ªå­—ç¬¦å¾—åˆ°å›æ–‡

   ```js
   /**
    * @param {string} s
    * @return {boolean}
    */
   var validPalindrome = function (s) {
     var isHW = function (str, left, right) {
       for (let i = left, j = right; i < j; i++, j--) {
         if (str[i] !== str[j]) {
           return false;
         }
       }
       return true;
     };

     for (let left = 0, right = s.length - 1; left < right; left++, right--) {
       if (s[left] !== s[right]) {
         return isHW(s, left + 1, right) || isHW(s, left, right - 1);
       }
     }
     return true;
   };
   ```

2. å›æ–‡å­ä¸² | å›æ–‡å­å­—ç¬¦ä¸²çš„ä¸ªæ•°

   æœ‰å¾ˆå¤šæ–¹æ³•

   ```js
   // åŒé‡forå¾ªç¯
   /**
    * @param {string} s
    * @return {number}
    */
   var countSubstrings = function (s) {
     let res = 0;
     var isHW = function (str, l, r) {
       for (let i = l, j = r; i <= j; i++, j--) {
         if (str[i] !== str[j]) return false;
       }
       return true;
     };
     for (let i = 0; i < s.length; i++) {
       for (let j = i; j < s.length; j++) {
         if (isHW(s, i, j)) {
           res++;
         }
       }
     }
     return res;
   };
   ```

   ```js
   // åŠ¨æ€è§„åˆ’
   const countSubstrings = function (s) {
     const len = s.length;
     const dp = new Array(len).fill(0).map(() => new Array(len).fill(false));
     let res = 0;
     // ä¸ºä»€ä¹ˆæ˜¯æ­£åº
     for (let i = 0; i < len; i++) {
       // dp[i][j] = dp[i - 1][j + 1] æ‰€ä»¥jæ˜¯å€’åº
       for (let j = i; j >= 0; j--) {
         if (s[i] === s[j]) {
           // åˆå§‹åŒ–
           if (i - j <= 1) {
             // åˆå§‹åŒ– a å’Œ aa çš„æƒ…å†µ
             dp[i][j] = true;
           } else {
             dp[i][j] = dp[i - 1][j + 1];
           }
         }
         res += dp[i][j] ? 1 : 0;
       }
     }
     return res;
   };
   ```

   ```js
   // åŒæŒ‡é’ˆæ³•, ä»¥æŸä¸ªå­—ç¬¦ä¸²ä¸ºä¸­å¿ƒå‘å¤–å»¶å±•
   /**
    * @param {string} s
    * @return {number}
    */
   var countSubstrings = function (s) {
     if (!s) return 0;

     var isHW = function (s, start, end) {
       let count = 0;
       while (
         start >= 0 &&
         end < s.length &&
         // ä¸‹é¢è¿™å¥ä¸€å®šè¦å†™åœ¨æ¡ä»¶é‡Œ, falseç›´æ¥break
         s.charAt(start) === s.charAt(end)
       ) {
         count++;
         start--;
         end++;
       }
       return count;
     };
     let res = 0;
     for (let i = 0; i < s.length; i++) {
       // é•¿åº¦ä¸ºå¥‡æ•°çš„å›æ–‡çš„å¯¹ç§°ä¸­å¿ƒåªæœ‰ä¸€ä¸ªå­—ç¬¦
       res += isHW(s, i, i);
       // é•¿åº¦ä¸ºå¶æ•°çš„å›æ–‡çš„å¯¹ç§°ä¸­å¿ƒåªæœ‰ä¸¤ä¸ªå­—ç¬¦
       res += isHW(s, i, i + 1);
     }
     return res;
   };
   ```

3. æœ€é•¿å›æ–‡å­ä¸²(ä¸­)

   ```javascript
   var longestPalindrome = function (s) {
     if (s.length < 2) return s;

     let res = "";
     for (let i = 0; i < s.length; i++) {
       helper(i, i);
       helper(i, i + 1);
     }

     function helper(m, n) {
       while (m >= 0 && n < s.length && s[n] === s[m]) {
         m--;
         n++;
       }

       if (n - m - 1 > res.length) {
         // è¿™é‡Œå¿…é¡»ç”¨sliceæˆ–è€…substring, éƒ½æ˜¯è¡¨ç¤ºä»å¼€å§‹ç´¢å¼•åˆ°ç»“æŸç´¢å¼•
         res = s.slice(m + 1, n);
       }
     }
     return res;
   };
   ```

4. æœ€é•¿å›æ–‡å­åºåˆ—(ä¸­)

   ```js
   const longestPalindromeSubseq = (s) => {
     const strLen = s.length;
     let dp = Array.from(Array(strLen), () => Array(strLen).fill(0));

     for (let i = 0; i < strLen; i++) {
       dp[i][i] = 1;
     }

     for (let i = strLen - 1; i >= 0; i--) {
       // ä¸ºä»€ä¹ˆä»i+1å¼€å§‹ï¼Œ å› ä¸ºå·²ç»è®¾è®¡dp[i][i]=1
       // å› ä¸ºæ˜¯ä»å†…å‘å¤–, å…ˆä»s[i]å’Œs[i+1]å¼€å§‹
       for (let j = i + 1; j < strLen; j++) {
         if (s[i] === s[j]) {
           // å›æ–‡å‡è®¾ä»é‡Œå‘å¤–æ‰©æ•£
           // ç”±ä¸‹é¢çš„é€’æ¨å…¬å¼å¾—å‡ºiæ˜¯å€’åºéå†ï¼Œjæ˜¯æ­£åºéå†
           dp[i][j] = dp[i + 1][j - 1] + 2;
         } else {
           dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
         }
       }
     }

     return dp[0][strLen - 1];
   };
   ```

5. åˆ†å‰²å›æ–‡å­å­—ç¬¦ä¸²(ä¸­) - å›æº¯

   ```js
   /**
    * @param {string} s
    * @return {string[][]}
    */
   var partition = function (s) {
     let res = [],
       len = s.length;
     // åˆ¤æ–­æ˜¯ä¸æ˜¯å›æ–‡
     var isHW = function (s, l, r) {
       for (let i = l, j = r; i < j; i++, j--) {
         if (s[i] !== s[j]) return false;
       }
       return true;
     };

     var getPath = function (path, i) {
       if (i >= len) {
         res.push([...path]);
         return;
       }
       for (let j = i; j < s.length; j++) {
         if (!isHW(s, i, j)) continue;
         // substrå‚æ•°ä¸ºå¼€å§‹ç´¢å¼•å’Œæˆªå–ä¸ªæ•°
         path.push(s.substr(i, j - i + 1));
         getPath(path, j + 1);
         path.pop();
       }
     };
     getPath([], 0);
     return res;
   };
   ```

6. å›æ–‡æ’åˆ—

   ```js
   /**
    * @param {string} s
    * @return {boolean}
    */
   var canPermutePalindrome = function (s) {
     let set = new Set();

     for (let item of s) {
       if (!set.has(item)) {
         set.add(item);
       } else {
         set.delete(item);
       }
     }
     return set.size === 1 || set.size === 0;
   };
   ```

# å›¾

1. æ‰¾åˆ°å°é•‡çš„æ³•å®˜

   ```js
   /**
    * @param {number} n
    * @param {number[][]} trust
    * @return {number}
    */
   var findJudge = function (n, trust) {
     // è®¾ç½®å…¥åº¦
     let inDegree = new Array(n + 1).fill(0);
     // è®¾ç½®å‡ºåº¦
     let outDegree = new Array(n + 1).fill(0);

     for (let edge of trust) {
       let node1 = edge[0];
       let node2 = edge[1];
       // å› ä¸ºæ˜¯node1æŒ‡å‘node2
       // æ‰€ä»¥node1çš„å‡ºåº¦+1, node2çš„å…¥åº¦+1
       outDegree[node1]++;
       inDegree[node2]++;
     }
     for (let i = 1; i <= n; i++) {
       // å°é•‡æ³•å®˜çš„å…¥åº¦åº”ä¸ºn-1, å…¥åº¦ä¸º0
       if (inDegree[i] === n - 1 && outDegree[i] === 0) {
         return i;
       }
     }
     return -1;
   };
   ```

2. å¯»æ‰¾å›¾ä¸­æ˜¯å¦å­˜åœ¨è·¯å¾„

   ```js
   // æ–¹æ³•ä¸€: æ·±åº¦ä¼˜å…ˆéå†
   /**
    * @param {number} n
    * @param {number[][]} edges
    * @param {number} source
    * @param {number} destination
    * @return {boolean}
    */
   var validPath = function (n, edges, source, destination) {
     // æ·±åº¦ä¼˜å…ˆéå†
     let graph = new Array(n).fill().map(() => []);
     // graphè¡¨ç¤ºindexè¡¨ç¤ºçš„èŠ‚ç‚¹ä¸å“ªäº›èŠ‚ç‚¹è¿æ¥
     for (let [a, b] of edges) {
       graph[a].push(b);
       graph[b].push(a);
     }
     let visited = new Set();
     var dfs = function (node) {
       // è®°å½•nodeå·²ç»è®¿é—®è¿‡
       visited.add(node);
       // å¦‚æœnode === detination,è¯´æ˜æœ‰ä¸€æ¡è·¯å¾„
       if (node === destination) return true;
       // éå†ä¸èŠ‚ç‚¹nodeç›¸è¿çš„å¯¹ç«‹èŠ‚ç‚¹
       for (let w of graph[node]) {
         // æ²¡æœ‰èŠ‚ç‚¹wæ²¡æœ‰è®¿é—®è¿‡ï¼Œç»§ç»­æ‰§è¡Œ
         // ç»§ç»­æ·±åº¦ä¼˜å…ˆéå†w
         if (!visited.has(w) && dfs(w)) {
           return true;
         }
       }
       // å¦åˆ™è¿”å›false
       return false;
     };
     return dfs(source);
   };
   ```

   ```js
   // æ–¹æ³•äºŒ:å¹¿åº¦ä¼˜å…ˆéå†
   /**
    * @param {number} n
    * @param {number[][]} edges
    * @param {number} source
    * @param {number} destination
    * @return {boolean}
    */
   var validPath = function (n, edges, source, destination) {
     const graph = [];
     for (let i = 0; i < n; i++) {
       graph.push([]);
     }
     // æˆ–è€…
     // const graph = new Array(n).fill().map(() => [])
     // ä¸‹é¢è¿™ç§æƒ…å†µä¼šå‡ºé”™ã€‹è™½ç„¶ä¸çŸ¥é“ä¸ºä»€ä¹ˆ
     // const graph = new Array(n).fill([])
     for (const [x, y] of edges) {
       graph[x].push(y);
       graph[y].push(x);
     }
     const q = [source];
     const set = new Set();
     while (q.length) {
       const len = q.length;
       for (let i = 0; i < len; i++) {
         const node = q.shift();
         if (node == destination) return true;
         // è¡¨ç¤ºè·¯å¾„èµ°è¿‡äº†ï¼Œä¸èƒ½ç»§ç»­èµ°
         if (set.has(node)) continue;
         set.add(node);
         for (const m of graph[node]) {
           q.push(m);
         }
       }
     }
     return false;
   };
   ```

   ```js
   // æ–¹æ³•ä¸‰: å¹¶æŸ¥é›†
   /**
    * @param {number} n
    * @param {number[][]} edges
    * @param {number} source
    * @param {number} destination
    * @return {boolean}
    */
   var validPath = function (n, edges, source, destination) {
     // åˆå§‹åŒ–
     let parent = new Array(n).fill().map((item, index) => index);

     for (let i = 0; i < edges.length; i++) {
       let node1 = edges[i][0];
       let node2 = edges[i][1];
       // å¦‚æœèŠ‚ç‚¹node1å’Œnode2è¿é€šçš„è¯ï¼Œå®ƒä»¬ä¸€å®šæ‹¥æœ‰ç›¸åŒçš„æ ¹èŠ‚ç‚¹
       // ä¸¤ä¸ªä»£è¡¨èŠ‚ç‚¹ä¸ç›¸åŒï¼Œè¯´æ˜ä¹‹å‰ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´ä¸è¿é€šï¼Œå°†å…¶åˆå¹¶
       if (find(parent, node1) !== find(parent, node2)) {
         union(parent, node1, node2);
       }
     }
     // å¦‚æœä¸¤ä¸ªæ ¹èŠ‚ç‚¹ç›¸åŒï¼Œè¯´æ˜ä¸¤ä¸ªé¡¶ç‚¹å·²ç»è¿é€š
     return find(parent, source) === find(parent, destination);
   };

   // æŸ¥è¯¢èŠ‚ç‚¹içš„æ ¹èŠ‚ç‚¹,åˆ©ç”¨é€’å½’
   var find = function (parent, i) {
     if (parent[i] !== i) {
       parent[i] = find(parent, parent[i]);
     }
     return parent[i];
   };
   // åˆå¹¶
   var union = function (parent, i1, i2) {
     let parent1 = find(parent, i1);
     let parent2 = find(parent, i2);
     parent[parent1] = parent2;
   };
   ```

3. å¤šä½™çš„è¾¹ | å†—ä½™è¿æ¥

   ```js
   /**
    * @param {number[][]} edges
    * @return {number[]}
    */
   var findRedundantConnection = function (edges) {
     const len = edges.length;
     // parent[i] = i
     const parent = new Array(len + 1).fill().map((item, index) => index);

     for (let i = 0; i < len; i++) {
       let node1 = edges[i][0];
       let node2 = edges[i][1];
       // å¦‚æœèŠ‚ç‚¹på’Œqè¿é€šçš„è¯ï¼Œå®ƒä»¬ä¸€å®šæ‹¥æœ‰ç›¸åŒçš„æ ¹èŠ‚ç‚¹
       if (find(parent, node1) !== find(parent, node2)) {
         // ä¸¤ä¸ªä»£è¡¨èŠ‚ç‚¹ä¸ç›¸åŒï¼Œè¯´æ˜ä¹‹å‰ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´ä¸è¿é€šï¼Œåˆå¹¶
         union(parent, node1, node2);
       } else {
         // ä¸¤ä¸ªä»£è¡¨èŠ‚ç‚¹ç›¸åŒï¼Œè¯´æ˜åœ¨éå†å½“å‰è¾¹ä¹‹å‰ï¼Œä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´å·²ç»è¿é€šï¼Œå½“å‰è¾¹ä¼šå¯¼è‡´ç¯å‡ºç°
         return edge;
       }
     }
     return [0];
   };

   // èŠ‚ç‚¹åˆå¹¶
   var union = function (parent, i1, i2) {
     // æ‰¾åˆ°i1èŠ‚ç‚¹çš„ç¥–å…ˆèŠ‚ç‚¹
     let parent1 = find(parent, i1);
     // æ‰¾åˆ°i2èŠ‚ç‚¹çš„ç¥–å…ˆèŠ‚ç‚¹
     let parent2 = find(parent, i2);
     // i1ç¥–å…ˆèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ æŒ‡å‘ i2èŠ‚ç‚¹çš„ç¥–å…ˆèŠ‚ç‚¹
     parent[parent1] = parent2;
   };
   // æŸ¥è¯¢èŠ‚ç‚¹içš„æ ¹èŠ‚ç‚¹ï¼Œé€’å½’éå†
   var find = function (parent, i) {
     if (parent[i] != i) {
       parent[i] = find(parent, parent[i]);
     }
     return parent[i];
   };
   ```

4. äºŒåˆ†å›¾

   å›¾è§£äºŒåˆ†å›¾ï¼šæ€è·¯é€šä¿—æ˜“æ‡‚ï¼Œæ³¨é‡Šè¯¦å°½
   https://leetcode-cn.com/problems/vEAB3K/solution/tu-jie-er-fen-tu-si-lu-tong-su-yi-dong-z-ayw1/

   ```js
   /**
    * @param {number[][]} graph
    * @return {boolean}
    */
   var isBipartite = function (graph) {
     // DFS éå†æ¡†æ¶
     const traverse = (graph, v) => {
       // å¦‚æœå·²ç»ç¡®å®šä¸æ˜¯äºŒåˆ†å›¾äº†ï¼Œå°±ä¸ç”¨æµªè´¹æ—¶é—´å†é€’å½’éå†äº†, ç›´æ¥returnåœæ­¢é€’å½’
       if (!flag) return;
       // è®°å½•å½“å‰èŠ‚ç‚¹vå·²ç»è®¿é—®è¿‡äº†
       visited[v] = true;
       // éå†å½“å‰èŠ‚ç‚¹æ‰€è¿æ¥çš„è¾¹çš„å¦ä¸€ä¸ªèŠ‚ç‚¹
       for (let w of graph[v]) {
         if (!visited[w]) {
           /**
            * ç›¸é‚»èŠ‚ç‚¹ w æ²¡æœ‰è¢«è®¿é—®è¿‡
            * é‚£ä¹ˆåº”è¯¥ç»™èŠ‚ç‚¹ w æ¶‚ä¸Šå’ŒèŠ‚ç‚¹ v ä¸åŒçš„é¢œè‰²
            */
           color[w] = !color[v];
           // ç»§ç»­éå† w
           traverse(graph, w);
         } else {
           // å¦‚æœèŠ‚ç‚¹wå·²ç»è®¿é—®è¿‡ï¼Œåˆ™åˆ¤æ–­vå’Œwæ˜¯å¦æ˜¯ä¸åŒé¢œè‰²
           // ç›¸åŒé¢œè‰²åˆ™ä¸æ˜¯äºŒåˆ†å›¾
           if (color[w] == color[v]) {
             flag = false;
           }
         }
       }
     };
     // è®°å½•å›¾æ˜¯å¦ç¬¦åˆäºŒåˆ†å›¾æ€§è´¨
     let flag = true;
     let n = graph.length;
     // è®°å½•å›¾ä¸­èŠ‚ç‚¹çš„é¢œè‰²ï¼Œfalse å’Œ true ä»£è¡¨ä¸¤ç§ä¸åŒé¢œè‰²,
     // å…ˆåˆå§‹åŒ–ä¸ºåŒä¸€ç§é¢œè‰²
     let color = new Array(n).fill(false);
     // è®°å½•å›¾ä¸­èŠ‚ç‚¹æ˜¯å¦è¢«è®¿é—®è¿‡
     let visited = new Array(n).fill(false);
     // å› ä¸ºå›¾ä¸ä¸€å®šæ˜¯è”é€šçš„ï¼Œå¯èƒ½å­˜åœ¨å¤šä¸ªå­å›¾
     // æ‰€ä»¥è¦æŠŠæ¯ä¸ªèŠ‚ç‚¹éƒ½ä½œä¸ºèµ·ç‚¹è¿›è¡Œä¸€æ¬¡éå†
     // å¦‚æœå‘ç°ä»»ä½•ä¸€ä¸ªå­å›¾ä¸æ˜¯äºŒåˆ†å›¾ï¼Œæ•´å¹…å›¾éƒ½ä¸ç®—äºŒåˆ†å›¾
     for (let i = 0; i < n; i++) {
       if (!visited[i]) {
         traverse(graph, i);
       }
     }
     return flag;
   };
   ```

5. æ‰¾å‡ºæ˜Ÿå‹å›¾çš„ä¸­å¿ƒèŠ‚ç‚¹

   ```js
   /**
    * @param {number[][]} edges
    * @return {number}
    */
   var findCenter = function (edges) {
     let n = edges.length + 1;
     let degrees = new Array(n + 1).fill(0);
     for (const edge of edges) {
       degrees[edge[0]]++;
       degrees[edge[1]]++;
     }
     for (let i = 1; i <= n; i++) {
       if (degrees[i] === n - 1) {
         return i;
       }
     }
   };
   ```

# å¹¶æŸ¥é›†

æœ€å®¹æ˜“ç†è§£çš„å¹¶æŸ¥é›†è¯¦è§£
https://leetcode-cn.com/problems/redundant-connection/solution/zui-rong-yi-li-jie-de-bing-cha-ji-xiang-abg0f/

é€šä¿—è®²è§£å¹¶æŸ¥é›†ï¼Œå¸®åŠ©å°ç™½å¿«é€Ÿç†è§£
https://leetcode-cn.com/problems/redundant-connection/solution/tong-su-jiang-jie-bing-cha-ji-bang-zhu-xiao-bai-ku/

è§†é¢‘
https://www.bilibili.com/video/BV1jv411a7LK?spm_id_from=333.337.search-card.all.click

1. å¯»æ‰¾å›¾ä¸­æ˜¯å¦å­˜åœ¨è·¯å¾„
   bfs å¹¿åº¦ä¼˜å…ˆéå†

   ```js
   // å¹¿åº¦ä¼˜å…ˆéå†
   /**
    * @param {number} n
    * @param {number[][]} edges
    * @param {number} source
    * @param {number} destination
    * @return {boolean}
    */
   var validPath = function (n, edges, source, destination) {
     const graph = [];
     for (let i = 0; i < n; i++) {
       graph.push([]);
     }
     // æˆ–è€…
     // const graph = new Array(n).fill().map(() => [])
     // ä¸‹é¢è¿™ç§æƒ…å†µä¼šå‡ºé”™ã€‹è™½ç„¶ä¸çŸ¥é“ä¸ºä»€ä¹ˆ
     // const graph = new Array(n).fill([])
     for (const [x, y] of edges) {
       graph[x].push(y);
       graph[y].push(x);
     }
     const q = [source];
     const set = new Set();
     while (q.length) {
       const len = q.length;
       for (let i = 0; i < len; i++) {
         const node = q.shift();
         if (node == destination) return true;
         // è¡¨ç¤ºè·¯å¾„èµ°è¿‡äº†ï¼Œä¸èƒ½ç»§ç»­èµ°
         if (set.has(node)) continue;
         set.add(node);
         for (const m of graph[node]) {
           q.push(m);
         }
       }
     }
     return false;
   };
   ```

   ```js
   /**
    * @param {number} n
    * @param {number[][]} edges
    * @param {number} start
    * @param {number} end
    * @return {boolean}
    */
   var validPath = function (n, edges, start, end) {
     if (start === end) return true;
     var parents = new Array(n);
     for (var i = 0; i < parents.length; i++) {
       parents[i] = i;
     }

     var find = function (x) {
       if (parents[x] === x) return x;
       return find(parents[x]);
     };

     for (var i = 0; i < edges.length; i++) {
       var u = find(edges[i][0]);
       var v = find(edges[i][1]);

       if (u != v) {
         parents[u] = v;
       }
     }
     return find(start) === find(end);
   };
   ```

   ```js
   // è‡ªå·±çš„å†™æ³•
   /**
    * @param {number} n
    * @param {number[][]} edges
    * @param {number} source
    * @param {number} destination
    * @return {boolean}
    */
   var validPath = function (n, edges, source, destination) {
     // åˆå§‹åŒ–
     let parent = new Array(n).fill().map((item, index) => index);

     for (let i = 0; i < edges.length; i++) {
       let node1 = edges[i][0];
       let node2 = edges[i][1];
       // å¦‚æœèŠ‚ç‚¹node1å’Œnode2è¿é€šçš„è¯ï¼Œå®ƒä»¬ä¸€å®šæ‹¥æœ‰ç›¸åŒçš„æ ¹èŠ‚ç‚¹
       // ä¸¤ä¸ªä»£è¡¨èŠ‚ç‚¹ä¸ç›¸åŒï¼Œè¯´æ˜ä¹‹å‰ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´ä¸è¿é€šï¼Œå°†å…¶åˆå¹¶
       if (find(parent, node1) !== find(parent, node2)) {
         union(parent, node1, node2);
       }
     }
     // å¦‚æœä¸¤ä¸ªæ ¹èŠ‚ç‚¹ç›¸åŒï¼Œè¯´æ˜ä¸¤ä¸ªé¡¶ç‚¹å·²ç»è¿é€š
     return find(parent, source) === find(parent, destination);
   };

   // æŸ¥è¯¢èŠ‚ç‚¹içš„æ ¹èŠ‚ç‚¹,åˆ©ç”¨é€’å½’
   var find = function (parent, i) {
     if (parent[i] !== i) {
       parent[i] = find(parent, parent[i]);
     }
     return parent[i];
   };
   // åˆå¹¶
   var union = function (parent, i1, i2) {
     let parent1 = find(parent, i1);
     let parent2 = find(parent, i2);
     parent[parent1] = parent2;
   };
   ```

2. å¤šä½™çš„è¾¹ | å†—ä½™è¿æ¥

   ```js
   /**
    * @param {number[][]} edges
    * @return {number[]}
    */
   var findRedundantConnection = function (edges) {
     const len = edges.length;
     // parent[i] = i
     const parent = new Array(len + 1).fill().map((item, index) => index);

     for (let i = 0; i < len; i++) {
       const edge = edges[i];
       const node1 = edge[0],
         node2 = edge[1];
       // å¦‚æœèŠ‚ç‚¹på’Œqè¿é€šçš„è¯ï¼Œå®ƒä»¬ä¸€å®šæ‹¥æœ‰ç›¸åŒçš„æ ¹èŠ‚ç‚¹
       if (find(parent, node1) !== find(parent, node2)) {
         // ä¸¤ä¸ªä»£è¡¨èŠ‚ç‚¹ä¸ç›¸åŒï¼Œè¯´æ˜ä¹‹å‰ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´ä¸è¿é€šï¼Œåˆå¹¶
         union(parent, node1, node2);
       } else {
         // ä¸¤ä¸ªä»£è¡¨èŠ‚ç‚¹ç›¸åŒï¼Œè¯´æ˜åœ¨éå†å½“å‰è¾¹ä¹‹å‰ï¼Œä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´å·²ç»è¿é€šï¼Œå½“å‰è¾¹ä¼šå¯¼è‡´ç¯å‡ºç°
         return edge;
       }
     }
     return [0];
   };

   // èŠ‚ç‚¹åˆå¹¶
   var union = function (parent, i1, i2) {
     // æ‰¾åˆ°i1èŠ‚ç‚¹çš„ç¥–å…ˆèŠ‚ç‚¹
     let parent1 = find(parent, i1);
     // æ‰¾åˆ°i2èŠ‚ç‚¹çš„ç¥–å…ˆèŠ‚ç‚¹
     let parent2 = find(parent, i2);
     // i1ç¥–å…ˆèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ æŒ‡å‘ i2èŠ‚ç‚¹çš„ç¥–å…ˆèŠ‚ç‚¹
     parent[parent1] = parent2;
   };
   // æŸ¥è¯¢èŠ‚ç‚¹içš„æ ¹èŠ‚ç‚¹ï¼Œé€’å½’éå†
   var find = function (parent, i) {
     if (parent[i] != i) {
       parent[i] = find(parent, parent[i]);
     }
     return parent[i];
   };
   ```

# å‰‘æŒ‡ offer

## ç®€å•

1. æ•°ç»„ä¸­é‡å¤çš„æ•°å­—

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var findRepeatNumber = function (nums) {
     let map = new Map();
     for (let i of nums) {
       if (map.has(i)) return i;
       map.set(i, 1);
     }
     return null;
   };
   ```

2. æ›¿æ¢ç©ºæ ¼, å³å®ç° replaceAll æ–¹æ³•

   ```js
   /**
    * @param {string} s
    * @return {string}
    */
   var replaceSpace = function (s) {
     return s.replaceAll(" ", "%20");
   };
   ```

   ```js
   /**
    * @param {string} s
    * @return {string}
    */
   var replaceSpace = function (s) {
     s = s.split("");
     let len = s.length;
     let count = 0;
     for (let i = 0; i < s.length; i++) {
       if (s[i] === " ") count++;
     }
     let left = len - 1,
       right = len + count * 2 - 1;
     for (let i = left, j = right; i >= 0, j >= 0; i--, j--) {
       if (s[i] === " ") {
         s[j - 2] = "%";
         s[j - 1] = "2";
         s[j] = "0";
         // ä¸è¦å¿˜è®°
         j -= 2;
       } else {
         s[j] = s[i];
       }
     }
     return s.join("");
   };
   ```

3. ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—

4. æ—‹è½¬æ•°ç»„çš„æœ€å°æ•°å­—-äºŒåˆ†æŸ¥æ‰¾(éœ€è¦å’Œå³ç«¯ç‚¹è¿›è¡Œæ¯”è¾ƒ)(éš¾)

   ```js
   /**
    * @param {number[]} numbers
    * @return {number}
    */
   var minArray = function (numbers) {
     let left = 0,
       right = numbers.length - 1;
     while (left < right) {
       let mid = left + Math.floor((right - left) / 2);
       // å¯ä»¥çœç•¥å·¦åŠåŒºé—´
       if (numbers[mid] > numbers[right]) {
         left = mid + 1;
         // å¯ä»¥çœç•¥å³åŠåŒºé—´
       } else if (numbers[mid] < numbers[right]) {
         right = mid;
       } else {
         right--;
       }
     }
     return numbers[left];
   };
   ```

5. äºŒè¿›åˆ¶ä¸­ 1 çš„ä¸ªæ•°

   ```js
   /**
    * @param {number} n - a positive integer
    * @return {number}
    */
   var hammingWeight = function (n) {
     let sum = 0;
     for (let i = 0; i < 32; i++) {
       sum += (n >> i) & 1;
     }
     return sum;
   };
   ```

6. æ‰“å°ä» 1 åˆ°æœ€å¤§çš„ n ä½æ•°-è€ƒè™‘å¤§æ•°(1. å›æº¯ 2. ä½è¿ç®—)(éš¾)
   https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution/4chong-jie-fa-bao-li-zi-fu-chuan-wei-yun-v2dr/

   ```js
   /**
    * @param {number} n
    * @return {number[]}
    */
   var printNumbers = function (n) {
     let res = [];
     var dfs = function (index, str) {
       if (index === n) {
         res.push(+str);
         return;
       }
       for (let i = 0; i <= 9; i++) {
         str += i.toString();
         dfs(index + 1, str);
         str = str.slice(0, str.length - 1);
       }
     };
     dfs(0, "");
     res.shift();
     return res;
   };
   ```

7. è°ƒæ•´æ•°ç»„é¡ºåºä½¿å¥‡æ•°ä½äºå¶æ•°å‰é¢

8. é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ | èºæ—‹çŸ©é˜µ(éš¾)

   https://leetcode-cn.com/problems/spiral-matrix/solution/shou-hui-tu-jie-liang-chong-bian-li-de-ce-lue-kan-/

   ```js
   /**
    * @param {number[][]} matrix
    * @return {number[]}
    */
   var spiralOrder = function (matrix) {
     let res = [];
     if (!matrix.length) return res;
     let left = 0,
       right = matrix[0].length - 1,
       top = 0,
       bottom = matrix.length - 1;

     while (left < right && top < bottom) {
       // éµå¾ªä¸Šå³ä¸‹å·¦çš„é¡ºåº
       for (let i = left; i < right; i++) res.push(matrix[top][i]);
       for (let i = top; i < bottom; i++) res.push(matrix[i][right]);
       for (let i = right; i > left; i--) res.push(matrix[bottom][i]);
       for (let i = bottom; i > top; i--) res.push(matrix[i][left]);
       // å››ä¸ªè¾¹ç•ŒåŒæ—¶æ”¶ç¼©ï¼Œè¿›å…¥å†…å±‚
       left++;
       right--;
       top++;
       bottom--;
     }
     // å‰©ä¸‹ä¸€åˆ—ï¼Œ ä»ä¸Šåˆ°ä¸‹ä¾æ¬¡æ·»åŠ 
     if (left == right) {
       for (let i = top; i <= bottom; i++) {
         res.push(matrix[i][left]);
       }
     }
     // å‰©ä¸‹ä¸€è¡Œï¼Œä»å·¦åˆ°å³ä¾æ¬¡æ·»åŠ 
     else if (top == bottom) {
       for (let i = left; i <= right; i++) {
         res.push(matrix[top][i]);
       }
     }
     return res;
   };
   ```

9. æ•°ç»„ä¸­å‡ºç°æ¬¡æ•°è¶…è¿‡ä¸€åŠçš„æ•°å­— | å¤šæ•°å…ƒç´ -æ‘©å°”æŠ•ç¥¨(æŠµæ¶ˆæ³•)

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var majorityElement = function (nums) {
     let res = 0,
       count = 0;
     for (let i = 0; i < nums.length; i++) {
       if (!count) {
         res = nums[i];
         count++;
       } else {
         count += nums[i] === res ? 1 : -1;
       }
     }
     return res;
   };
   ```

10. æœ€å°çš„ k ä¸ªæ•°(æ•²é‡ç‚¹ï¼Œ åˆ©ç”¨å¿«æ’) - è§ æ•°ç»„ä¸­çš„ç¬¬ k å¤§çš„æ•°å­—(éš¾)

    ```js
    /**
     * @param {number[]} arr
     * @param {number} k
     * @return {number[]}
     */
    var getLeastNumbers = function (arr, k) {
      let res = arr.sort((a, b) => a - b);
      return res.slice(0, k);
    };
    ```

    ```js
    /**
     * @param {number[]} arr
     * @param {number} k
     * @return {number[]}
     */
    var getLeastNumbers = function (arr, k) {
      if (k >= arr.length) return arr;
      let left = 0,
        right = arr.length - 1;
      let pivotIndex = partition(arr, left, right);
      while (pivotIndex !== k) {
        if (pivotIndex < k) {
          left = pivotIndex + 1;
        } else if (pivotIndex > k) {
          right = pivotIndex - 1;
        }
        pivotIndex = partition(arr, left, right);
      }
      return arr.slice(0, k);
    };

    var partition = function (arr, left, right) {
      let pivot = arr[right];
      let pivotIndex = left;
      for (let i = left; i < right; i++) {
        if (arr[i] < pivot) {
          [arr[i], arr[pivotIndex]] = [arr[pivotIndex], arr[i]];
          pivotIndex++;
        }
      }
      [arr[pivotIndex], arr[right]] = [arr[right], arr[pivotIndex]];
      return pivotIndex;
    };
    ```

    ```js
    /**
     * @param {number[]} arr
     * @param {number} k
     * @return {number[]}
     */
    var getLeastNumbers = function (arr, k) {
      if (k >= arr.length) return arr;
      let left = 0,
        right = arr.length - 1;
      let index = partition(arr, left, right);
      while (index !== k) {
        // å¦‚æœindex < kï¼Œå‰ k ä¸ªå…ƒç´ åœ¨[index + 1, right] ä¹‹é—´ï¼Œç¼©å°æŸ¥æ‰¾èŒƒå›´ï¼Œç»§ç»­æŸ¥æ‰¾
        if (index < k) {
          left = index + 1;
          index = partition(arr, left, right);
        }
        // å¦‚æœk < indexï¼Œå‰ k ä¸ªå…ƒç´ åœ¨[left, index - 1]ä¹‹é—´ï¼Œç¼©å°æŸ¥æ‰¾èŒƒå›´ï¼Œç»§ç»­æŸ¥æ‰¾
        else if (index > k) {
          right = index - 1;
          index = partition(arr, left, right);
        }
      }
      return arr.slice(0, k);
    };
    // å¿«æ’çš„Partitionæ“ä½œï¼Œ å°çš„æ”¾åœ¨å·¦è¾¹ï¼Œå¤§çš„æ”¾åœ¨å³è¾¹
    var partition = function (arr, start, end) {
      let pivot = arr[start];
      let left = start + 1,
        right = end;
      while (true) {
        while (left <= end && arr[left] <= pivot) left++;
        while (right >= start + 1 && arr[right] > pivot) right--;

        if (left >= right) {
          break;
        }
        [arr[left], arr[right]] = [arr[right], arr[left]];
        left++;
        right--;
      }
      [arr[start], arr[right]] = [arr[right], arr[start]];
      return right;
    };
    ```

11. è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œ

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var maxSubArray = function (nums) {
      let dp = new Array(nums.length).fill(0);
      // ç»“æœæ³¨æ„ä¸æ˜¯0
      let res = nums[0];
      dp[0] = nums[0];
      for (let i = 1; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);

        if (res < dp[i]) {
          res = dp[i];
        }
      }
      return res;
    };
    ```

12. ç¬¬ä¸€ä¸ªåªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦

    ```js
    // ç”¨å“ˆå¸Œè¡¨
    /**
     * @param {string} s
     * @return {character}
     */
    var firstUniqChar = function (s) {
      let map = new Map();
      for (let i = 0; i < s.length; i++) {
        map.set(s[i], (map.get(s[i]) || 0) + 1);
      }
      for (let [key, value] of map) {
        if (value === 1) {
          return key;
        }
      }
      return " ";
    };
    ```

    ```js
    /**
     * @param {string} s
     * @return {character}
     */
    var firstUniqChar = function (s) {
      for (let x of s) {
        if (s.indexOf(x) === s.lastIndexOf(x)) return x;
      }
      return " ";
    };
    ```

13. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾æ•°å­—(äºŒåˆ†æŸ¥æ‰¾)(éš¾)

    ```js
    /**
     * @param {number[]} nums
     * @param {number} target
     * @return {number}
     */
    var search = function (nums, target) {
      var helper = function (nums, target) {
        let left = 0,
          right = nums.length - 1;
        while (left <= right) {
          let mid = Math.floor((left + right) / 2);
          if (nums[mid] <= target) {
            left = mid + 1;
          } else {
            right = mid - 1;
          }
        }
        return left;
      };
      return helper(nums, target) - helper(nums, target - 1);
    };
    ```

14. 0-n-1 ä¸­ç¼ºå¤±çš„æ•°å­—(éš¾)

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var missingNumber = function (nums) {
      for (let i = 0; i < nums.length + 1; i++) {
        if (i !== nums[i]) {
          return i;
        }
      }
    };
    ```

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var missingNumber = function (nums) {
      let left = 0,
        right = nums.length - 1;
      while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        nums[mid] === mid ? (left = mid + 1) : (right = mid - 1);
      }
      return left;
    };
    ```

15. å’Œä¸º s çš„è¿ç»­æ­£æ•°åºåˆ—(éš¾)(å›æº¯ + æ»‘åŠ¨çª—å£?)

    ```js
    /**
     * @param {number} target
     * @return {number[][]}
     */
    var findContinuousSequence = function (target) {
      sum = 0;
      let res = [],
        path = [];
      for (let right = 1; right <= target; right++) {
        while (sum > target) {
          sum -= path.shift();
        }
        if (sum === target) {
          res.push([...path]);
        }
        sum += right;
        path.push(right);
      }
      return res;
    };
    ```

16. ç¿»è½¬å•è¯é¡ºåº

    ```js
    /**
     * @param {string} s
     * @return {string}
     */
    var reverseWords = function (s) {
      return s.trim().split(/\s+/).reverse().join(" ");
    };
    ```

17. å·¦æ—‹è½¬å­—ç¬¦ä¸²

    ```js
    /**
     * @param {string} s
     * @param {number} n
     * @return {string}
     */
    var reverseLeftWords = function (s, n) {
      return s.slice(n, s.length).concat(s.slice(0, n));
    };
    ```

18. æ‰‘å…‹ç‰Œä¸­çš„é¡ºå­

19. åœ†åœˆä¸­æœ€åå‰©ä¸‹çš„æ•°å­—

20. ä¸ç”¨åŠ å‡ä¹˜é™¤åšåŠ æ³•
    https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/qiao-yong-wei-yun-suan-you-ya-shi-xian-b-wzq7/
    ```js
    /**
     * @param {number} a
     * @param {number} b
     * @return {number}
     */
    var add = function (a, b) {
      while (b) {
        // å¯¹ äºŒè¿›åˆ¶ä¸­ 1+1æ»¡2å‘å‰è¿›1ï¼Œ æ‰€ä»¥<<1
        let carry = (a & b) << 1;
        // å¯¹ä¸æ»¡çš„è¿›åˆ¶ç›´æ¥ç›¸åŠ 
        a = a ^ b;
        b = carry;
      }
      return a;
    };
    ```

## ä¸­ç­‰

1. æ•°å­—åºåˆ—ä¸­æŸä¸€ä½çš„æ•°å­—(éš¾)
   https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/mian-shi-ti-44-shu-zi-xu-lie-zhong-mou-yi-wei-de-6/

   ```js
   /**
    * @param {number} n
    * @return {number}
    */
   var findNthDigit = function (n) {
     // è¡¨ç¤ºnæ‰€åœ¨çš„æ•°å­—ä½æ•°, æ•°å­—10çš„ä½æ•° ä¸º 2
     let digit = 1;
     // æ¯ digitdigit ä½æ•°çš„èµ·å§‹æ•°å­—ï¼ˆå³ï¼š1, 10, 100, \cdots1,10,100,â‹¯ï¼‰ï¼Œè®°ä¸º start
     let start = 1;
     // ä½æ•°çš„æ•°å­—æ•°é‡
     let count = 9;

     while (n > count) {
       n -= count;
       digit += 1;
       start *= 10;
       count = digit * start * 9;
     }
     // æ‰¾å‡ºæ‰€åœ¨çš„æ•°å­—
     let num = start + Math.floor((n - 1) / digit);
     // æ‰¾å‡ºæ‰€åœ¨æ•°å­—çš„ç¬¬å‡ ä½
     let index = (n - 1) % digit;
     return num.toString().charAt(index) - "0";
   };
   ```

2. å‰ªç»³å­

3. å‰ªç»³å­ II
   https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/tan-xin-javascript-by-lzxjack-6f7w/

   ```js
   /**
    * @param {number} n
    * @return {number}
    */
   var cuttingRope = function (n) {
     // ç‰¹æ®Šæƒ…å†µå¤„ç†
     const arr = [null, null, 1, 2, 4];
     if (n <= 4) return arr[n];
     const mod = 1000000007;
     let res = 1;
     while (n > 4) {
       // æ¯æ¬¡å‡æ‰3
       res = (res * 3) % mod;
       n -= 3;
     }
     // æœ€åå‰©ä¸‹ä¸€æ®µå°äºç­‰äº4çš„é•¿åº¦
     res *= n;
     return res % mod;
   };
   ```

4. æŠŠæ•°ç»„æ’æˆæœ€å°çš„æ•°

   ```js
   /**
    * @param {number[]} nums
    * @return {string}
    */
   var minNumber = function (nums) {
     return nums.sort((a, b) => "" + a + b - ("" + b + a)).join("");
   };
   ```

5. æŠŠæ•°å­—ç¿»è¯‘æˆå­—ç¬¦ä¸²

   ```js
   /**
    * @param {number} num
    * @return {number}
    */
   var translateNum = function (num) {
     const str = num.toString();
     const len = str.length;
     let dp = new Array(len + 1);
     (dp[0] = 1), (dp[1] = 1);

     for (let i = 2; i <= len; i++) {
       let temp = Number(str[i - 2] + str[i - 1]);
       if (temp > 9 && temp < 26) {
         dp[i] = dp[i - 1] + dp[i - 2];
       } else {
         dp[i] = dp[i - 1];
       }
     }
     return dp[len];
   };
   ```

6. ç¤¼ç‰©çš„æœ€å¤§ä»·å€¼

   ```js
   /**
    * @param {number[][]} grid
    * @return {number}
    */
   var maxValue = function (grid) {
     let [m, n] = [grid.length, grid[0].length];

     let dp = new Array(m).fill().map((item) => Array(n).fill(0));
     dp[0][0] = grid[0][0];

     for (let i = 1; i < m; i++) {
       dp[i][0] = dp[i - 1][0] + grid[i][0];
     }
     for (let i = 1; i < n; i++) {
       dp[0][i] = dp[0][i - 1] + grid[0][i];
     }
     for (let i = 1; i < m; i++) {
       for (let j = 1; j < n; j++) {
         dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
       }
     }
     return dp[m - 1][n - 1];
   };
   ```

7. ä¸‘æ•°
   https://leetcode-cn.com/problems/chou-shu-lcof/solution/js-jian-zhi-offer-49-chou-shu-by-adela20-4q7p/

   ```js
   /**
    * @param {number} n
    * @return {number}
    */
   var nthUglyNumber = function (n) {
     const dp = [1];
     let p2 = 0,
       p3 = 0,
       p5 = 0;
     for (let i = 1; i < n; i++) {
       let n2 = dp[p2] * 2,
         n3 = dp[p3] * 3,
         n5 = dp[p5] * 5;
       dp[i] = Math.min(n2, n3, n5);
       dp[i] == n2 && p2++;
       dp[i] == n3 && p3++;
       dp[i] == n5 && p5++;
     }
     return dp[n - 1];
   };
   ```

# å‰‘æŒ‡ offer II

## ç®€å•

1. æ•´æ•°é™¤æ³•

   ```js
   /**
    * @param {number} a
    * @param {number} b
    * @return {number}
    */
   var divide = function (a, b) {
     const MAX = Math.pow(2, 31) - 1,
       MIN = -Math.pow(2, 31);
     if (a === MIN && b == 1) return MIN;
     // é™¤æ³•æº¢å‡ºï¼Œ è¿”å›2çš„31-1
     if (a === MIN && b == -1) return MAX;

     const sign = (a > 0) ^ (b > 0);
     (a = Math.abs(a)), (b = Math.abs(b));
     let res = 0;
     while (a >= b) {
       res++;
       a -= b;
     }
     return sign > 0 ? -res : res;
   };
   ```

- æ»¡å‡ carry

2. å¤§æ•°ç›¸åŠ 

   ```js
   function add(a, b) {
     //å–ä¸¤ä¸ªæ•°å­—çš„æœ€å¤§é•¿åº¦
     let maxLength = Math.max(a.length, b.length);
     //ç”¨0å»è¡¥é½é•¿åº¦
     a = a.padStart(maxLength, 0); //"0009007199254740991"
     b = b.padStart(maxLength, 0); //"1234567899999999999"
     //å®šä¹‰åŠ æ³•è¿‡ç¨‹ä¸­éœ€è¦ç”¨åˆ°çš„å˜é‡
     let t = 0;
     let f = 0; //"è¿›ä½"
     let sum = "";
     for (let i = maxLength - 1; i >= 0; i--) {
       t = parseInt(a[i]) + parseInt(b[i]) + f;
       f = Math.floor(t / 10);
       sum = (t % 10) + sum;
     }
     if (f !== 0) {
       sum = "" + f + sum;
     }
     return sum;
   }
   ```

3. åŠ ä¸€

   ```js
   /**
    * @param {number[]} digits
    * @return {number[]}
    */
   var plusOne = function (digits) {
     for (let i = digits.length - 1; i >= 0; i--) {
       digits[i]++;
       digits[i] = digits[i] % 10;
       if (digits[i]) return digits;
     }
     digits.unshift(1);
     return digits;
   };
   ```

4. æ•°ç»„å½¢å¼çš„æ•´æ•°åŠ æ³•

   ```js
   /**
    * @param {number[]} num
    * @param {number} k
    * @return {number[]}
    */
   var addToArrayForm = function (num, k) {
     let res = [];
     let len1 = num.length - 1,
       carry = 0;
     while (len1 >= 0 || k !== 0) {
       const x = len1 >= 0 ? num[len1] : 0;
       const y = k !== 0 ? k % 10 : 0;

       let sum = x + y + carry;
       res.push(sum % 10);
       carry = Math.floor(sum / 10);

       len1--;
       k = Math.floor(k / 10);
     }
     if (carry) {
       res.push(carry);
     }
     return res.reverse();
   };
   ```

5. å­—ç¬¦ä¸²ç›¸åŠ 

   ```js
   /**
    * @param {string} num1
    * @param {string} num2
    * @return {string}
    */
   var addStrings = function (num1, num2) {
     let i = num1.length - 1,
       j = num2.length - 1;
     let res = "",
       carry = 0;
     while (i >= 0 || j >= 0) {
       const x = i >= 0 ? num1[i] - 0 : 0;
       const y = j >= 0 ? num2[j] - 0 : 0;

       const sum = x + y + carry;
       res += sum % 10;
       carry = Math.floor(sum / 10);

       i--;
       j--;
     }
     if (carry) res += carry;
     return res.split("").reverse().join("");
   };
   ```

6. äºŒè¿›åˆ¶æ±‚å’Œ

   ```js
   /**
    * @param {string} a
    * @param {string} b
    * @return {string}
    */
   var addBinary = function (a, b) {
     let res = "";
     let i = a.length - 1,
       j = b.length - 1;
     let carry = 0;
     // æ³¨æ„ç»†èŠ‚ï¼Œæ˜¯>=0
     while (i >= 0 || j >= 0) {
       // æ³¨æ„ç»†èŠ‚ï¼Œæ˜¯>=0
       const x = i >= 0 ? a[i] - "0" : 0;
       const y = j >= 0 ? b[j] - "0" : 0;

       let sum = x + y + carry;
       res += sum % 2;
       carry = Math.floor(sum / 2);

       i--;
       j--;
     }
     if (carry) res += carry;
     return res.split("").reverse().join("");
   };
   ```

7. å‰ n ä¸ªæ•°å­—äºŒè¿›åˆ¶ä¸­ 1 çš„ä¸ªæ•°-ä½è¿ç®—

   ```js
   /**
    * @param {number} n
    * @return {number[]}
    */
   var countBits = function (n) {
     let res = [];
     for (let i = 0; i <= n; i++) {
       let sum = 0;
       for (let j = 0; j < 32; j++) {
         sum += (i >> j) & 1;
       }
       res.push(sum);
     }
     return res;
   };
   ```

8. ä¸¤æ•°ç›¸åŠ 

   ```js
   /**
    * Definition for singly-linked list.
    * function ListNode(val, next) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.next = (next===undefined ? null : next)
    * }
    */
   /**
    * @param {ListNode} l1
    * @param {ListNode} l2
    * @return {ListNode}
    */
   var addTwoNumbers = function (l1, l2) {
     let dummy = new ListNode();
     let cur = dummy;
     let carry = 0;
     while (l1 || l2) {
       const x = l1 ? l1.val : 0;
       const y = l2 ? l2.val : 0;

       let sum = x + y + carry;
       cur.next = new ListNode(sum % 10);
       cur = cur.next;
       carry = Math.floor(sum / 10);

       if (l1) l1 = l1.next;
       if (l2) l2 = l2.next;
     }
     if (carry) cur.next = new ListNode(carry);
     return dummy.next;
   };
   ```

- äºŒåˆ†æŸ¥æ‰¾

9. æ’åºæ•°ç»„ä¸­ä¸¤ä¸ªæ•°å­—ä¹‹å’Œ
   https://leetcode-cn.com/problems/kLl5u1/solution/jian-dan-yi-dong-javac-pythonjs-liang-sh-et4y/

   ```js
   /**
    * @param {number[]} numbers
    * @param {number} target
    * @return {number[]}
    */
   var twoSum = function (numbers, target) {
     let left = 0,
       right = numbers.length - 1;

     while (left < right) {
       let sum = numbers[left] + numbers[right];
       if (sum < target) {
         left++;
       } else if (sum > target) {
         right--;
       } else {
         return [left, right];
       }
     }
     return [];
   };
   ```

10. çˆ¬æ¥¼æ¢¯çš„æœ€å°‘æˆæœ¬

    ```js
    /**
     * @param {number[]} cost
     * @return {number}
     */
    var minCostClimbingStairs = function (cost) {
      let len = cost.length;
      let dp = new Array(len + 1);
      (dp[0] = cost[0]), (dp[1] = cost[1]);
      for (let i = 2; i <= len; i++) {
        dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];
      }
      return Math.min(dp[len - 1], dp[len - 2]);
    };
    ```

11. å·¦å³ä¸¤è¾¹å­æ•°ç»„çš„å’Œç›¸ç­‰

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var pivotIndex = function (nums) {
      let total = nums.reduce((a, b) => a + b);
      let sum = 0;
      for (let i = 0; i < nums.length; i++) {
        if (sum === total - sum - nums[i]) {
          return i;
        }
        sum += nums[i];
      }
      return -1;
    };
    ```

12. åˆ†å‰²ç­‰å’Œå­é›†

    ```js
    /**
     * @param {number[]} nums
     * @return {boolean}
     */
    var canPartition = function (nums) {
      let sum = nums.reduce((pre, cur) => pre + cur);
      if (sum % 2 !== 0) return false;

      let number = sum / 2;
      let dp = new Array(number + 1).fill(0);

      for (let i = 0; i < nums.length; i++) {
        for (let j = number; j >= nums[i]; j--) {
          dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
          if (dp[j] === number) {
            return true;
          }
        }
      }
      return false;
    };
    ```

13. æœ‰æ•ˆçš„å›æ–‡

    ```js
    /**
     * @param {string} s
     * @return {boolean}
     */
    var isPalindrome = function (s) {
      let str = s.toLowerCase();
      let res = [];
      for (let i = 0; i < str.length; i++) {
        if (str.charCodeAt(i) >= 97 && str.charCodeAt(i) <= 122)
          res.push(str[i]);
        if (str.charCodeAt(i) >= 48 && str.charCodeAt(i) <= 57)
          res.push(str[i]);
      }
      let resL = res.join("");
      let resR = res.reverse().join("");
      if (resL === resR) return true;
      return false;
    };
    ```

14. å±±å³°æ•°ç»„çš„é¡¶éƒ¨

    ```js
    /**
     * @param {number[]} arr
     * @return {number}
     */
    var peakIndexInMountainArray = function (arr) {
      let left = 1,
        right = arr.length - 2;
      while (left < right) {
        let mid = Math.floor((left + left) / 2);
        if (arr[mid - 1] < arr[mid] && arr[mid] > arr[mid + 1]) {
          return mid;
        } else if (arr[mid - 1] < arr[mid]) {
          left = mid + 1;
        } else {
          right = mid - 1;
        }
      }
      return left;
    };
    ```

15. æœ‰æ•ˆçš„å˜ä½è¯ | æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯

    ```js
    /**
     * @param {string} s
     * @param {string} t
     * @return {boolean}
     */
    var isAnagram = function (s, t) {
      let len1 = s.length,
        len2 = t.length;
      if (len1 !== len2 || s === t) return false;

      let map1 = new Map(),
        map2 = new Map();
      for (let i = 0; i < s.length; i++) {
        map1.set(s[i], map1.has(s[i]) ? map1.get(s[i]) + 1 : 1);
      }
      for (let i = 0; i < t.length; i++) {
        map2.set(t[i], map2.has(t[i]) ? map2.get(t[i]) + 1 : 1);
      }
      for (let [key, value] of map1) {
        if (!map2.has(key) || map2.get(key) !== value) {
          return false;
        }
      }
      return true;
      // æ–¹æ³•äºŒ æ’åºååˆ¤æ–­æ˜¯å¦ç›¸ç­‰
      // return s.length === t.length && [...s].sort().join() == [...t].sort().join()
    };
    ```

16. æ±‚å¹³æ–¹æ ¹

    ```js
    /**
     * @param {number} x
     * @return {number}
     */
    var mySqrt = function (x) {
      let left = 0,
        right = x;
      while (left < right) {
        // å¿…é¡»æ˜¯ceil, å› ä¸ºå­˜åœ¨8çš„æƒ…å†µï¼Œä¼šäº§ç”Ÿå¾ªç¯
        let mid = left + Math.ceil((right - left) / 2);
        if (mid * mid <= x) {
          left = mid;
        } else {
          right = mid - 1;
        }
      }
      return left;
    };
    ```

17. æ•°ç»„ç›¸å¯¹æ’åº

    ```js
    /**
     * @param {number[]} arr1
     * @param {number[]} arr2
     * @return {number[]}
     */
    var relativeSortArray = function (arr1, arr2) {
      let arr = Array(1001).fill(0);
      // ç»Ÿè®¡arr1æ•°å­—çš„å‡ºç°æ¬¡æ•°
      for (let num of arr1) {
        arr[num]++;
      }

      let res = [];
      for (let num of arr2) {
        // å‡ºç°æ¬¡æ•°>0ï¼Œå¾ªç¯æ¨å…¥res
        while (arr[num] > 0) {
          res.push(num);
          arr[num]--;
        }
      }
      // è§£å†³æœªå‡ºç°å…ƒç´ 
      for (let i = 0; i < arr.length; i++) {
        // é0é¡¹çš„ç´¢å¼• å¾ªç¯æ¨å…¥res
        while (arr[i] > 0) {
          res.push(i);
          arr[i]--;
        }
      }
      return res;
    };
    ```

18. æœ€å¤šåˆ é™¤ä¸€ä¸ªå­—ç¬¦å¾—åˆ°å›æ–‡

    ```js
    /**
     * @param {string} s
     * @return {boolean}
     */
    var validPalindrome = function (s) {
      var isHW = function (str, left, right) {
        for (let i = left, j = right; i < j; i++, j--) {
          if (str[i] !== str[j]) {
            return false;
          }
        }
        return true;
      };

      for (let left = 0, right = s.length - 1; left < right; left++, right--) {
        if (s[left] !== s[right]) {
          return isHW(s, left + 1, right) || isHW(s, left, right - 1);
        }
      }
      return true;
    };
    ```

## ä¸­ç­‰

- ä½è¿ç®—

1. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—(å…¶ä½™å…ƒç´ å‡å‡ºç°ä¸¤æ¬¡)
   ç”¨å¼‚æˆ–
   https://leetcode-cn.com/problems/single-number/solution/hua-jie-suan-fa-136-zhi-chu-xian-yi-ci-de-shu-zi-b/

   https://leetcode-cn.com/problems/single-number-ii/solution/ti-yi-lei-jie-wei-yun-suan-yi-wen-dai-ni-50dc/

   ```js
   var singleNumber = function (nums) {
     let res = 0;
     for (let num of nums) {
       res ^= num;
     }
     return res;
   };
   ```

2. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—(ä¸¤ä¸ªå…ƒç´ å‡ºç°ä¸€æ¬¡ï¼Œå…¶ä½™å‡å‡ºç°ä¸¤æ¬¡)

   ```js
   /**
    * @param {number[]} nums
    * @return {number[]}
    */
   var singleNumbers = function (nums) {
     let res1 = 0,
       res2 = 0;
     let diff = 0,
       bit = 1;
     // å¼‚æˆ–è¿ç®—ï¼Œ ç›®çš„æ˜¯æ‰¾åˆ°ä¸¤ä¸ªè½å•æ•°å€¼ï¼Œä¾¿äºåé¢åˆ†ç±»
     for (let num of nums) {
       diff ^= num;
     }
     // å·¦ç§»è¿ç®—ï¼Œæ‰¾åˆ°äºŒè€…æŸä¸€ä½çš„ä¸åŒï¼Œå°†è¿™1å®šä½åˆ†ç±»ä¾æ®ï¼Œåˆ†å¼€è½å•æ•°å€¼
     while ((diff & bit) === 0) {
       bit <<= 1;
     }
     for (let num of nums) {
       if (num & bit) {
         res1 ^= num;
       } else {
         res2 ^= num;
       }
     }
     return [res1, res2];
   };
   ```

3. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—(å…¶ä½™å…ƒç´ å‡å‡ºç°ä¸‰æ¬¡)
   å°†æ‰€æœ‰ nums[i]å¯¹åº”çš„äºŒè¿›åˆ¶æ•°çš„å¯¹åº”ä½æ±‚å’Œï¼Œå°†æ¯ä¸€å¯¹åº”ä½çš„å’Œå€¼ä¸ 3 è¿›è¡Œå–æ¨¡è¿ç®—ï¼Œå¾—åˆ°çš„ä½™æ•°å°±æ˜¯ç­”æ¡ˆçš„å¯¹åº”äºŒè¿›åˆ¶ä½çš„æ•°å€¼ã€‚

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var singleNumber = function (nums) {
     let res = 0;
     for (let i = 0; i < 32; i++) {
       let sum = 0;
       for (let num of nums) {
         sum += (num >> i) & 1;
       }
       if (sum % 3 === 1) {
         res |= 1 << i;
       }
     }
     return res;
   };
   ```

4. å•è¯é•¿åº¦çš„æœ€å¤§ä¹˜ç§¯
   https://leetcode-cn.com/problems/aseY1I/

   ```js
   /**
    * @param {string[]} words
    * @return {number}
    */
   var maxProduct = function (words) {
     let res = 0;
     var isSame = function (a, b) {
       for (let i = 0; i < a.length; i++) {
         if (b.indexOf(a[i]) !== -1) {
           return false;
         }
       }
       return true;
     };
     for (let i = 0; i < words.length - 1; i++) {
       for (let j = i + 1; j < words.length; j++) {
         if (isSame(words[i], words[j])) {
           let sum = words[i].length * words[j].length;
           if (res < sum) {
             res = sum;
           }
         }
       }
     }
     return res;
   };
   ```

   ```js
   /**
    * @param {string[]} words
    * @return {number}
    */
   var maxProduct = function (words) {
     let res = 0;
     let mask = new Array(words.length);

     for (let i = 0; i < words.length; i++) {
       let bitMask = 0;
       for (let c of words[i]) {
         // æ³¨æ„ä»¥ä¸‹å«ä¹‰
         bitMask |= 1 << (c.charCodeAt() - "a".charCodeAt());
       }
       mask[i] = bitMask;
     }

     for (let i = 0; i < words.length; i++) {
       for (let j = i + 1; j < words.length; j++) {
         // ===ä¼˜å…ˆ æ‰€ä»¥ä¸€å®šè¦åŠ ()
         if ((mask[i] & mask[j]) === 0) {
           res = Math.max(res, words[i].length * words[j].length);
         }
       }
     }
     return res;
   };
   ```

- æ»‘åŠ¨çª—å£

5. å’Œå¤§äºç­‰äº target çš„æœ€çŸ­å­æ•°ç»„

   ```js
   /**
    * @param {number} target
    * @param {number[]} nums
    * @return {number}
    */
   var minSubArrayLen = function (target, nums) {
     let left = 0;
     let sum = 0,
       res = nums.length + 1;
     for (let right = 0; right < nums.length; right++) {
       sum += nums[right];
       // æ³¨æ„ =
       while (sum >= target && left <= right) {
         res = Math.min(res, right - left + 1);

         sum -= nums[left];
         left++;
       }
     }
     return res === nums.length + 1 ? 0 : res;
   };
   ```

6. ä¹˜ç§¯å°äº k çš„å­æ•°ç»„

   ```js
   /**
    * @param {number[]} nums
    * @param {number} k
    * @return {number}
    */
   var numSubarrayProductLessThanK = function (nums, k) {
     let left = 0;
     let res = 0,
       sum = 1;
     for (let right = 0; right < nums.length; right++) {
       sum *= nums[right];

       while (sum >= k && left <= right) {
         sum /= nums[left];
         left++;
       }
       res += right >= left ? right - left + 1 : 0;
     }
     return res;
   };
   ```

- å‰ç¼€å’Œ

7. å’Œä¸º k çš„å­æ•°ç»„
   æ€è·¯: ä½¿ç”¨å‰ç¼€å’Œ
   https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484488&idx=1&sn=848f76e86fce722e70e265d0c6f84dc3&source=41#wechat_redirect

   ```js
   /**
    * @param {number[]} nums
    * @param {number} k
    * @return {number}
    */
   var subarraySum = function (nums, k) {
     let res = 0,
       sum = 0;
     let map = new Map();
     map.set(0, 1);

     for (let i = 0; i < nums.length; i++) {
       sum += nums[i];
       // å¿…é¡»å…ˆæ±‚å’Œå†è®¾ç½®mapå€¼
       res += map.get(sum - k) || 0;
       map.set(sum, (map.get(sum) || 0) + 1);
     }
     return res;
   };
   ```

8. 0 å’Œ 1 ä¸ªæ•°ç›¸åŒçš„å­æ•°ç»„
   æ€è·¯: ä½¿ç”¨å‰ç¼€å’Œ

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var findMaxLength = function (nums) {
     let map = new Map();
     let res = 0,
       sum = 0;
     map.set(0, -1);
     for (let i = 0; i < nums.length; i++) {
       let number = nums[i] === 0 ? -1 : 1;
       sum += number;
       // å¦‚æœå­˜åœ¨çš„è¯ï¼Œåˆ™å°†å½“å‰ç´¢å¼•å’Œä¹‹å‰å­˜å…¥çš„ç´¢å¼•å€¼ç›¸å‡  å–é¢˜ç›®è¦æ±‚çš„æœ€å¤§å€¼
       if (map.has(sum)) {
         res = Math.max(res, i - map.get(sum));
       } else {
         // è®°å½•å‰ç¼€å’Œ å’Œ ç´¢å¼•
         map.set(sum, i);
       }
     }
     return res;
   };
   ```

9. äºŒç»´å­çŸ©é˜µçš„å’Œ

- åŒæŒ‡é’ˆ

10. å­—ç¬¦ä¸²ä¸­çš„å˜ä½è¯

    ```js
    // åˆ©ç”¨æ»‘åŠ¨çª—å£
    /**
     * @param {string} s1
     * @param {string} s2
     * @return {boolean}
     */
    var checkInclusion = function (s1, s2) {
      if (s2.length < s1.length) return false;
      const arr = new Array(26).fill(0);

      function isZero(arr) {
        for (let i = 0; i < arr.length; i++) {
          if (arr[i] !== 0) return false;
        }
        return true;
      }
      for (let i = 0; i < s1.length; i++) {
        arr[s1.charCodeAt(i) - "a".charCodeAt(0)]++;
        arr[s2.charCodeAt(i) - "a".charCodeAt(0)]--;
      }
      if (isZero(arr)) {
        return true;
      }
      for (let i = s1.length; i < s2.length; i++) {
        arr[s2.charCodeAt(i) - "a".charCodeAt(0)]--;
        arr[s2.charCodeAt(i - s1.length) - "a".charCodeAt(0)]++;
        if (isZero(arr)) {
          return true;
        }
      }
      return false;
    };
    ```

11. å­—ç¬¦ä¸²ä¸­çš„æ‰€æœ‰å˜ä½è¯

    ```js
    /**
     * @param {string} s
     * @param {string} p
     * @return {number[]}
     */
    var findAnagrams = function (s, p) {
      let res = [];
      if (s.length < p.length) return [];
      let arr = new Array(26).fill(0);

      function isZero(arr) {
        for (let i = 0; i < arr.length; i++) {
          if (arr[i] !== 0) return false;
        }
        return true;
      }

      for (let i = 0; i < p.length; i++) {
        arr[p.charCodeAt(i) - "a".charCodeAt(0)]++;
        arr[s.charCodeAt(i) - "a".charCodeAt(0)]--;
      }
      if (isZero(arr)) {
        res.push(0);
      }

      for (let i = p.length; i < s.length; i++) {
        arr[s.charCodeAt(i) - "a".charCodeAt(0)]--;
        arr[s.charCodeAt(i - p.length) - "a".charCodeAt(0)]++;
        if (isZero(arr)) {
          res.push(i - p.length + 1);
        }
      }
      return res;
    };
    ```

- æ»‘åŠ¨çª—å£

12. ä¸å«é‡å¤å­—ç¬¦çš„æœ€é•¿å­å­—ç¬¦ä¸²
    https://leetcode-cn.com/problems/wtcaE1/solution/jian-dan-yi-dong-javac-pythonjshua-dong-dtang/

    ```js
    /**
     * @param {string} s
     * @return {number}
     */
    var lengthOfLongestSubstring = function (s) {
      // çª—å£ä¸­çš„å­—ç¬¦
      let window = {};
      let left = 0,
        res = 0;
      for (let right = 0; right < s.length; right++) {
        let str = s[right];
        window[str] = (window[str] || 0) + 1;
        while (window[str] > 1) {
          let strL = s[left];
          left++;
          window[strL]--;
        }
        res = Math.max(res, right - left + 1);
      }
      return res;
    };
    ```

13. å›æ–‡å­å­—ç¬¦ä¸²çš„ä¸ªæ•°
    æœ‰å¾ˆå¤šæ–¹æ³•

    ```js
    // åŒé‡forå¾ªç¯
    /**
     * @param {string} s
     * @return {number}
     */
    var countSubstrings = function (s) {
      let res = 0;
      var isHW = function (str, l, r) {
        for (let i = l, j = r; i <= j; i++, j--) {
          if (str[i] !== str[j]) return false;
        }
        return true;
      };
      for (let i = 0; i < s.length; i++) {
        for (let j = i; j < s.length; j++) {
          if (isHW(s, i, j)) {
            res++;
          }
        }
      }
      return res;
    };
    ```

    ```js
    // åŠ¨æ€è§„åˆ’
    const countSubstrings = function (s) {
      const len = s.length;
      const dp = new Array(len).fill(0).map(() => new Array(len).fill(false));
      let res = 0;
      for (let i = 0; i < len; i++) {
        for (let j = i; j >= 0; j--) {
          if (s[i] === s[j]) {
            // åˆå§‹åŒ–
            if (i - j <= 1) {
              // åˆå§‹åŒ– a å’Œ aa çš„æƒ…å†µ
              dp[i][j] = true;
            } else {
              // dp[i][j] å‘å†…æ”¶
              dp[i][j] = dp[i - 1][j + 1];
            }
          }
          res += dp[i][j] ? 1 : 0;
        }
      }
      return res;
    };
    ```

    ```js
    // åŒæŒ‡é’ˆæ³•, ä»¥æŸä¸ªå­—ç¬¦ä¸²ä¸ºä¸­å¿ƒå‘å¤–å»¶å±•
    /**
     * @param {string} s
     * @return {number}
     */
    var countSubstrings = function (s) {
      if (!s) return 0;

      var isHW = function (s, start, end) {
        let count = 0;
        while (
          start >= 0 &&
          end < s.length &&
          // ä¸‹é¢è¿™å¥ä¸€å®šè¦å†™åœ¨æ¡ä»¶é‡Œ, falseç›´æ¥break
          s.charAt(start) === s.charAt(end)
        ) {
          count++;
          start--;
          end++;
        }
        return count;
      };
      let res = 0;
      for (let i = 0; i < s.length; i++) {
        // é•¿åº¦ä¸ºå¥‡æ•°çš„å›æ–‡çš„å¯¹ç§°ä¸­å¿ƒåªæœ‰ä¸€ä¸ªå­—ç¬¦
        res += isHW(s, i, i);
        // é•¿åº¦ä¸ºå¶æ•°çš„å›æ–‡çš„å¯¹ç§°ä¸­å¿ƒåªæœ‰ä¸¤ä¸ªå­—ç¬¦
        res += isHW(s, i, i + 1);
      }
      return res;
    };
    ```

14. æœ€è¿‘æœ€å°‘ä½¿ç”¨ç¼“å­˜

    ```js
    /**
     * @param {number} capacity
     */
    var LRUCache = function (capacity) {
      this.cache = new Map();
      this.capacity = capacity;
    };

    /**
     * @param {number} key
     * @return {number}
     */
    LRUCache.prototype.get = function (key) {
      if (!this.cache.has(key)) {
        return -1;
      }
      const value = this.cache.get(key);
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    };

    /**
     * @param {number} key
     * @param {number} value
     * @return {void}
     */
    LRUCache.prototype.put = function (key, value) {
      if (this.cache.has(key)) {
        this.cache.delete(key);
      }
      // å½“ç¼“å­˜å®¹é‡è¾¾åˆ°ä¸Šé™æ—¶ï¼Œåˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®å€¼
      if (this.cache.size === this.capacity) {
        const iterator = this.cache.keys();
        this.cache.delete(iterator.next().value);
      }
      this.cache.set(key, value);
    };

    /**
     * Your LRUCache object will be instantiated and called as such:
     * var obj = new LRUCache(capacity)
     * var param_1 = obj.get(key)
     * obj.put(key,value)
     */
    ```

15. å˜ä½è¯ç»„

    ```js
    /**
     * @param {string[]} strs
     * @return {string[][]}
     */
    var groupAnagrams = function (strs) {
      let obj = {};
      strs.forEach((item) => {
        let key = item.split("").sort().join("");

        if (!(key in obj)) {
          obj[key] = [];
        }
        obj[key].push(item);
      });
      return Object.values(obj);
    };
    ```

16. æœ€å°æ—¶é—´å·®

17. åç¼€è¡¨è¾¾å¼

    ```js
    /**
     * @param {string[]} tokens
     * @return {number}
     */
    var evalRPN = function (tokens) {
      let numarr = [];
      let len = tokens.length;
      for (let i = 0; i < len; i++) {
        if (tokens[i] === "+") {
          let num1 = numarr.pop();
          let num2 = numarr.pop();
          numarr.push(num1 + num2);
        } else if (tokens[i] === "-") {
          let num1 = numarr.pop();
          let num2 = numarr.pop();
          numarr.push(num2 - num1);
        } else if (tokens[i] === "*") {
          let num1 = numarr.pop();
          let num2 = numarr.pop();
          numarr.push(num2 * num1);
        } else if (tokens[i] === "/") {
          let num1 = numarr.pop();
          let num2 = numarr.pop();
          numarr.push(parseInt(num2 / num1));
        } else {
          numarr.push(parseInt(tokens[i]));
        }
      }
      return numarr.pop();
    };
    ```

18. å°è¡Œæ˜Ÿç¢°æ’

19. æ¯æ—¥æ¸©åº¦

20. å€¼å’Œä¸‹æ ‡ä¹‹å·®éƒ½åœ¨ç»™å®šçš„èŒƒå›´å†… - æ¡¶æ’åº

    ```js
    /**
     * @param {number[]} nums
     * @param {number} k
     * @param {number} t
     * @return {boolean}
     */
    var containsNearbyAlmostDuplicate = function (nums, k, t) {
      for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
          let number = Math.abs(nums[i] - nums[j]);
          let index = Math.abs(i - j);
          if (number <= t && index <= k) {
            return true;
          }
        }
      }
      return false;
    };
    ```

21. å‡ºç°é¢‘ç‡æœ€é«˜çš„ k ä¸ªæ•°å­—

    ```js
    /**
     * @param {number[]} nums
     * @param {number} k
     * @return {number[]}
     */
    var topKFrequent = function (nums, k) {
      let obj = {},
        arr = [];
      for (let i = 0; i < nums.length; i++) {
        if (!obj[nums[i]]) {
          obj[nums[i]] = 1;
        } else {
          obj[nums[i]]++;
        }
      }
      for (let i in obj) {
        arr.push({ key: i, value: obj[i] });
      }
      arr.sort((a, b) => b.value - a.value);
      return arr.splice(0, k).map((item) => {
        return item.key;
      });
    };
    ```

22. å’Œæœ€å°çš„ k ä¸ªæ•°å¯¹ - æœ€å¥½ç”¨å †æ’åº

    ```js
    // åŒé‡forå¾ªç¯
    /**
     * @param {number[]} nums1
     * @param {number[]} nums2
     * @param {number} k
     * @return {number[][]}
     */
    var kSmallestPairs = function (nums1, nums2, k) {
      arr = [];
      for (let i = 0; i < nums1.length; i++) {
        for (let j = 0; j < nums2.length; j++) {
          let sum = nums1[i] + nums2[j];
          arr.push({ u: nums1[i], v: nums2[j], sum: sum });
        }
      }
      arr.sort((a, b) => a.sum - b.sum);
      return arr.splice(0, k).map((item) => {
        return [item.u, item.v];
      });
    };
    ```

23. ç‹’ç‹’åƒé¦™è•‰

24. åˆå¹¶åŒºé—´(éš¾)

    ```js
    /**
     * @param {number[][]} intervals
     * @return {number[][]}
     */
    var merge = function (intervals) {
      // æ’åºï¼Œ åƒä¸‡ä¸è¦å¿˜è®°
      intervals.sort((a, b) => a[0] - b[0]);
      let prevArr = intervals[0];
      let res = [];
      for (let i = 1; i < intervals.length; i++) {
        let curArr = intervals[i];
        if (curArr[0] > prevArr[1]) {
          res.push(prevArr);
          prevArr = curArr;
        } else {
          // è€ƒè™‘[1,9], [3,7]çš„æƒ…å†µå’Œ[1,3],[5,7]çš„æƒ…å†µ
          prevArr[1] = Math.max(curArr[1], prevArr[1]);
        }
      }
      res.push(prevArr);
      return res;
    };
    ```

25. æ•°ç»„ä¸­çš„ç¬¬ k å¤§çš„æ•°å­—
    https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/xie-gei-qian-duan-tong-xue-de-ti-jie-yi-kt5p2/

    ```js
    // åˆ©ç”¨æ’å…¥æ’åº
    /**
     * @param {number[]} nums
     * @param {number} k
     * @return {number}
     */
    var findKthLargest = function (nums, k) {
      let len = nums.length;
      for (let i = 1; i < len; i++) {
        let curValue = nums[i];
        let j = i - 1;
        while (j >= 0 && curValue < nums[j]) {
          nums[j + 1] = nums[j];
          j--;
        }
        nums[j + 1] = curValue;
      }
      return nums[len - k];
    };
    ```

    ```js
    /**
     * @param {number[]} nums
     * @param {number} k
     * @return {number}
     */
    var findKthLargest = function (nums, k) {
      let targetIndex = nums.length - k;
      let start = 0,
        end = nums.length - 1;
      let index = partition(nums, start, end);
      while (index != targetIndex) {
        if (index > targetIndex) {
          end = index - 1;
        } else {
          start = index + 1;
        }
        index = partition(nums, start, end);
      }
      return nums[index];
    };

    function partition(nums, left, right) {
      let pivot = nums[right]; // æœ€å³è¾¹çš„å…ƒç´ ä½œä¸º pivot å…ƒç´ 
      let pivotIndex = left; // pivotIndex åˆå§‹ä¸º left
      for (let i = left; i < right; i++) {
        // é€ä¸ªè€ƒå¯Ÿå…ƒç´ ï¼Œå’Œ pivot æ¯”è¾ƒ
        if (nums[i] < pivot) {
          // å¦‚æœå½“å‰å…ƒç´ æ¯” pivot å°, å°†å®ƒäº¤æ¢åˆ° pivotIndex çš„ä½ç½®
          [arr[pivotIndex], arr[i]] = [arr[i], arr[pivotIndex]];
          // swap(nums, i, pivotIndex);
          // æ¯æ‰¾åˆ°ä¸€ä¸ªæ¯”pivotå°çš„å…ƒç´ , pivotIndex+1, æ‰€ä»¥pivotIndexå·¦è¾¹éƒ½æ˜¯æ¯”pivotå°çš„
          pivotIndex++;
        }
      }
      // å¾ªç¯ç»“æŸæ—¶ï¼ŒpivotIndexå·¦è¾¹éƒ½æ˜¯æ¯”pivotå°çš„
      // pivotIndexå’Œrightäº¤æ¢ï¼Œæ›´æ–°pivotå…ƒç´ 
      [arr[pivotIndex], arr[right]] = [arr[right], arr[[pivotIndex]]];
      // swap(nums, right, pivotIndex);
      return pivotIndex; // è¿”å› pivotIndex ä¸‹æ ‡
    }

    //function swap(nums, i, j) {
    //  let temp = nums[i];
    //  nums[i] = nums[j];
    //  nums[j] = temp;
    //}
    ```

26. ç¿»è½¬å­—ç¬¦(éš¾)

    ```js
    /**
     * @param {string} s
     * @return {number}
     */
    var minFlipsMonoIncr = function (s) {
      // è®°å½•1çš„ä¸ªæ•°
      let countOf1 = s[0] === "0" ? 0 : 1;
      let dp = new Array(s.length).fill(0);
      for (let i = 1; i < s.length; i++) {
        if (s[i] === "0") {
          // s[i] ä¸º0, æœ‰ä¸¤ç§é€‰æ‹©
          // 1) å°†è‡ªå·±çš„0ç¿»è½¬ä¸º1
          // 2) å°†å‰é¢çš„æ‰€æœ‰1ç¿»è½¬ä¸º0
          dp[i] = Math.min(dp[i - 1] + 1, countOf1);
        } else {
          // è‹¥ä¸º1, ä¸å‰é¢ç›¸åŒ
          dp[i] = dp[i - 1];
          // è®°å½•1çš„ä¸ªæ•°
          countOf1++;
        }
      }
      return dp[s.length - 1];
    };
    ```

# leetcode éš¾

1. äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @return {number}
    */
   var maxPathSum = function (root) {
     // resåˆå§‹åŒ–å€¼ä¸ºæ•°å­—æœ€å°å€¼
     let res = Number.MIN_SAFE_INTEGER;

     var dfs = function (node) {
       if (!node) return 0;

       // ä¸‹é¢æœ€å¥½leftå’Œrightæ‹†å¼€æ¥å†™
       let left = dfs(node.left);
       let right = dfs(node.right);

       // å½“å‰èŠ‚ç‚¹å­æ ‘å†…éƒ¨çš„æœ€å¤§è·¯å¾„å’Œ(èŠ‚ç‚¹å€¼+å·¦å­æ ‘æœ€å¤§å’Œ+å³å­æ ‘æœ€å¤§å’Œ)
       let maxSum = node.val + left + right;
       res = Math.max(res, maxSum);

       // å½“å‰èŠ‚ç‚¹å­æ ‘å¯¹å¤–æä¾›çš„æœ€å¤§å’Œ
       let nodeSum = node.val + Math.max(left, right);

       // nodeSum<0çš„è¯åˆ™ä¸è¦è¿™æ¡è·¯ï¼Œå› ä¸ºä¸èƒ½å¸¦æ¥æ”¶ç›Š
       return nodeSum < 0 ? 0 : nodeSum;
     };
     dfs(root);
     return res;
   };
   ```

2. æ¥é›¨æ°´
   åˆ©ç”¨åŠ¨æ€è§„åˆ’

   ```js
   /**
    * @param {number[]} height
    * @return {number}
    */
   var trap = function (height) {
     const len = height.length;
     if (len <= 2) return 0;
     const maxLeft = new Array(len).fill(0);
     const maxRight = new Array(len).fill(0);
     // è®°å½•æ¯ä¸ªæŸ±å­å·¦è¾¹æŸ±å­æœ€å¤§é«˜åº¦
     maxLeft[0] = height[0];
     for (let i = 1; i < len; i++) {
       maxLeft[i] = Math.max(height[i], maxLeft[i - 1]);
     }
     // è®°å½•æ¯ä¸ªæŸ±å­å³è¾¹æŸ±å­æœ€å¤§é«˜åº¦
     maxRight[len - 1] = height[len - 1];
     for (let i = len - 2; i >= 0; i--) {
       maxRight[i] = Math.max(height[i], maxRight[i + 1]);
     }
     // æ±‚å’Œ
     let sum = 0;
     for (let i = 0; i < len; i++) {
       let count = Math.min(maxLeft[i], maxRight[i]) - height[i];
       if (count > 0) sum += count;
     }
     return sum;
   };
   ```

   ä¸‹é¢è¿™ç§æ–¹æ³•è¶…å‡ºæ—¶é—´é™åˆ¶

   ```js
   /**
    * @param {number[]} height
    * @return {number}
    */
   var trap = function (height) {
     let sum = 0;

     for (let i = 0; i < height.length; i++) {
       // ç¬¬ä¸€ä¸ªæŸ±å­å’Œæœ€åä¸€ä¸ªæŸ±å­ä¸æ¥é›¨æ°´
       if (i === 0 || i === height.length - 1) continue;

       // åˆå§‹åŒ–å·¦å³æŸ±å­çš„é«˜åº¦ä¸ºå½“å‰åˆ—
       let lHeight = height[i];
       let rHeight = height[i];

       // æ‰¾å‡ºå³è¾¹æŸ±å­çš„æœ€é«˜é«˜åº¦
       for (let r = i + 1; r < height.length; r++) {
         rHeight = Math.max(rHeight, height[r]);
       }
       // æ‰¾å‡ºå·¦è¾¹æŸ±å­çš„æœ€é«˜é«˜åº¦
       // for (let l=0; l<i; l++) {
       //     lHeight = Math.max(lHeight, height[l])
       // }
       for (let l = i - 1; l >= 0; l--) {
         if (height[l] > lHeight) lHeight = height[l];
       }
       // æ‰€æ±‚å½“å‰åˆ—çš„é›¨æ°´çš„å¤§å° = å·¦å³ä¸¤è¾¹çš„é«˜åº¦æœ€å°å€¼- å½“å‰åˆ—é«˜åº¦
       let h = Math.min(lHeight, rHeight) - height[i];
       if (h > 0) sum += h;
     }
     return sum;
   };
   ```

3. æœ€é•¿æœ‰æ•ˆæ‹¬å·

   ```js
   /**
    * @param {string} s
    * @return {number}
    */
   var longestValidParentheses = function (s) {
     let res = 0;
     let stack = [];
     // é¢„ç½®-1ä½œä¸ºæ–°çš„å‚ç…§ç‰©
     stack.push(-1);
     for (let i = 0; i < s.length; i++) {
       let str = s[i];
       if (str === "(") {
         stack.push(i);
       } else {
         // æ ˆé¡¶çš„å·¦æ‹¬å·è¢«åŒ¹é…, å‡ºæ ˆ
         stack.pop();
         if (stack.length) {
           // è®¡ç®—å½“å‰æœ‰æ•ˆè¿ç»­é•¿åº¦
           let sum = i - stack[stack.length - 1];
           res = Math.max(res, sum);
         } else {
           // å…¥æ ˆå……å½“å‚ç…§ç‰©
           stack.push(i);
         }
       }
     }
     return res;
   };
   ```

4. æœ€å°è¦†ç›–å­ä¸²

   ```js
   /**
    * @param {string} s
    * @param {string} t
    * @return {string}
    */
   var minWindow = function (s, t) {
     let res = Number.MAX_VALUE;
     // è®°å½•tå­—ç¬¦ä¸²éœ€è¦çš„å­—æ¯ä¸ªæ•°
     let need = {};
     // è®°å½•çª—å£ä¸­çš„å­—æ¯ä¸ªæ•°æƒ…å†µ
     let window = {};
     // å·¦zhizhen
     let left = 0;
     // æœ€å°è¦†ç›–å­ä¸²çš„èµ·å§‹ç´¢å¼•
     let start = 0;
     // è¡¨ç¤ºwindowä¸­å·²æœ‰çš„tçš„å­—æ¯ä¸ªæ•°
     let valid = 0;
     // ç»Ÿè®¡tä¸­çš„å­—ç¬¦
     for (let str of t) {
       need[str] = (need[str] || 0) + 1;
     }
     for (let right = 0; right < s.length; right++) {
       let str = s[right];
       // å¦‚æœå½“å‰å­—ç¬¦å­˜åœ¨äºtä¸­
       if (need[str]) {
         // æ›´æ–°çª—å£ç»Ÿè®¡
         window[str] = (window[str] || 0) + 1;
         // å½“å‰çª—å£å’Œéœ€è¦çš„å­—ç¬¦åŒ¹é…æ—¶ï¼ŒéªŒè¯æ•°é‡+1
         if (window[str] == need[str]) {
           valid++;
         }
       }
       // å½“éªŒè¯æ•°é‡å’Œéœ€è¦çš„å­—ç¬¦ä¸ªæ•°ç›¸åŒæ—¶,å¼€å§‹æ”¶ç¼©çª—å£
       while (valid == Object.keys(need).length) {
         // æ›´æ–°æœ€å°è¦†ç›–å­ä¸²
         if (right - left + 1 < res) {
           start = left;
           res = right - left + 1;
         }
         // å¤„ç†å·¦è¾¹å³å°†ç§»å‡ºçš„å­—ç¬¦
         let remove = s[left];
         left++;
         // ä¸»è¦éœ€è¦å¤„ç†ç§»å‡ºå­—ç¬¦ä¸²æ‰€å½±å“åˆ°çš„windowå’Œvalid
         if (need[remove]) {
           if (window[remove] == need[remove]) {
             valid--;
           }
           window[remove]--;
         }
       }
     }
     return res == Number.MAX_VALUE ? "" : s.substr(start, res);
   };
   ```

5. ç¼ºå¤±çš„ç¬¬ä¸€ä¸ªæ­£æ•°

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var firstMissingPositive = function (nums) {
     let len = nums.length;
     // è®©æ¯ä¸ªæ•°å­—néƒ½å›åˆ°ä¸‹æ ‡ä¸ºn-1çš„å®¶é‡Œã€‚
     for (let i = 0; i < len; i++) {
       while (nums[i] >= 1 && nums[i] <= len && nums[i] !== nums[nums[i] - 1]) {
         // num[index] æ”¾åˆ°å¯¹åº”çš„ num[num[index]-1]çš„ä½ç½®ä¸Š
         // æŠŠnum[i]æ”¾åˆ°å¯¹åº”çš„nums[nums[i]-1]çš„ä½ç½®ä¸Š
         let temp = nums[nums[i] - 1];
         nums[nums[i] - 1] = nums[i];
         nums[i] = temp;
         // [nums[i], nums[nums[i]-1]] = [nums[nums[i] -1], nums[i]]
       }
     }
     for (let i = 0; i < len; i++) {
       if (nums[i] !== i + 1) {
         return i + 1;
       }
     }
     return len + 1;
   };
   ```

6. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨

   ```js
   /**
    * Definition for singly-linked list.
    * function ListNode(val, next) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.next = (next===undefined ? null : next)
    * }
    */
   /**
    * @param {ListNode} head
    * @param {number} k
    * @return {ListNode}
    */
   var reverseKGroup = function (head, k) {
     const dummyNode = new ListNode(0, head);
     let pre = dummyNode;

     while (head) {
       let tail = pre;
       // æŸ¥çœ‹å‰©ä½™éƒ¨åˆ†é•¿åº¦æ˜¯å¦å¤§äºç­‰äº k
       for (let i = 0; i < k; i++) {
         tail = tail.next;
         // å¦‚æœtailä¸å­˜åœ¨äº†ï¼Œè¯´æ˜å·²ç»åˆ°è¾¾ç»ˆç‚¹
         if (!tail) {
           return dummyNode.next;
         }
       }
       const cur = tail.next;
       [head, tail] = reverseList(head, tail);
       // æŠŠå­é“¾è¡¨é‡æ–°æ¥å›åŸé“¾è¡¨
       pre.next = head;
       tail.next = cur;

       // å‘ä¸‹ä¸€æ®µè¿›è¡Œç§»åŠ¨
       pre = tail;
       head = tail.next;
     }
     // å¦‚æœåˆšå¥½å°±ç›´æ¥è¿”å›
     return dummyNode.next;
   };

   const reverseList = (head, tail) => {
     // åˆå§‹preä¸ºnull
     let pre = tail.next;
     let cur = head;
     // ç»ˆæ­¢æ¡ä»¶ pre == tailå°¾èŠ‚ç‚¹, è¯´æ˜å‰é¢çš„èŠ‚ç‚¹å·²ç»å…¨éƒ¨é€†åºæˆåŠŸ
     while (pre !== tail) {
       const temp = cur.next;
       cur.next = pre;
       pre = cur;
       cur = temp;
     }
     return [tail, head];
   };
   ```

7. åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨(éš¾)
   ```js
   /**
    * Definition for singly-linked list.
    * function ListNode(val, next) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.next = (next===undefined ? null : next)
    * }
    */
   /**
    * @param {ListNode[]} lists
    * @return {ListNode}
    */
   var mergeKLists = function (lists) {
     if (!lists.length) return null;
     return mergeList(lists, 0, lists.length - 1);
   };
   // ä½¿ç”¨å½’å¹¶æ’åº
   function mergeList(list, start, end) {
     // å¦‚æœ start === end è¯´æ˜åˆ†æ²»çš„åˆ†åˆ°å¤´äº†ï¼Œåªå‰©ä¸€ç»„å…ƒç´ äº†ï¼Œç›´æ¥è¿”å›ä½œä¸ºleftListæˆ–è€…rightListå³å¯
     if (start === end) {
       return list[start];
     }
     let mid = start + ((end - start) >> 1);
     let leftList = mergeList(list, start, mid);
     let rightList = mergeList(list, mid + 1, end);
     return merge(leftList, rightList);
   }
   function merge(head1, head2) {
     let dummyNode = new ListNode(0);
     let cur = dummyNode;
     while (head1 && head2) {
       if (head1.val < head2.val) {
         cur.next = head1;
         head1 = head1.next;
       } else {
         cur.next = head2;
         head2 = head2.next;
       }
       cur = cur.next;
     }
     cur.next = head1 ? head1 : head2;
     return dummyNode.next;
   }
   ```

# é¢è¯•é¢˜

1. ç¿»è½¬å•è¯é¡ºåº

   ```js
   //ç¿»è½¬å•è¯é¡ºåº
   var reverseWords = function (s) {
     //å°†ä¸¤ä¸ªå•è¯å¤šä½™çš„ç©ºæ ¼å‡å°‘åˆ°ä¸€ä¸ª
     s = s.replace(/ +/g, " ");
     return s.split(" ").reverse().join(" ").trim();
   };
   ```

2. å’Œä¸º s çš„è¿ç»­æ­£æ•°åºåˆ—(éš¾)

   ```js
   /**
    * @param {number} target
    * @return {number[][]}
    */
   var findContinuousSequence = function (target) {
     let res = [],
       sum = 0,
       path = [];

     for (let i = 1; i <= target; i++) {
       while (sum > target) {
         sum -= path.shift();
       }
       if (sum === target) {
         res.push([...path]);
       }
       sum += i;
       path.push(i);
     }
     return res;
   };
   ```

3. æœ€é•¿å›æ–‡å­ä¸²

   ```javascript
   var longestPalindrome = function (s) {
     if (s.length < 2) return s;

     let res = "";
     for (let i = 0; i < s.length; i++) {
       helper(i, i);
       helper(i, i + 1);
     }

     function helper(m, n) {
       while (m >= 0 && n < s.length && s[n] === s[m]) {
         m--;
         n++;
       }

       if (n - m - 1 > res.length) {
         res = s.slice(m + 1, n);
       }
     }
     return res;
   };
   ```

4. æœ€é•¿å…¬å…±å‰ç¼€(éš¾)

   ```js
   /**
    * @param {string[]} strs
    * @return {string}
    */
   var longestCommonPrefix = function (strs) {
     if (strs.length === 0) return "";
     let res = strs[0];
     for (let i = 1; i < strs.length; i++) {
       let j = 0;
       for (; j < strs[0].length && j < strs[i].length; j++) {
         if (res[j] !== strs[i][j]) {
           break;
         }
       }
       res = res.substr(0, j);
     }
     return res;
   };
   ```

5. æœ‰æ•ˆçš„æ‹¬å·

   ```js
   var isValid = function (s) {
     let stack = [];
     for (let val of s) {
       if (val === "(" || val === "[" || val === "{") {
         stack.push(val);
       } else {
         if (stack.length === 0) return false;
         if (val === ")" && stack.pop() !== "(") return false;
         if (val === "]" && stack.pop() !== "[") return false;
         if (val === "}" && stack.pop() !== "{") return false;
       }
     }
     return !stack.length;
   };
   ```

6. ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—
   https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/tu-jie-guan-fang-tui-jian-ti-jie-yong-li-yjbf/

   ```js
   var CQueue = function () {
     this.stackA = [];
     this.stackB = [];
   };

   CQueue.prototype.appendTail = function (value) {
     this.stackA.push(value);
   };

   CQueue.prototype.deleteHead = function () {
     if (this.stackB.length) {
       return this.stackB.pop();
     } else {
       while (this.stackA.length) {
         this.stackB.push(this.stackA.pop());
       }
       if (!this.stackB.length) {
         return -1;
       } else {
         return this.stackB.pop();
       }
     }

     // if (!this.stackB.length) {
     //   while (this.stackA.length) {
     //      this.stackB.push(this.stackA.pop())
     //   }
     // }
     // return this.stackB.pop()
   };
   ```

7. ç”¨æ ˆå®ç°é˜Ÿåˆ—

   ```js
   var MyQueue = function () {
     this.stackA = [];
     this.stackB = [];
   };

   /**
    * @param {number} x
    * @return {void}
    */
   MyQueue.prototype.push = function (x) {
     this.stackA.push(x);
   };

   /**
    * @return {number}
    */
   MyQueue.prototype.pop = function () {
     if (this.stackB.length) {
       return this.stackB.pop();
     }
     while (this.stackA.length) {
       this.stackB.push(this.stackA.pop());
     }
     if (!this.stackB.length) {
       return -1;
     } else {
       return this.stackB.pop();
     }
   };

   /**
    * @return {number}
    */
   MyQueue.prototype.peek = function () {
     if (!this.stackB.length) {
       while (this.stackA.length) {
         this.stackB.push(this.stackA.pop());
       }
     }
     return this.stackB[this.stackB.length - 1];
   };

   /**
    * @return {boolean}
    */
   MyQueue.prototype.empty = function () {
     return !this.stackA.length && !this.stackB.length;
   };

   /**
    * Your MyQueue object will be instantiated and called as such:
    * var obj = new MyQueue()
    * obj.push(x)
    * var param_2 = obj.pop()
    * var param_3 = obj.peek()
    * var param_4 = obj.empty()
    */
   ```

8. ç”¨é˜Ÿåˆ—å®ç°æ ˆ
   https://leetcode-cn.com/problems/implement-stack-using-queues/solution/wu-tu-guan-fang-tui-jian-ti-jie-yong-dui-63d4/

   ```js
   let MyStack = function () {
     this.queue = [];
     this._queue = [];
   };

   MyStack.prototype.push = function (x) {
     this.queue.push(x);
   };

   MyStack.prototype.pop = function () {
     while (this.queue.length > 1) {
       this._queue.push(this.queue.shift());
     }
     let ans = this.queue.shift();
     while (this._queue.length) {
       this.queue.push(this._queue.shift());
     }
     return ans;
   };

   MyStack.prototype.top = function () {
     return this.queue.slice(-1)[0];
   };

   MyStack.prototype.empty = function () {
     return !this.queue.length;
   };
   ```

9. æ’åºæ•°ç»„

10. åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„(éš¾)

    ```js
    /**
     * @param {number[]} nums1
     * @param {number} m
     * @param {number[]} nums2
     * @param {number} n
     * @return {void} Do not return anything, modify nums1 in-place instead.
     */
    var merge = function (nums1, m, nums2, n) {
      // å› æ­¤å¦‚æœæˆ‘ä»¬é‡‡ç”¨æ­£å‘éå†æ—¶ï¼Œnums2 çš„æ•°å€¼æ›¿æ¢åˆ° nums1 ä¸Šæ—¶ï¼Œå¦‚æœæ­¤æ—¶ nums1 ä¸Šè¯¥æ•°å­—è¿˜æ²¡æœ‰éå†åˆ°ï¼Œåˆ™ä¼šå¯¼è‡´è¯¥æ•°å­—ä¸¢å¤±ã€‚
      let index = m + n - 1;
      let i = m - 1,
        j = n - 1;
      while (i >= 0 && j >= 0) {
        if (nums1[i] < nums2[j]) {
          nums1[index] = nums2[j];
          j--;
        } else {
          nums1[index] = nums1[i];
          i--;
        }
        index--;
      }
      while (i >= 0) {
        nums1[index] = nums1[i];
        index--;
        i--;
      }
      while (j >= 0) {
        nums1[index] = nums2[j];
        index--;
        j--;
      }
      return nums1;
    };
    ```

11. æœç´¢æ—‹è½¬æ’åºæ•°ç»„

12. ç¿»è½¬é“¾è¡¨ II

13. èºæ—‹çŸ©é˜µ

    ```js
    /**
     * @param {number[][]} matrix
     * @return {number[]}
     */
    var spiralOrder = function (matrix) {
      let res = [];
      if (!matrix.length) return res;
      let left = 0,
        right = matrix[0].length - 1,
        top = 0,
        bottom = matrix.length - 1;

      while (left < right && top < bottom) {
        // éµå¾ªä¸Šå³ä¸‹å·¦çš„é¡ºåº
        for (let i = left; i < right; i++) res.push(matrix[top][i]);
        for (let i = top; i < bottom; i++) res.push(matrix[i][right]);
        for (let i = right; i > left; i--) res.push(matrix[bottom][i]);
        for (let i = bottom; i > top; i--) res.push(matrix[i][left]);
        // å››ä¸ªè¾¹ç•ŒåŒæ—¶æ”¶ç¼©ï¼Œè¿›å…¥å†…å±‚
        left++;
        right--;
        top++;
        bottom--;
      }
      // å‰©ä¸‹ä¸€åˆ—ï¼Œ ä»ä¸Šåˆ°ä¸‹ä¾æ¬¡æ·»åŠ 
      if (left == right) {
        for (let i = top; i <= bottom; i++) {
          res.push(matrix[i][left]);
        }
      }
      // å‰©ä¸‹ä¸€è¡Œï¼Œä»å·¦åˆ°å³ä¾æ¬¡æ·»åŠ 
      else if (top == bottom) {
        for (let i = left; i <= right; i++) {
          res.push(matrix[top][i]);
        }
      }
      return res;
    };
    ```

14. èºæ—‹çŸ©é˜µ II

    ```js
    /**
     * @param {number} n
     * @return {number[][]}
     */
    var generateMatrix = function (n) {
      let arr = new Array(n).fill().map((item) => Array(n).fill(0));
      let num = 1;
      let left = 0,
        right = n - 1,
        top = 0,
        bottom = n - 1;
      while (num <= n * n) {
        // è¡¨ç¤ºç¬¬ä¸€è¡Œå…¨éƒ¨è·å–ï¼Œä½™ä¸‹ä¸‰ä¸ªforå¾ªç¯ä¸å–ç¬¬ä¸€ä¸ªæ•°å­—
        for (let i = left; i <= right; i++) {
          arr[top][i] = num;
          num++;
        }
        top++;
        for (let i = top; i <= bottom; i++) {
          arr[i][right] = num;
          num++;
        }
        right--;
        for (let i = right; i >= left; i--) {
          arr[bottom][i] = num;
          num++;
        }
        bottom--;
        for (let i = bottom; i >= top; i--) {
          arr[i][left] = num;
          num++;
        }
        left++;
      }
      return arr;
    };
    ```

15. é‡æ’é“¾è¡¨

16. æ¯”è¾ƒç‰ˆæœ¬å·

    ```js
    let arr = ["0.1.1", "2.3.3", "0.302.1", "4.2", "4.3.5", "4.3.4.5"];
    arr.sort((a, b) => {
      let i = 0;
      const arr1 = a.split(".");
      const arr2 = b.split(".");

      while (true) {
        const s1 = arr1[i];
        const s2 = arr2[i];
        i++;
        // å…ˆåˆ¤æ–­é•¿åº¦ä¸ç›¸ç­‰çš„æƒ…å†µ,æ¯”å¦‚4.2å’Œ4.2.1ï¼Œå‰é¢éƒ½ç›¸ç­‰ï¼Œåªèƒ½æ¯”è¾ƒé•¿åº¦
        if (s1 === undefined || s2 === undefined) {
          return arr2.length - arr1.length;
        }
        // å¦‚æœå­—ç¬¦ç›¸ç­‰åˆ™æ¯”è¾ƒä¸‹ä¸€å­—ç¬¦
        if (s1 === s2) continue;
        // æœ€åæ¯”è¾ƒå­—ç¬¦å¤§å°
        return s2 - s1;
      }
    });
    console.log(arr);
    ```

17. å¥‡å¶æ’åº

18. äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {number}
     */
    var maxPathSum = function (root) {
      // resåˆå§‹åŒ–å€¼ä¸ºæ•°å­—æœ€å°å€¼
      let res = Number.MIN_SAFE_INTEGER;

      var dfs = function (node) {
        if (!node) return 0;

        let left = dfs(node.left);
        let right = dfs(node.right);

        // å½“å‰èŠ‚ç‚¹å­æ ‘å†…éƒ¨çš„æœ€å¤§è·¯å¾„å’Œ(èŠ‚ç‚¹å€¼+å·¦å­æ ‘æœ€å¤§å’Œ+å³å­æ ‘æœ€å¤§å’Œ)
        let maxSum = node.val + left + right;
        res = Math.max(res, maxSum);

        // å½“å‰èŠ‚ç‚¹å­æ ‘å¯¹å¤–æä¾›çš„æœ€å¤§å’Œ
        let nodeSum = node.val + Math.max(left, right);

        // nodeSum<0çš„è¯åˆ™ä¸è¦è¿™æ¡è·¯ï¼Œå› ä¸ºä¸èƒ½å¸¦æ¥æ”¶ç›Š
        return nodeSum < 0 ? 0 : nodeSum;
      };
      dfs(root);
      return res;
    };
    ```

19. æ¥é›¨æ°´
    åˆ©ç”¨åŠ¨æ€è§„åˆ’

    ```js
    /**
     * @param {number[]} height
     * @return {number}
     */
    var trap = function (height) {
      const len = height.length;
      if (len <= 2) return 0;
      const maxLeft = new Array(len).fill(0);
      const maxRight = new Array(len).fill(0);
      // è®°å½•æ¯ä¸ªæŸ±å­å·¦è¾¹æŸ±å­æœ€å¤§é«˜åº¦
      maxLeft[0] = height[0];
      for (let i = 1; i < len; i++) {
        maxLeft[i] = Math.max(height[i], maxLeft[i - 1]);
      }
      // è®°å½•æ¯ä¸ªæŸ±å­å³è¾¹æŸ±å­æœ€å¤§é«˜åº¦
      maxRight[len - 1] = height[len - 1];
      for (let i = len - 2; i >= 0; i--) {
        maxRight[i] = Math.max(height[i], maxRight[i + 1]);
      }
      // æ±‚å’Œ
      let sum = 0;
      for (let i = 0; i < len; i++) {
        let count = Math.min(maxLeft[i], maxRight[i]) - height[i];
        if (count > 0) sum += count;
      }
      return sum;
    };
    ```

    ä¸‹é¢è¿™ç§æ–¹æ³•è¶…å‡ºæ—¶é—´é™åˆ¶

    ```js
    /**
     * @param {number[]} height
     * @return {number}
     */
    var trap = function (height) {
      let sum = 0;

      for (let i = 0; i < height.length; i++) {
        // ç¬¬ä¸€ä¸ªæŸ±å­å’Œæœ€åä¸€ä¸ªæŸ±å­ä¸æ¥é›¨æ°´
        if (i === 0 || i === height.length - 1) continue;

        // åˆå§‹åŒ–å·¦å³æŸ±å­çš„é«˜åº¦ä¸ºå½“å‰åˆ—
        let lHeight = height[i];
        let rHeight = height[i];

        // æ‰¾å‡ºå³è¾¹æŸ±å­çš„æœ€é«˜é«˜åº¦
        for (let r = i + 1; r < height.length; r++) {
          rHeight = Math.max(rHeight, height[r]);
        }
        // æ‰¾å‡ºå·¦è¾¹æŸ±å­çš„æœ€é«˜é«˜åº¦
        // for (let l=0; l<i; l++) {
        //     lHeight = Math.max(lHeight, height[l])
        // }
        for (let l = i - 1; l >= 0; l--) {
          if (height[l] > lHeight) lHeight = height[l];
        }
        // æ‰€æ±‚å½“å‰åˆ—çš„é›¨æ°´çš„å¤§å° = å·¦å³ä¸¤è¾¹çš„é«˜åº¦æœ€å°å€¼- å½“å‰åˆ—é«˜åº¦
        let h = Math.min(lHeight, rHeight) - height[i];
        if (h > 0) sum += h;
      }
      return sum;
    };
    ```

20. æ¯”è¾ƒç‰ˆæœ¬å·

    ```js
    var compareVersion = function (version1, version2) {
      const arr1 = version1.split(".");
      const arr2 = version2.split(".");

      while (arr1.length && arr2.length) {
        const n1 = Number(arr1.shift());
        const n2 = Number(arr2.shift());

        if (n1 > n2) return 1;
        if (n1 < n2) return -1;
      }
      if (arr1.length) {
        // arr2 æ•°ç»„å·²ç»ä¸ºç©º
        return arr1.every((item) => Number(item) === 0) ? 0 : 1;
      }
      if (arr2.length) {
        // arr1 æ•°ç»„å·²ç»ä¸ºç©º
        return arr2.every((item) => Number(item) === 0) ? 0 : -1;
      }

      return 0;
    };
    ```

21. å­—ç¬¦ä¸²ç›¸ä¹˜

22. å¯»æ‰¾é‡å¤æ•°-ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆ
    https://leetcode-cn.com/problems/find-the-duplicate-number/solution/qian-duan-ling-hun-hua-shi-tu-jie-kuai-man-zhi-z-3/
    å‰ç«¯çµé­‚ç”»å¸ˆ ğŸ¨ å›¾è§£å¿«æ…¢æŒ‡é’ˆ

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var findDuplicate = function (nums) {
      let slow = 0,
        fast = 0;
      while (true) {
        slow = nums[slow];
        fast = nums[nums[fast]];
        if (slow === fast) {
          let _slow = 0;
          while (nums[slow] !== nums[_slow]) {
            slow = nums[slow];
            _slow = nums[_slow];
          }
          return nums[slow];
        }
      }
    };
    ```

23. æœ€é•¿æœ‰æ•ˆæ‹¬å·

    ```js
    /**
     * @param {string} s
     * @return {number}
     */
    var longestValidParentheses = function (s) {
      let res = 0;
      let stack = [];
      // é¢„ç½®-1ä½œä¸ºæ–°çš„å‚ç…§ç‰©
      stack.push(-1);
      for (let i = 0; i < s.length; i++) {
        let str = s[i];
        if (str === "(") {
          stack.push(i);
        } else {
          // æ ˆé¡¶çš„å·¦æ‹¬å·è¢«åŒ¹é…, å‡ºæ ˆ
          stack.pop();
          if (stack.length) {
            // è®¡ç®—å½“å‰æœ‰æ•ˆè¿ç»­é•¿åº¦
            // ä¾‹å¦‚)()()), æ˜¯æœ€åä¸€ä¸ªï¼‰çš„ç´¢å¼•-ç¬¬ä¸€ä¸ª ( çš„ç´¢å¼•
            let sum = i - stack[stack.length - 1];
            res = Math.max(res, sum);
          } else {
            // å…¥æ ˆå……å½“å‚ç…§ç‰©
            stack.push(i);
          }
        }
      }
      return res;
    };
    ```

24. æœ€å°è¦†ç›–å­ä¸²

    ```js
    /**
     * @param {string} s
     * @param {string} t
     * @return {string}
     */
    var minWindow = function (s, t) {
      let res = Number.MAX_VALUE;
      // è®°å½•tå­—ç¬¦ä¸²éœ€è¦çš„å­—æ¯ä¸ªæ•°
      let need = {};
      // è®°å½•çª—å£ä¸­çš„å­—æ¯ä¸ªæ•°æƒ…å†µ
      let window = {};
      // å·¦zhizhen
      let left = 0;
      // æœ€å°è¦†ç›–å­ä¸²çš„èµ·å§‹ç´¢å¼•
      let start = 0;
      // è¡¨ç¤ºwindowä¸­å·²æœ‰çš„tçš„å­—æ¯ä¸ªæ•°
      let valid = 0;
      // ç»Ÿè®¡tä¸­çš„å­—ç¬¦
      for (let str of t) {
        need[str] = (need[str] || 0) + 1;
      }
      for (let right = 0; right < s.length; right++) {
        let str = s[right];
        // å¦‚æœå½“å‰å­—ç¬¦å­˜åœ¨äºtä¸­
        if (need[str]) {
          // æ›´æ–°çª—å£ç»Ÿè®¡
          window[str] = (window[str] || 0) + 1;
          // å½“å‰çª—å£å’Œéœ€è¦çš„å­—ç¬¦åŒ¹é…æ—¶ï¼ŒéªŒè¯æ•°é‡+1
          if (window[str] == need[str]) {
            valid++;
          }
        }
        // å½“éªŒè¯æ•°é‡å’Œéœ€è¦çš„å­—ç¬¦ä¸ªæ•°ç›¸åŒæ—¶,å¼€å§‹æ”¶ç¼©çª—å£
        while (valid == Object.keys(need).length) {
          // æ›´æ–°æœ€å°è¦†ç›–å­ä¸²
          if (right - left + 1 < res) {
            start = left;
            res = right - left + 1;
          }
          // å¤„ç†å·¦è¾¹å³å°†ç§»å‡ºçš„å­—ç¬¦
          let remove = s[left];
          left++;
          // ä¸»è¦éœ€è¦å¤„ç†ç§»å‡ºå­—ç¬¦ä¸²æ‰€å½±å“åˆ°çš„windowå’Œvalid
          if (need[remove]) {
            if (window[remove] == need[remove]) {
              valid--;
            }
            window[remove]--;
          }
        }
      }
      return res == Number.MAX_VALUE ? "" : s.substr(start, res);
    };
    ```

25. å•è¯æ‹†åˆ† - å®Œå…¨èƒŒåŒ…ç»å…¸é¢˜

    ```js
    /**
     * @param {string} s
     * @param {string[]} wordDict
     * @return {boolean}
     */
    var wordBreak = function (s, wordDict) {
      // å®Œå…¨èƒŒåŒ…ç®—æ³•
      let dp = new Array(s.length + 1).fill(false);
      dp[0] = true;
      for (let i = 0; i <= s.length; i++) {
        for (let j = 0; j < wordDict.length; j++) {
          // å‰ææ˜¯s[i] >= wordDict[j].length
          if (i >= wordDict[j].length) {
            // s.slice(i-wordDict[j].length, i) === wordDict[j] å¹¶ä¸” ä¹‹å‰çš„ä¸ºtrue
            if (
              s.slice(i - wordDict[j].length, i) === wordDict[j] &&
              dp[i - wordDict[j].length]
            ) {
              dp[i] = true;
            }
          }
        }
      }
      return dp[s.length];
    };
    ```

26. ç§»æ‰ K ä½æ•°å­—

    ```js
    /**
     * @param {string} num
     * @param {number} k
     * @return {string}
     */
    var removeKdigits = function (num, k) {
      let stack = [];
      for (let i = 0; i < num.length; i++) {
        let c = num[i];
        // ç»´æŠ¤ä¸€ä¸ªå•è°ƒé€’å¢æ ˆ
        // å¦‚æœcæ¯”æ ˆé¡¶å…ƒç´ æ›´å°, åˆ™å¼¹å‡ºæ ˆé¡¶å…ƒç´ ï¼Œç§»é™¤çš„æ•°é‡k--
        // ä¸€å®šè¦ç¡®ä¿k>0
        while (k > 0 && stack.length && c < stack[stack.length - 1]) {
          stack.pop();
          // kè¡¨ç¤ºè¦ç§»é™¤çš„æ•°é‡
          k--;
        }
        // æ’é™¤æ‰ 0åœ¨æ ˆé¡¶çš„æƒ…å†µ(c === '0' && stack.legnth === 0)
        if (c != "0" || stack.length !== 0) {
          // å°†æ•°å­—å‹å…¥æ ˆä¸­
          stack.push(c);
        }
      }
      // å¦‚æœè¿˜æ²¡åˆ å¤Ÿkä¸ªå­—ç¬¦æ—¶
      while (k > 0) {
        stack.pop();
        k--;
      }
      // åˆ¤æ–­ num=10, k=2çš„æƒ…å†µ
      return stack.length === 0 ? "0" : stack.join("");
    };
    ```

27. å­—ç¬¦ä¸²ç›¸ä¹˜

    ```js
    /**
     * @param {string} num1
     * @param {string} num2
     * @return {string}
     */
    var multiply = function (num1, num2) {
      let m = num1.length,
        n = num2.length;
      // ç»“æœæœ€å¤šä¸ºm+nä½
      let arr = new Array(m + n).fill(0);
      // ä»ä¸ªä½æ•°å¼€å§‹é€ä½ç›¸ä¹˜
      for (let i = m - 1; i >= 0; i--) {
        for (let j = n - 1; j >= 0; j--) {
          let mul = +num1[i] * +num2[j];
          // ä¹˜ç§¯åœ¨reså¯¹åº”çš„ç´¢å¼•ä½ç½®, p1ä¸ºåä½, p2ä¸ºä¸ªä½
          let p1 = i + j;
          let p2 = i + j + 1;
          // è·å–ä¹˜ç§¯+å·²å­˜åœ¨çš„ä¸ªä½çš„æ•°å­—
          let sum = mul + arr[p2];
          arr[p2] = sum % 10;
          arr[p1] += Math.floor(sum / 10);
        }
      }
      // ç§»é™¤æ‰å¼€å¤´ä¸º0çš„æƒ…å†µ
      let i = 0;
      while (i < arr.length && arr[i] === 0) {
        i++;
      }
      // å°†arrè½¬ä¸ºstrå­—ç¬¦ä¸²
      let str = "";
      while (i < arr.length) {
        str += arr[i];
        i++;
      }
      // è¿˜éœ€è¦åˆ¤æ–­ 0å’Œ0çš„æƒ…å†µ
      return str.length == 0 ? "0" : str;
    };
    ```

28. æ—‹è½¬å›¾åƒ

    ```js
    /**
     * @param {number[][]} matrix
     * @return {void} Do not return anything, modify matrix in-place instead.
     */
    var rotate = function (matrix) {
      // å¯¹äºçŸ©é˜µä¸­ç¬¬ i è¡Œçš„ç¬¬ j ä¸ªå…ƒç´ ï¼Œåœ¨æ—‹è½¬åï¼Œå®ƒå‡ºç°åœ¨å€’æ•°ç¬¬ i åˆ—çš„ç¬¬ j ä¸ªä½ç½®ã€‚
      // matrix[i][j] ==> matrix[j][n-i-1]
      // å·¦ä¸Šè§’çš„ä½ç½®ç§»åˆ°å³ä¸Šè§’ï¼Œå³ä¸Šè§’ç§»åˆ°å³ä¸‹è§’ï¼Œå³ä¸‹è§’ç§»åˆ°å·¦ä¸‹è§’ï¼Œå·¦ä¸‹è§’ç§»åˆ°å·¦ä¸Šè§’çš„ä½ç½®
      let n = matrix.length;
      for (let i = 0; i < Math.floor(n / 2); i++) {
        for (let j = 0; j < Math.floor((n + 1) / 2); j++) {
          let temp = matrix[i][j];
          matrix[i][j] = matrix[n - j - 1][i];
          matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
          matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
          matrix[j][n - i - 1] = temp;
        }
      }
    };
    ```

29. ç¼ºå¤±çš„ç¬¬ä¸€ä¸ªæ­£æ•°

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var firstMissingPositive = function (nums) {
      let len = nums.length;
      // è®©æ¯ä¸ªæ•°å­—néƒ½å›åˆ°ä¸‹æ ‡ä¸ºn-1çš„å®¶é‡Œã€‚
      for (let i = 0; i < len; i++) {
        while (
          nums[i] >= 1 &&
          nums[i] <= len &&
          nums[i] !== nums[nums[i] - 1]
        ) {
          // num[index] æ”¾åˆ°å¯¹åº”çš„ num[num[index]-1]çš„ä½ç½®ä¸Š
          // æŠŠnum[i]æ”¾åˆ°å¯¹åº”çš„nums[nums[i]-1]çš„ä½ç½®ä¸Š
          let temp = nums[nums[i] - 1];
          nums[nums[i] - 1] = nums[i];
          nums[i] = temp;
          // [nums[i], nums[nums[i]-1]] = [nums[nums[i] -1], nums[i]]
        }
      }
      for (let i = 0; i < len; i++) {
        if (nums[i] !== i + 1) {
          return i + 1;
        }
      }
      return len + 1;
    };
    ```

30. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val, next) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.next = (next===undefined ? null : next)
     * }
     */
    /**
     * @param {ListNode} head
     * @param {number} k
     * @return {ListNode}
     */
    var reverseKGroup = function (head, k) {
      const dummyNode = new ListNode(0, head);
      let pre = dummyNode;

      while (head) {
        let tail = pre;
        // æŸ¥çœ‹å‰©ä½™éƒ¨åˆ†é•¿åº¦æ˜¯å¦å¤§äºç­‰äº k
        for (let i = 0; i < k; i++) {
          tail = tail.next;
          // å¦‚æœtailä¸å­˜åœ¨äº†ï¼Œè¯´æ˜å·²ç»åˆ°è¾¾ç»ˆç‚¹
          if (!tail) {
            return dummyNode.next;
          }
        }
        const cur = tail.next;
        // headè¿˜æ˜¯ä¹‹å‰çš„headèŠ‚ç‚¹ï¼Œtailè¿˜æ˜¯ä¹‹å‰çš„tailèŠ‚ç‚¹
        [head, tail] = reverseList(head, tail);
        // æŠŠå­é“¾è¡¨é‡æ–°æ¥å›åŸé“¾è¡¨
        pre.next = head;
        tail.next = cur;

        // å‘ä¸‹ä¸€æ®µè¿›è¡Œç§»åŠ¨
        pre = tail;
        head = tail.next;
      }
      // å¦‚æœåˆšå¥½å°±ç›´æ¥è¿”å›
      return dummyNode.next;
    };

    const reverseList = (head, tail) => {
      // åˆå§‹preä¸ºnull
      let pre = tail.next;
      let cur = head;
      // ç»ˆæ­¢æ¡ä»¶ pre == tailå°¾èŠ‚ç‚¹, è¯´æ˜å‰é¢çš„èŠ‚ç‚¹å·²ç»å…¨éƒ¨é€†åºæˆåŠŸ
      while (pre !== tail) {
        const temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
      }
      return [tail, head];
    };
    ```

31. åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨(éš¾)

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val, next) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.next = (next===undefined ? null : next)
     * }
     */
    /**
     * @param {ListNode[]} lists
     * @return {ListNode}
     */
    var mergeKLists = function (lists) {
      if (!lists.length) return null;
      return mergeList(lists, 0, lists.length - 1);
    };
    // ä½¿ç”¨å½’å¹¶æ’åº
    function mergeList(list, start, end) {
      // å¦‚æœ start === end è¯´æ˜åˆ†æ²»çš„åˆ†åˆ°å¤´äº†ï¼Œåªå‰©ä¸€ç»„å…ƒç´ äº†ï¼Œç›´æ¥è¿”å›ä½œä¸ºleftListæˆ–è€…rightListå³å¯
      if (start === end) {
        return list[start];
      }
      let mid = start + ((end - start) >> 1);
      let leftList = mergeList(list, start, mid);
      let rightList = mergeList(list, mid + 1, end);
      return merge(leftList, rightList);
    }
    function merge(head1, head2) {
      let dummyNode = new ListNode(0);
      let cur = dummyNode;
      while (head1 && head2) {
        if (head1.val < head2.val) {
          cur.next = head1;
          head1 = head1.next;
        } else {
          cur.next = head2;
          head2 = head2.next;
        }
        cur = cur.next;
      }
      cur.next = head1 ? head1 : head2;
      return dummyNode.next;
    }
    ```

32. å­—ç¬¦ä¸²è§£ç 

    ```js
    /**
     * @param {string} s
     * @return {string}
     */
    var decodeString = function (s) {
      let numStack = [];
      let strStack = [];
      let result = "";
      let num = 0;
      for (let i = 0; i < s.length; i++) {
        let c = s[i];
        // å¦‚æœcä¸ºæ•°å­—çš„æƒ…å†µ
        if (!isNaN(c)) {
          // è€ƒè™‘kä¸ºä¸¤ä½æ•°åŠä»¥ä¸Šçš„æƒ…å†µï¼Œ ä¾‹å¦‚ 12[c]
          num = num * 10 + Number(c);
        } else if (c === "[") {
          // æŠŠ[å‰çš„æ•°å­—å…¥æ ˆï¼ŒæŠŠä¹‹å‰çš„å­—ç¬¦ä¸²ä¿å­˜èµ·æ¥ï¼Œå…¥æ ˆ
          numStack.push(num);
          num = 0;
          strStack.push(result);
          result = "";
        } else if (c === "]") {
          // æ•°å­—å‡ºæ ˆ
          // ç»“æœä¸º åŸæ¥çš„å­—ç¬¦ä¸²(å­˜åœ¨strStackä¸­) + ç°æœ‰çš„result*æ•°å­—
          let time = numStack.pop();
          result = strStack.pop() + result.repeat(time);
        } else {
          result += c;
        }
      }
      return result;
    };
    ```

33. æœ€å°æ ˆ

    ```js
    var MinStack = function () {
      this.stack = [];
      this.min_stack = [Infinity];
    };

    /**
     * @param {number} val
     * @return {void}
     */
    MinStack.prototype.push = function (val) {
      this.stack.push(val);
      this.min_stack.push(
        Math.min(this.min_stack[this.min_stack.length - 1], val)
      );
    };

    /**
     * @return {void}
     */
    MinStack.prototype.pop = function () {
      this.stack.pop();
      this.min_stack.pop();
    };

    /**
     * @return {number}
     */
    MinStack.prototype.top = function () {
      return this.stack[this.stack.length - 1];
    };

    /**
     * @return {number}
     */
    MinStack.prototype.getMin = function () {
      return this.min_stack[this.min_stack.length - 1];
    };

    /**
     * Your MinStack object will be instantiated and called as such:
     * var obj = new MinStack()
     * obj.push(val)
     * obj.pop()
     * var param_3 = obj.top()
     * var param_4 = obj.getMin()
     */
    ```

34. äºŒå‰æ ‘çš„ç›´å¾„

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {number}
     */
    var diameterOfBinaryTree = function (root) {
      let res = 0;
      var getRes = function (node) {
        if (!node) return 0;
        let left = getRes(node.left);
        let right = getRes(node.right);
        sum = left + right;
        res = Math.max(sum, res);
        return Math.max(left, right) + 1;
      };
      getRes(root);
      return res;
    };
    ```

35. æœ€å¤§æ•°

    ```js
    /**
     * @param {number[]} nums
     * @return {string}
     */
    var largestNumber = function (nums) {
      // å› ä¸ºè¦æ˜¯æ•°å­—å°½å¯èƒ½å¤§, [10, 2] æ¯”è¾ƒ 102å’Œ210å“ªä¸ªæ›´å¤§
      // è‡ªå®šä¹‰æ’åº
      let res = nums.sort((a, b) => b + "" + a - (a + "" + b)).join("");
      // æ’é™¤æ‰ [0,0]çš„æƒ…å†µï¼Œå› ä¸ºæ’åºåä¼šè¿”å›'00'
      return res[0] === "0" ? "0" : res;
    };
    ```

36. xxx
